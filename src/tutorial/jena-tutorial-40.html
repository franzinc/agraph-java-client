<html>
<head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<title>Jena API Tutorial for AllegroGraph 4</title>

<style type="text/css">

.input { margin-left:4em; background-color:#ADDFFF;}
.output { margin-left:4em; background-color:#F1F1F1;}
.returnlink {font-size:small;  font-weight:normal; }
</style>
</head>
<body>
<h1>Java Jena API Tutorial for AllegroGraph 4</h1>
<p>This is an introduction to the Jena client API to the AllegroGraph 4 RDFStore&#8482; from <a href="http://agraph.franz.com/allegrograph/">Franz Inc.</a> </p>
<p>
The Java Jena API offers convenient and efficient
access to an AllegroGraph server from a Java-based application.  This API provides methods for
creating, querying and maintaining RDF data, and for managing the stored triples. </p>
<p>The Java Jena API emulates the <a href="http://jena.sourceforge.net/">Jena Semantic Web Framework</a> to make it easier to migrate from Jena to AllegroGraph.&nbsp; &nbsp; </p>
<h2 id="Contents">Contents</h2>
<table width="554" border="0" style="vertical-align:top" >
  <tr>
    <td width="249"><ul>
      <li><a href="#Overview">Overview</a></li>
<!--      <li><a href="#PrerequisitesWindows">Prerequisites (Windows)</a> </li>-->
      <li><a href="#PrerequisitesLinux">Prerequisites (Linux)</a></li>
      <li><a href="#Terminology">Terminology</a></li>
      <li><a href="#Creating a Repository">Creating a Repository and Triple Indices </a></li>
      <li><a href="#Asserting and Retracting Triples">Asserting and Retracting Triples</a></li>
      <li><a href="#A SPARQL Query">A SPARQL Query</a></li>
      <li><a href="#Statement Matching">Statement Matching</a></li>
      <!--<li><a href="#Datasets and Contexts">Datasets and Contexts</a></li> -->
    </ul></td>
    <td width="295"><ul>
      <li><a href="#Literal Values">Literal Values</a></li>
      <li><a href="#Importing Triples">Importing Triples</a></li>
	  <li><a href="#Exporting Triples">Exporting Triples</a></li>      
      <li><a href="#Namespaces">Namespaces</a></li>
      <!--<li><a href="#Free Text Search">Free Text Search</a></li> -->
      <li><a href="#Ask, Describe, and Construct Queries">Select, Ask, Describe, Construct, and Update Queries</a></li>
      <!--<li><a href="#Parametric Queries">Parametric Queries</a></li>
      <li><a href="#Range Matches">Range Matches</a></li>
      <li><a href="#Federated Repositories">Federated Repositories</a></li>  
	  <li><a href="#Prolog Rule Queries">Prolog Rule Queries</a></li>
      <li><a href="#Loading Prolog Rules">Loading Prolog Rules</a> </li> -->
      <li><a href="#RDFS++ Inference">RDFS++ Inference</a> </li>
      <!--<li><a href="#Geospatial Search">Geospatial Search</a> </li>
      <li><a href="#Social Network Analysis">Social Network Analysis</a> </li>
      <li><a href="#Transaction">Transactions </a></li> -->
      </ul>
    <p>&nbsp;</p></td>
  </tr>
</table>
<p>&nbsp;</p>
<h2 id="Overview">Overview&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>The Jena client tutorial rests on a simple architecture involving AllegroGraph, disk-based data files, Java, and a file of examples called JenaTutorialExamples.java.</p>
<table width="964" border="0">
  <tr>
    <td width="286"><p>The AllegroGraph 4 Java client distribution contains the Java Jena API. </p>
    <p>The Java client communicates with the AllegroGraph Server through HTTP port 10035 in this tutorial. Java and AllegroGraph may be installed on the same computer, but in practice one server is shared by multiple clients running on different machines. </p>
    <p>Load JenaTutorialExamples.java into Java to view the tutorial examples. </p></td>
    <td width="668"><img src="allegrographdiagramJena.jpg" width="668" height="443"></td>
  </tr>
</table>
<p>Each lesson in <strong>JenaTutorialExamples.java</strong> is encapsulated in a Java method, named exampleN(), where N ranges from 0 to 21 (or more). The function names are referenced in the title of each section to make it easier to compare the tutorial text and the living code of the examples file. We use the same example numbers across multiple APIs to facilitate comparisons among them, even though differences in API features sometimes leaves a gap in the sequence of numbers.</p>
<!--<h2 id="PrerequisitesLinux">Prerequisites (Windows) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<table border="1">
    <tr>
        <td width="867">The following procedure describes the installation of both the paid and free versions of AllegroGraph Server. Note that you cannot install both versions on the same computer. Follow the instructions that are appropriate to your version. </td>
    </tr>
</table>

<p>The tutorial examples can be run on a 32-bit Windows XP computer, running AllegroGraph and Java on the same computer (&quot;localhost&quot;). The tutorial assumes that AllegroGraph and Java 2.5 have  been installed and configured using this procedure:</p>
<p>&nbsp;</p>
<ol>
  <li>Download an AllegroGraph 4.0 installation file (agraph-4.0-windows.exe). The free edition is available <a href="/downloads/clp/ag_survey">here.</a> For the licensed edition please contact <a href="mailto:support@franz.com">Franz customer support</a> for a download link and authorizing key. </li>
  <li>Run the agraph-4.0-windows.exe to install AllegroGraph. The default installation directory is C:\Program Files\AllegroGraphFJE32 for the free edition, or c:\Program Files\AllegroGraphJEE32 for the licensed edition.</li>
  <li>Create a scratch directory for AllegroGraph to use for disk-based data storage. In this tutorial the directory is c:\tmp\scratch. If you elect to use a different location, the configuration and example files will have to be modified in the same way.</li>
  <li>
  Edit the <strong>agraph.cfg</strong> configuration file. You'll find it in the AllegroGraph installation directory. Set the following parameters to the indicated values. 
      <pre>:new-http-port 8080
:new-http-catalog ("c:/tmp/scratch")
:client-prolog t </pre>
  If you use a different port number, you will need to change the value of the AG_PORT variable at the top of tutorial_examples_40.java.
 It defaults to 8080. <br>
 <br>
 NOTE: On Windows Vista and Windows 7 systems, you must edit this file with elevated privileges. To do this, either start a Command Prompt with&nbsp; the context menu item &quot;Run as Administrator&quot; then edit the file using a text editor launched in that shell, or run your favorite editor with &quot;Run as Administrator&quot;. If you do not edit with elevated privileges, the file will look like it was saved successfully but the changes will not be seen by the service when it is started. This produces a &quot;cannot connect to server&quot; error message. 
  <li>To update AllegroGraph Server with recent patches, open a connection to the Internet. Run <strong>update.exe</strong>, which you will find the AllegroGraph installation directory. This automatically downloads and installs all current patches. </li>
  <li>On a Windows computer, the AllegroGraph Server runs as a Windows service. You have to restart this service to load the updates. Beginning at the Windows <strong>Start </strong>button, navigate this path: <br>
    <br>
  Start &gt; Settings &gt; Control Panel &gt; Administrative Tools &gt; Services. <br>
  <br>
  Locate the AllegroGraph Server service and select it. Click the <strong>Restart</strong> link to restart the service. </li>
  <li>This example used ActivePython 2.5 from ActiveState.com. Download and install the Windows installation file, 

 
  <a href="http://downloads.activestate.com/ActivePython/windows/2.5/ActivePython-2.5.2.2-win32-x86.msi">ActivePython-2.5.2.2-win32-x86.msi.</a> The default installation direction is C:\Python25.</li>
  <li>It is necessary to augment Python 2.5 with the CJSON package from python.cs.hu. Download and run the installation file, 

 
  <a href="http://python.cx.hu/python-cjson/python-cjson-1.0.3x6.win32-py2.5.exe">python-cjson-1.0.3x6.win32-py2.5.exe.</a> It will add files to the default Python directory structure.</li>
  <li>It is also necessary to augment Python 2.5 with the Pycurl package. Download and run the installation file, 

 
  <a href="http://pycurl.sourceforge.net/download/pycurl-ssl-7.18.2.win32-py2.5.exe">pycurl-ssl-7.18.2.win32-py2.5.exe.</a> It will add a small directory to your default Python directory structure. </li>
  <li>
    Link the Python software to the AllegroGraph Python API by setting a PYTHONPATH environment variable. For the free edition of AllegroGraph, the path value is:
      <pre>PYTHONPATH=C:\Program Files\AllegroGraphFJE40\python</pre>
For the licensed edition of AllegroGraph, the path value is:
      <pre>PYTHONPATH=C:\Program Files\AllegroGraphJEE40\python</pre>
In Windows XP, you can set an environment variable by 


 right-clicking on the <strong>My Computer</strong> icon, then navigate to Properties &gt; Advanced tab &gt; Environment Variables. Create a new variable showing the path to the AllegroGraph python subdirectory.<br>
 <br>
 <img src="environmentvariable.jpg" width="423" height="205"> <br>
  </li>
  <li>Start the ActivePython 2.5 PythonWin editor. Navigate this path:  <strong>Start</strong> button &gt; Programs &gt; ActiveState ActivePython 2.5 &gt;  PythonWin Editor. </li>
  <li>In the PythonWin editor, open the File menu, select Run, and browse to the location of the tutorial_examples_40.java file. It will be in the AllegroGraph\python subdirectory. Run this file. This loads and runs the Python tutorial examples.</li>
</ol>
-->
<h2 id="PrerequisitesLinux">Prerequisites (Linux) &nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>The tutorial examples can be run on a Linux system, running AllegroGraph and the examples on the same computer (&quot;localhost&quot;). The tutorial assumes that AllegroGraph has been installed and configured using the procedure posted on <a href="/agraph/support/documentation/v4/server-installation.html">this webpage</a>. The Java Jena API and the Jena tutorial are bundled with the AllegroGraph Java Client. </p>
<h2 id="Terminology">Terminology&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>We need to clarify some terminology before proceeding. </p>
<ul>
  <li>&quot;RDF&quot; is the <a href="http://www.w3.org/RDF/">Resource Description Framework</a> defined by the <a href="http://www.w3.org/">World Wide Web Consortium</a> (W3C). It provides an elegantly simple means for describing multi-faceted resource objects and for linking them into complex relationship graphs. AllegroGraph Server creates, searches, and manages such RDF graphs. </li>
  <li>A &quot;URI&quot; is a <a href="http://www.ietf.org/rfc/rfc2396.txt">Uniform Resource Identifier</a>. It is a label used to uniquely identify various types of entities in an RDF graph. A typical URI looks a lot like a web address: http://example.org/project/class#number. In spite of the resemblance, a URI is not a web address. It is simply a unique label. </li>
  <li>A &quot;triple&quot; is a data statement, a &quot;fact,&quot; stored in RDF format. It states that a  resource has an attribute with a value. It consists of three fields:</li>
  <ul>  <li>Subject: The first field contains the URI that uniquely identifies the resource that this triple describes. </li>
  <li>Predicate: The second field contains the URI identifying a property of this resource, such as its color or size, or a relationship between this resource and another one, such as parentage or ownership. </li>
  <li>Object: The third field is the value of the property. It could be a literal value, such as &quot;red,&quot; or the URI of a linked resource. </li>
  </ul>
  <li>A &quot;quad&quot; is a triple with an added &quot;context&quot; field, which is used to divide the repository into &quot;subgraphs.&quot; This context or subgraph is just a URI label that appears in the fourth field of related triples. </li>
  <li>A &quot;quint&quot; is a quad with a fifth field used for the &quot;tripleID.&quot; AllegroGraph Server implements all triples as quints behind the scenes. The fourth and fifth fields are often ignored, however, so we speak casually of &quot;triples,&quot; and sometimes of &quot;quads,&quot; when it would be more rigorous to call them all &quot;quints.&quot; </li>
  <li>A &quot;resource description&quot; is a collection of triples that all have the same URI in the subject field. In other words, the triples all describe attributes of the same thing.</li>
  <li>A &quot;statement&quot; is a client-side Java object that describes a triple (quad, quint).&nbsp; </li>
  <li>A &quot;model&quot; is a Jena object that provides methods for managing a specific RDF graph. </li>
</ul>
  <table width="809" border="0">
  <tr>
    <td width="378"><p>In the context of AllegroGraph Server: </p>
      <ul>
        <li>A &quot;catalog&quot; is a list of repositories owned by an AllegroGraph server.</li>
        <li>A &quot;repository&quot; is a collection of triples within a Catalog, stored and indexed on a hard disk.</li>
        <li>A &quot;context&quot; is a subgraph of the triples in a repository. </li>
        <li>If contexts are not in use, the triples are stored in the background (default) graph.</li>
        <li>A Jena &quot;model&quot; corresponds to a background graph or subgraph in AllegroGraph.  </li>
      </ul>      </td>
    <td width="421"><img src="catalogrepositorycontext.jpg" width="397" height="400" align="right"></td>
  </tr>
</table>
  <p>&nbsp;</p>
  <h2 id="Creating a Repository">Creating a Repository and Triple Indices (example1()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
  <p>The first task is to have our AllegroGraph Server open a repository. This task is implemented in<strong> example1()</strong> from<strong> JenaTutorialExamples.java</strong>. </p>
<p>In <strong>example1()</strong> we build a chain of Java objects,  ending in a &quot;connection&quot; object that lets us manipulate triples in a specific repository. The overall process of generating the connection object follows 
this diagram:</p>
  <table width="809" border="0">
  <tr>
    <td width="378"><p>The example1() and example2() functions open a repository by building a series of client-side objects, culminating in a &quot;Model&quot; object. These objects can be passed to other methods in JenaTutorialExamples.java. </p>
      <p>The Model object is the unique interface to a specific RDF graph. </p></td>
    <td width="421"><img src="createconnectionobjectJena.jpg"></td>
  </tr>
</table>

<p>The example first connects to an AllegroGraph Server by providing the endpoint (host IP address and port number) of an already-launched AllegroGraph server. You'll also need a user name and password. This creates a client-side server object, which can access the AllegroGraph server's list of available catalogs through the <strong>server.listCatalogs()</strong> method:</p>
<pre class="input">public class JenaTutorialExamples {

	static private final String SERVER_URL = "http://localhost:10035";
	static private final String CATALOG_ID = "java-catalog";
	static private final String REPOSITORY_ID = "jenatutorial";
	static private final String USERNAME = "test";
	static private final String PASSWORD = "xyzzy";
	static private final String TEMPORARY_DIRECTORY = "";

	static final String FOAF_NS = "http://xmlns.com/foaf/0.1/";

	/**
	 * Creating a Repository
	 */
	public static AGGraphMaker example1(boolean close)
			throws Exception {
		// Tests getting the repository up.
		println("\nStarting example1().");
		AGServer server = new AGServer(SERVER_URL, USERNAME, PASSWORD);
		println("Available catalogs: " + server.listCatalogs());</pre>
<p>This is the output so far:</p>
<pre class="output">Starting example example1().<br>Available catalogs: [/, java-catalog, python-catalog]</pre>
<p>These examples use either the default root catalog (denoted as &quot;/&quot;) or a named catalog called &quot;java-catalog&quot;. </p>
<p>In the next line of example1(), we use the server's <strong>getRootCatalog()</strong> method to create a client-side catalog object connected to AllegroGraph's default rootCatalog, as defined in the AllegroGraph configuration file. The catalog object has methods such as <strong>getCatalogName()</strong> and <strong>getAllRepositories()</strong> that we can use to investigate the catalogs on the AllegroGraph server. When we look inside the root catalog, we can see which repositories are available:</p>
<pre class="input">		AGCatalog catalog = server.getCatalog(CATALOG_ID);<br>		println(&quot;Available repositories in catalog &quot;<br>				+ (catalog.getCatalogName()) + &quot;: &quot;<br>				+ catalog.listRepositories());</pre>
<p>The corresponding output lists the available repositories.  (When you run the examples, you may see a different list of repositories.)</p>
<pre class="output">Available catalogs: [/, java-catalog]<br>Available repositories in catalog java-catalog: []</pre>
<p>In the examples, we are careful to delete previous state before continuing. You probably would not do this in your actual application:</p>
<pre class="input">         catalog.deleteRepository(REPOSITORY_ID); </pre>
<p>The next step is to create a client-side repository object representing the repository we wish to open, by calling the
  <strong>createRepository()</strong> method of the catalog object. We have to provide the name of the desired repository (REPOSITORY_ID in this case, which is bound to the string &quot;jenatutorial&quot;). </p>
<pre class="input">		AGRepository myRepository = catalog.createRepository(REPOSITORY_ID);<br>		println(&quot;Got a repository.&quot;);<br>		myRepository.initialize();<br>		println(&quot;Initialized repository.&quot;);</pre>
<p>A new or renewed repository must be initialized, using the <strong>initialize()</strong> method of the repository object. If you try to initialize a repository twice you get a warning message in the Java window but no exception. </p>
<pre class="output"> Got a repository.
 Initialized repository.
</pre>
<p>The goal of all this object-building has been to create a client-side <strong>repositoryConnection</strong> object, which we casually refer to as the &quot;connection&quot; or &quot;connection object.&quot; The repository object's <strong>getConnection()</strong> method returns this connection object. The function <strong>closeBeforeExit()</strong> maintains a list of connection objects and automatically cleans them up when the client exits. </p>
<pre class="input">		AGRepositoryConnection conn = myRepository.getConnection();<br>		closeBeforeExit(conn);<br>		println(&quot;Got a connection.&quot;);<br>		println(&quot;Repository &quot; + (myRepository.getRepositoryID())<br>				+ &quot; is up! It contains &quot; + (conn.size()) + &quot; statements.&quot;);</pre>
 <p>The <strong>size()</strong> method of the connection object returns how many triples are present. In the example1() function, this number should always be zero because we deleted, recreated, and cleared the repository. This is the output in the Java window: </p>
<pre class="output"> Got a connection.<br> Repository javatutorial is up! It contains 0 statements.</pre>
 <p>When using the Java Jena API, it is necessary to create a GraphMaker object on the connection. This object will let us create graphs in the connection's repository.</p>
 <pre class="input">		AGGraphMaker maker = new AGGraphMaker(conn);
		println(&quot;Got a graph maker for the connection.&quot;); </pre>
 <pre class="output">Got a graph maker for the connection.</pre>
 <p>Whenever you create a new repository, you should stop to consider which kinds of triple indices you will need.&nbsp; This is an important efficiency decision.&nbsp; AllegroGraph uses a set of sorted indices to quickly identify a contiguous block of triples that are likely to match a specific query pattern. </p>
 <p>These indices are identified by names that describe their organization. The default set of indices are called <strong>spogi, posgi, ospgi, gspoi, gposi, gospi</strong>, and<strong> i</strong> , where: </p>
 <ul>
     <li>S stands for the subject URI. </li>
     <li>P stands for the predicate URI. </li>
     <li>O stands for the object URI or literal. </li>
     <li>G stands for the graph URI. </li>
     <li>I stands for the triple identifier (its unique id number within the triple store). </li>
 </ul>
 <p> The order of the letters denotes how the index has been organized. For instance, the <strong>spogi</strong> index contains all of the triples in the store, sorted first by subject, then by predicate, then by object, and finally by graph. The triple id number is present as a fifth column in the index. If you know the URI of a desired resource (the <em>subject</em> value of the query pattern), then the <strong>spogi</strong> index lets you retrieve all triples with that subject as a single block.&nbsp; </p>
 <p>The idea is to provide your respository with the indices that your queries will need, and to avoid maintaining indices that you will never need.&nbsp; </p>
 <p>We can use the connection object's <strong>listValidIndices()</strong> method to examine the list of all possible AllegroGraph triple indices: </p>
 <pre class="input">        List&lt;String&gt; indices = conn.listValidIndices();<br>        println(&quot;All valid triple indices: &quot; + indices);</pre>
 <p>This is the list of all possible valid indices:</p>
 <pre class="output">All valid triple indices: [spogi, spgoi, sopgi, sogpi, sgpoi, sgopi, psogi, 
psgoi, posgi, pogsi, pgsoi, pgosi, ospgi, osgpi, opsgi, opgsi, ogspi, ogpsi, 
gspoi, gsopi, gpsoi, gposi, gospi, gopsi, i]</pre>
 <p>AllegroGraph can generate any of these indices if you need them, but it creates only seven indices by default.&nbsp; We can see the current indices by using the connection object's <strong>listIndices()</strong> method:</p>
 <pre class="input">        indices = conn.listIndices();<br>        println(&quot;Current triple indices: &quot; + indices);</pre>
 <p>There are currently seven indices:</p>
 <pre class="output">Current triple indices: [i, gospi, gposi, gspoi, ospgi, posgi, spogi]</pre>
 <p>The indices that begin with &quot;g&quot; are sorted primarily by subgraph (or &quot;context&quot;).&nbsp; If you application does not use subgraphs, you should consider removing these indices from the repository.&nbsp; You don't want to build and maintain triple indices that your application will never use.&nbsp; This wastes CPU time and disk space.&nbsp; The connection object has a convenient <strong>dropIndex()</strong> method:</p>
 <pre class="input">        println(&quot;Removing graph indices...&quot;);<br>        conn.dropIndex(&quot;gospi&quot;);<br>        conn.dropIndex(&quot;gposi&quot;);<br>        conn.dropIndex(&quot;gspoi&quot;);<br>        indices = conn.listIndices();<br>        println(&quot;Current triple indices: &quot; + indices);</pre>
 <p>Having dropped three of the triple indices, there are now four remaining:</p>
 <pre class="output">Removing graph indices...<br>Current triple indices: [i, ospgi, posgi, spogi]</pre>
 <p>The <strong>i</strong> index is for deleting triples by using the triple id number.&nbsp; The <strong>ospgi</strong> index is sorted primarily by object value, which makes it possible to grab a range of object values as a single block of triples from the index.&nbsp; Similarly, the <strong>posgi</strong> index lets us reach for a block of triples that all share the same predicate.&nbsp; We mentioned previously that the <strong>spogi</strong> index lets us retrieve blocks of triples that all have the same subject URI.&nbsp; </p>
 <p>As it happens, we may have been overly hasty in eliminating all of the graph indices.&nbsp; AllegroGraph can find the right matches as long as there is <em>any</em> one index present, but using the &quot;right&quot; index is much faster.&nbsp; Let's put one of the graph indices back, just in case we need it. We'll use the connection object's<strong> addIndex()</strong> method: </p>
 <pre class="input">        println(&quot;Adding one graph index back in...&quot;);<br>        conn.addIndex(&quot;gspoi&quot;);<br>        indices = conn.listIndices();<br>        println(&quot;Current triple indices: &quot; + indices);</pre>
 <pre class="output">Adding one graph index back in...<br>Current triple indices: [i, gspoi, ospgi, posgi, spogi]</pre>
 <p>In its default mode, example1() closes the maker and connection. It can optionally return the maker when called by another method, as will occur in several examples below. If you are done with these objects, closing them and shutting them down will free resources.</p>
 <pre class="input">		if (close) {<br>			// tidy up<br>			maker.close();<br>			conn.close();<br>			myRepository.shutDown();<br>			return null;<br>		}<br>		return maker;<br>	}</pre>

<h2 id="Asserting and Retracting Triples">Asserting and Retracting Triples (example2()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>




<p>

In example2(), we show how
to create resources describing two
people, Bob and Alice, by asserting individual triples into the repository. The example also retracts and replaces a triple.  Assertions and retractions to the triple store
are executed by 'add' and 'remove' methods belonging to the Model object. The Model object is created by the GraphMaker object, which we will obtain from example1(), above. </p>
<p>Before asserting a triple, we have to generate the URI values for the subject, predicate and object fields. The Java Jena API to AllegroGraph Server predefines a number of classes and predicates for the RDF, RDFS, XSD, and OWL ontologies.  RDF.type is one of the predefined predicates we will use. </p>
<p>
The example2() function begins by calling example1() to create the appropriate GraphMaker object, which is bound to the variable <strong>maker</strong>. We will use the GraphMaker to create a <strong>graph</strong>, and then a <strong>model</strong> object that is connected to the graph. We will need both objects in order to proceed. </p>
<pre class="input">	public static AGModel example2(boolean close) throws Exception {<br>		println(&quot;\nStarting example2().&quot;);<br>		AGGraphMaker maker = example1(false);<br>		AGGraph graph = maker.getGraph();<br>		AGModel model = new AGModel(graph);</pre>
 <p>The next step is to begin assembling the resources we will need for the example. The model's <strong>createResource()</strong> method creates a Resource object based on a string URI. These are the resources for &quot;Bob&quot; and &quot;Alice&quot;:</p>
 <pre class="input">		Resource alice = model<br>				.createResource(&quot;http://example.org/people/alice&quot;);<br>		Resource bob = model.createResource(&quot;http://example.org/people/bob&quot;);</pre>
 <p>Both Bob and Alice will have a &quot;name&quot; attribute. We also need to declare a class of Persons, so we can state that Bob and Alice are Persons. </p>
 <pre class="input">		Property name = model<br>				.createProperty(&quot;http://example.org/ontology/name&quot;);<br>		Resource person = model<br>				.createResource(&quot;http://example.org/ontology/Person&quot;);</pre>
 <p>The name attributes will contain literal values. We have to generate the Literal objects from strings: </p>
 <pre class="input">		Literal bobsName = model.createLiteral(&quot;Bob&quot;);<br>		Literal alicesName = model.createLiteral(&quot;Alice&quot;);</pre>
 <p>The next line prints out the number of triples currently in the repository. </p>
 <pre class="input">		println(&quot;Triple count before inserts: &quot; + model.size());</pre>
<pre class="output">Triple count before inserts:  0
</pre>
<p>Now we assert four triples, two for Bob and two more for Alice, using the model's <strong>add()</strong> method. Note the use of RDF.type, which is an attribute of the RDF object in <a href="http://jena.sourceforge.net/javadoc/index.html">http://jena.sourceforge.net/javadoc/index.html</a>. This attribute is set the the URI of the rdf:type predicate, which is used to indicate the class of a resource. </p>
<pre class="input">		// Alice's name is &quot;Alice&quot;<br>		model.add(alice, name, alicesName);<br>		// Alice is a person<br>		model.add(alice, RDF.type, person);<br>		// Bob's name is &quot;Bob&quot;<br>		model.add(bob, name, bobsName);<br>		// Bob is a person, too.<br>		model.add(bob, RDF.type, person);</pre>
<p>After the assertions, we count triples again (there should be four) and print out the triples for inspection. If we call <strong>model.listStatements()</strong> with no arguments, it dumps every triple in the graph. (We'll be a little more selective in example4().) </p>
<pre class="input">		println(&quot;Added four triples.&quot;);<br>		println(&quot;Triple count after inserts: &quot; + (model.size()));<br>		StmtIterator result = model.listStatements();<br>		while (result.hasNext()) {<br>			Statement st = result.next();<br>			println(st);<br>		}</pre>
<p>This is the output at this point. We see four triples, two about Alice and two about Bob:</p>
<pre class="output">Triple count after inserts: 4<br>[http://example.org/people/bob, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/ontology/Person]<br>[http://example.org/people/bob, http://example.org/ontology/name, &quot;Bob&quot;]<br>[http://example.org/people/alice, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/ontology/Person]<br>[http://example.org/people/alice, http://example.org/ontology/name, &quot;Alice&quot;]</pre>
<p>We see two resources of type &quot;person,&quot; each with a literal name. </p>
<p>The next step is to demonstrate how to remove a triple. Use the <strong>remove()</strong> method of the model object, and supply a triple pattern that matches the target triple. In this case we want to remove Bob's name triple from the repository. Then we'll count the triples again to verify that there are only three remaining. </p>
<pre class="input">		model.remove(bob, name, bobsName);<br>		println(&quot;Removed one triple.&quot;);<br>		println(&quot;Triple count after deletion: &quot; + (model.size()));
</pre>
 
 <pre class="output">Removed one triple.<br>Triple count after deletion: 3</pre>
 <p>Finally, we re-assert Bob's name so we can use it in subsequent examples, and we'll return the model object for other examples to use. Example2() ends with a condition that either closes the connection or passes the model object on to the next method for reuse. </p>
 <pre class="input">		model.add(bob, name, bobsName);<br>		if (close) {<br>			model.close();<br>			graph.close();<br>			maker.close();<br>			return null;<br>		}<br>		return model;<br>	}</pre>
 <h2 id="A SPARQL Query">A SPARQL Query (example3()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>SPARQL stands for  the &quot;<a href="http://www.w3.org/TR/rdf-sparql-query/">SPARQL Protocol and RDF Query Language</a>,&quot; a recommendation of the <a href="http://www.w3.org/">World Wide Web Consortium (W3C)</a>. SPARQL is a query language for retrieving RDF triples. </p>
 <p>Our next example illustrates how to evaluate a SPARQL query. This is the simplest query, the one that returns all triples. Note that example3() continues with the four triples created in example2(). </p>
 <pre class="input">	public static void example3() throws Exception {<br>		AGModel model = example2(false);<br>		println(&quot;\nStarting example3().&quot;);<br>		try {<br>			String queryString = &quot;SELECT ?s ?p ?o  WHERE {?s ?p ?o .}&quot;;</pre>
 <p>The SELECT clause returns the variables ?s, ?p and ?o. The variables are bound to the subject, predicate and object values of each triple that satisfies the WHERE clause. In this case the WHERE clause is unconstrained. The dot (.) in the fourth position signifies the end of the pattern. </p>
<p>Queries must be created by offering the queryString to the <strong>AGQueryFactory.create()</strong> method. This creates a query object. The query object is passed, in turn, to the <strong>AGQueryExecutionFactory.create() </strong>method where it is combined with the <strong>model</strong> for the graph you want to search. The resulting <strong>AGQueryExecution</strong> object has a method, <strong>execSelect()</strong>, that runs the query and returns a ResultSet. </p>
<pre class="input">			AGQuery sparql = AGQueryFactory.create(queryString);<br>			QueryExecution qe = AGQueryExecutionFactory.create(sparql, model);<br>			try {<br>				ResultSet results = qe.execSelect();</pre>
<p>The ResultSet is an iterator that gives access to a sequence of bindingSets. Below we illustrate one (rather heavyweight) method for extracting the values
  from a binding set, indexed by the name of the corresponding column variable
in the SELECT clause.</p>
<pre class="input">				while (results.hasNext()) {<br>					QuerySolution result = results.next();<br>					RDFNode s = result.get(&quot;s&quot;);<br>					RDFNode p = result.get(&quot;p&quot;);<br>					RDFNode o = result.get(&quot;o&quot;);<br>					System.out.println(&quot; { &quot; + s + &quot; &quot; + p + &quot; &quot; + o + &quot; . }&quot;);</pre>
<pre class="output">Starting example3().<br> { http://example.org/people/alice http://example.org/ontology/name Alice . }<br> { http://example.org/people/alice http://www.w3.org/1999/02/22-rdf-syntax-ns#type http://example.org/ontology/Person . }<br> { http://example.org/people/bob http://www.w3.org/1999/02/22-rdf-syntax-ns#type http://example.org/ontology/Person . }<br> { http://example.org/people/bob http://example.org/ontology/name Bob . }</pre>
<p>The best practice is to close the various objects as soon as you finish using them, in order to free resources. </p>
<pre class="input">			} finally {<br>				qe.close();<br>			}<br>		} finally {<br>			model.close();<br>		}<br>	}</pre>
<h2 id="Statement Matching">Statement Matching (example4()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>

<p>
The listStatements() method of the model object provides a simple way to perform unsophisticated queries. This method lets you enter a mix of required values and wildcards, and retrieve all matching triples. (If you need to perform sophisticated tests and comparisons you should use the SPARQL query instead.)</p>
<p>
This is the <strong>example4()</strong> function of JenaTutorialExamples.java. It begins by calling example2() to create a model object and populate the jenarepository with four triples describing Bob and Alice. </p>
<pre class="input">	public static void example4() throws Exception {<br>		AGModel model = example2(false);<br>		println(&quot;\nStarting example4().&quot;);</pre>
<p>We're going to search for triples that mention Alice, so we have to create an &quot;Alice&quot; resource object to use in the search pattern. Think of this as Alice's URI. </p>
<pre class="input">		Resource alice = model<br>				.createResource(&quot;http://example.org/people/alice&quot;);</pre>
<p> Now we search for triples with Alice's URI in the subject position.  The &quot;null&quot; values are wildcards for the predicate and object positions of the triple. The RDFNode token indicates that we want to object of the triple to be either a resource URI or a literal value. The object value can sometimes be a string, which we are excluding from this pattern. </p>
<pre class="input">		StmtIterator statements = model.listStatements(alice, null,<br>				(RDFNode) null);</pre>
<p>The listStatements() method returns a statement iterator object (bound to the variable &quot;statements&quot; in this case). This object can be iterated over, exposing one result statement at a time. </p>
<pre class="input">		try {<br>			while (statements.hasNext()) {<br>				println(statements.next());<br>			}</pre>
<p>This prints out the two matching triples for &quot;Alice.&quot; </p>
<pre class="output">Starting example4().<br>[http://example.org/people/alice, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/ontology/Person]<br>[http://example.org/people/alice, http://example.org/ontology/name, &quot;Alice&quot;]</pre>
<p>At this point it is good form to close the statements and model objects because they occupy memory. </p>
<pre class="input">		} finally {<br>			statements.close();<br>			model.close();<br>		}<br>	}</pre>
<p>&nbsp;</p>

<h2 id="Literal Values">Literal Values (example5())&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>The next example, <strong>example5()</strong>, illustrates some variations on what we have seen so far.  The example creates and asserts typed literal values, including  language-specific literals.</p>
<p>First, example5() obtains a model object from example2(). Then it clears the repository of all existing triples. </p>
<pre class="input">	public static void example5() throws Exception {<br>        AGModel model = example2(false);<br>        println(&quot;\nStarting example5().&quot;);<br>        model.removeAll();</pre>
<p>For sake of coding efficiency, it is good practice to create variables for namespace strings. We'll use this namespace again and again in the following lines. </p>
<pre class="input">        String exns = &quot;http://example.org/people/&quot;;</pre>
<p>The example creates new resources describing Alice and Ted. Apparently Bob was on vacation. We will use these resources in the subject field of the triples. </p>
<pre class="input">        Resource alice = model.createResource(&quot;http://example.org/people/alice&quot;);<br>        Resource ted = model.createResource(exns + &quot;ted&quot;);</pre>
<p>These are the four predicates used in the example: age, weight, favoriteColor, and birthdate. They are instantiated as Property objects. We would usually refer to these are predicates in AllegroGraph. </p>
<pre class="input">        Property age = model.createProperty(exns,&quot;age&quot;);<br>        Property weight = model.createProperty(exns, &quot;weight&quot;);<br>        Property favoriteColor = model.createProperty(exns, &quot;favoriteColor&quot;);<br>        Property birthdate = model.createProperty(exns, &quot;birthdate&quot;);</pre>
<p>Favorite colors, declared as Literals in English (default) and French. </p>
<pre class="input">        Literal red = model.createLiteral(&quot;Red&quot;);<br>        Literal rouge = model.createLiteral(&quot;Rouge&quot;, &quot;fr&quot;);</pre>
<p>Age values, declared as INT, LONG, and untyped: </p>
<pre class="input">        Literal fortyTwoInt = model.createTypedLiteral(&quot;42&quot;, XSDDatatype.XSDint);<br>        Literal fortyTwoLong = model.createTypedLiteral(&quot;42&quot;, XSDDatatype.XSDlong);<br>        Literal fortyTwoUntyped = model.createLiteral(&quot;42&quot;);</pre>
<p>Birth date values, declared as DATE and DATETIME types. </p>
<pre class="input">        Literal date = model.createTypedLiteral(&quot;1984-12-06&quot;, XSDDatatype.XSDdate);<br>        Literal time = model.createTypedLiteral(&quot;1984-12-06T09:00:00&quot;, XSDDatatype.XSDdateTime);</pre>
<p>Weights, written as floats, but one untyped and the other declared to be a float. </p>
<pre class="input">        Literal weightUntyped = model.createLiteral(&quot;120.5&quot;);<br>        Literal weightFloat = model.createTypedLiteral(&quot;120.5&quot;, XSDDatatype.XSDfloat);</pre>
 <p>The model object's createStatement() method assembles the elements of a triple, but does not yet add them to the repository. Here are Alice's and Ted's ages assembled into statements. (We gave Ted two age triples because Bob was on vacation. The triples have the same value cast into different types.) </p>
 <pre class="input">        Statement stmt1 = model.createStatement(alice, age, fortyTwoInt);<br>        Statement stmt2 = model.createStatement(ted, age, fortyTwoLong);<br>        Statement stmt3 = model.createStatement(ted, age, fortyTwoUntyped);</pre>
<p>The Java Jena API to AllegroGraph Server uses the <strong>model.add()</strong> method for asserting triples into the repository. It can create triples from statements, or from URIs and literal values, as shown here. </p>
<pre class="input">        model.add(stmt1);<br>        model.add(stmt2);<br>        model.add(stmt3);<br>        model.add(alice, weight, weightFloat);<br>        model.add(ted, weight, weightUntyped);<br>        model.add(alice, favoriteColor, red);<br>        model.add(ted, favoriteColor, rouge);<br>        model.add(alice, birthdate, date);<br>        model.add(ted, birthdate, time);</pre>
<p>The RDF/SPARQL spec is very conservative when matching various combinations of literal values. The match and query statements below illustrate how some of these combinations perform. Note that this loop uses the listStatements() method to retrieve triples. We'll do SPARQL queries in a minute. </p>
<pre class="input">        for (Literal obj : new Literal[] {null, fortyTwoInt, fortyTwoLong, fortyTwoUntyped,  weightFloat, weightUntyped,<br>                    red, rouge}) {<br>            println( &quot;\nRetrieve triples matching &quot; + obj + &quot;.&quot;);<br>            StmtIterator statements = model.listStatements(null, null, obj);<br>            try {<br>                while (statements.hasNext()) {<br>                    println(statements.next());<br>                }<br>            } finally {<br>                statements.close();<br>            }<br>        }</pre>
<p>The listStatements() method looks for all triples that have a specific value in the object position. It doesn't care which resource or which predicate are in play. The loop cycles through various typed and untyped Literals to see which triples match each request. </p>
<p>These are the results of the tests in this loop. The first iteration uses &quot;null&quot; as the object value. This is a wildcard value, and matches all the triples in the repository: </p>
<pre class="output">Retrieve triples matching null.<br>[http://example.org/people/ted, http://example.org/people/birthdate, &quot;1984-12-06T09:00:00Z&quot;^^http://www.w3.org/2001/XMLSchema#dateTime]<br>[http://example.org/people/alice, http://example.org/people/birthdate, &quot;1984-12-06Z&quot;^^http://www.w3.org/2001/XMLSchema#date]<br>[http://example.org/people/ted, http://example.org/people/favoriteColor, &quot;Rouge&quot;@fr]<br>[http://example.org/people/alice, http://example.org/people/favoriteColor, &quot;Red&quot;]<br>[http://example.org/people/ted, http://example.org/people/weight, &quot;120.5&quot;]<br>[http://example.org/people/alice, http://example.org/people/weight, &quot;1.20500006E2&quot;^^http://www.w3.org/2001/XMLSchema#float]<br>[http://example.org/people/ted, http://example.org/people/age, &quot;42&quot;]<br>[http://example.org/people/ted, http://example.org/people/age, &quot;42&quot;^^http://www.w3.org/2001/XMLSchema#long]<br>[http://example.org/people/alice, http://example.org/people/age, &quot;42&quot;^^http://www.w3.org/2001/XMLSchema#int]<br>[http://example.org/people/bob, http://example.org/ontology/name, &quot;Bob&quot;]<br>[http://example.org/people/bob, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/ontology/Person]<br>[http://example.org/people/alice, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/ontology/Person]<br>[http://example.org/people/alice, http://example.org/ontology/name, &quot;Alice&quot;]</pre>
<p>What triples match &quot;42&quot; declared as an INT? [fortyTwoInt]</p>
<pre class="output">Retrieve triples matching 42^^http://www.w3.org/2001/XMLSchema#int.<br>[http://example.org/people/alice, http://example.org/people/age, &quot;42&quot;^^http://www.w3.org/2001/XMLSchema#int]</pre>
<p>What triples match &quot;42&quot; declared as an LONG? [fortyTwoLong]</p>
<pre class="output">Retrieve triples matching 42^^http://www.w3.org/2001/XMLSchema#long.<br>[http://example.org/people/ted, http://example.org/people/age, &quot;42&quot;^^http://www.w3.org/2001/XMLSchema#long]</pre>
<p>What triples match &quot;42&quot; untyped? [fortyTwoUntyped] </p>
<pre class="output">Retrieve triples matching 42.<br>[http://example.org/people/ted, http://example.org/people/age, &quot;42&quot;]</pre>
<p>What triples match &quot;120.5&quot; declared as a FLOAT? [weightFloat]</p>
<pre class="output">Retrieve triples matching 120.5^^http://www.w3.org/2001/XMLSchema#float.<br>[http://example.org/people/alice, http://example.org/people/weight, &quot;1.20500006E2&quot;^^http://www.w3.org/2001/XMLSchema#float]</pre>
<p>What triples match &quot;120.5&quot; untyped? [weightUntyped]</p>
<pre class="output"></p>Retrieve triples matching 120.5.<br>[http://example.org/people/ted, http://example.org/people/weight, &quot;120.5&quot;]</pre>
<p>What triples match &quot;Red&quot; as a simple string? [Red] </p>
<pre class="output"></p>Retrieve triples matching Red.<br>[http://example.org/people/alice, http://example.org/people/favoriteColor, &quot;Red&quot;]</pre>
<p>What triples match &quot;Rouge&quot; declared as a French string? [Rouge] </p>
<pre class="output"></p>Retrieve triples matching Rouge@fr.<br>[http://example.org/people/ted, http://example.org/people/favoriteColor, &quot;Rouge&quot;@fr]</pre>
<p>The next loop builds and evaluates a SPARQL query instead of using listStatements(). It also shows examples of putting typed values into the search criteria without creating Literal objects as an intermediate step. It also shows how to  extract individual subject, predicate and object values from each returned triple. </p>
<pre class="input">        for (String obj : new String[]{&quot;42&quot;, &quot;\&quot;42\&quot;&quot;, &quot;120.5&quot;, &quot;\&quot;120.5\&quot;&quot;, &quot;\&quot;120.5\&quot;^^xsd:float&quot;,<br>                                       &quot;\&quot;Rouge\&quot;@fr&quot;, &quot;\&quot;Rouge\&quot;&quot;, &quot;\&quot;1984-12-06\&quot;^^xsd:date&quot;}) {<br>            println( &quot;\nQuery triples matching &quot; + obj + &quot;.&quot;);<br>            String queryString = &quot;PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; SELECT ?s ?p ?o WHERE {?s ?p ?o . filter (?o = &quot; + obj + &quot;)}&quot;;<br>            AGQuery query = AGQueryFactory.create(queryString);<br>            QueryExecution qe = AGQueryExecutionFactory.create(query, model);<br>			try {<br>				ResultSet results = qe.execSelect();<br>				while (results.hasNext()) {<br>					QuerySolution result = results.next();<br>					RDFNode s = result.get(&quot;s&quot;);<br>					RDFNode p = result.get(&quot;p&quot;);<br>					RDFNode o = result.get(&quot;o&quot;);<br>					println(&quot;  &quot; + s + &quot; &quot; + p + &quot; &quot; + o);<br>				}</pre>
<p>What triples match &quot;42&quot; (which is an int). We get both ints and longs. 
<pre class="output">Query triples matching 42.<br>  http://example.org/people/alice http://example.org/people/age &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#int&gt;<br>  http://example.org/people/ted http://example.org/people/age &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#long&gt;</pre>
<p>What triples match &quot;\&quot;42\&quot;&quot; (which is a string?) </p>
<pre class="output">Query triples matching &quot;42&quot;.<br>  http://example.org/people/ted http://example.org/people/age 42</pre>
<p>What triples match &quot;120.5&quot; (a float)? </p>
<pre class="output">Query triples matching 120.5.<br>  http://example.org/people/alice http://example.org/people/weight 1.20500006E2^^&lt;http://www.w3.org/2001/XMLSchema#float&gt;</pre>
<p>What triples match &quot;\&quot;120.5\&quot;&quot; (a string)? </p>
<pre class="output">Query triples matching &quot;120.5&quot;.<br>  http://example.org/people/ted http://example.org/people/weight 120.5</pre>
<p>What triples match&quot;\&quot;120.5\&quot;^^xsd:float&quot; (a float)? </p>
<pre class="output">Query triples matching &quot;120.5&quot;^^xsd:float.<br>  http://example.org/people/alice http://example.org/people/weight 1.20500006E2^^&lt;http://www.w3.org/2001/XMLSchema#float&gt;</pre>
<p>What triples match &quot;\&quot;Rouge\&quot;@fr&quot; (a French string)? </p>
<pre class="output">Query triples matching &quot;Rouge&quot;@fr.<br>  http://example.org/people/ted http://example.org/people/favoriteColor Rouge@fr<br>
</pre>
<p>What triples match &quot;Rouge&quot; (a string)? </p>
<pre class="output">Query triples matching &quot;Rouge&quot;. 
[No matches. General string fails to match French string.]</p></pre>
<p>In the following example, we use listStatements() to match a DATE object. We have used a DATE literal in the object position of the triple pattern: </p> 
<pre class="input">            println(&quot;\nRetrieve triples matching DATE object.&quot;);<br>             StmtIterator statements = model.listStatements(null, null, date);<br>            try {<br>                while (statements.hasNext()) {<br>                    println(statements.next());<br>                }<br>            } finally {<br>                statements.close();<br>            }</pre> 
<pre class="output">Retrieve triples matching DATE object.<br>[http://example.org/people/alice, http://example.org/people/birthdate, &quot;1984-12-06Z&quot;^^http://www.w3.org/2001/XMLSchema#date]</pre>
<p>Note the string representation of the DATE object in the following query.  </p>
<pre class="input">            StmtIterator statements = model.listStatements(null, null,<br>                    model.createTypedLiteral(&quot;1984-12-06&quot;,XSDDatatype.XSDdate));</pre>
<pre class="output">Match triples having a specific DATE value.<br>[http://example.org/people/alice, http://example.org/people/birthdate, &quot;1984-12-06Z&quot;^^http://www.w3.org/2001/XMLSchema#date]</pre>
<p>Let's try the same experiment with DATETIME:</p>
<pre class="input">            StmtIterator statements = model.listStatements(null, null, time);</pre> 
<pre class="output">Retrieve triples matching DATETIME object.<br>[http://example.org/people/ted, http://example.org/people/birthdate, &quot;1984-12-06T09:00:00Z&quot;^^http://www.w3.org/2001/XMLSchema#dateTime]</pre>



<p>And a DATETIME match without using a literal value object:</p>
<pre class="input">            StmtIterator statements = model.listStatements(null, null,<br>                    model.createTypedLiteral(&quot;1984-12-06T09:00:00&quot;,XSDDatatype.XSDdateTime));</pre>
<pre class="output">Match triples having a specific DATETIME value.<br>[http://example.org/people/ted, http://example.org/people/birthdate, &quot;1984-12-06T09:00:00Z&quot;^^http://www.w3.org/2001/XMLSchema#dateTime]</pre>
<h2 id="Importing Triples">Importing Triples (example6() and example7()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>
The Java Jena API client can load triples in either RDF/XML format or  NTriples format.  </p>
<table width="769" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
  <tr>
    <td width="928"><p><strong>Note:</strong> If you get a &quot;file not found&quot; error while running this example, it means that Java is looking in the wrong directory for the data files to load. Check the file paths in example6() and correct them if necessary.</p>    </td>
  </tr>
</table>
<p>The RDF/XML file contains a short list of v-cards (virtual business cards), like this one:</p>
<pre>  &lt;rdf:Description rdf:about=&quot;http://somewhere/JohnSmith/&quot;&gt;<br>    &lt;vCard:FN&gt;John Smith&lt;/vCard:FN&gt;<br>    &lt;vCard:N rdf:parseType=&quot;Resource&quot;&gt;<br>	    &lt;vCard:Family&gt;Smith&lt;/vCard:Family&gt;<br>	    &lt;vCard:Given&gt;John&lt;/vCard:Given&gt;<br>    &lt;/vCard:N&gt;<br>  &lt;/rdf:Description&gt; </pre>
<p>The NTriples file contains a graph of resources describing the Kennedy family, the places where they were each born, their colleges, and their professions. A typical entry from that file looks like this:</p>
<pre>&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#first-name&gt; &quot;Joseph&quot; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#middle-initial&gt; &quot;Patrick&quot; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#last-name&gt; &quot;Kennedy&quot; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#suffix&gt; &quot;none&quot; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#alma-mater&gt; &lt;http://www.franz.com/simple#Harvard&gt; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#birth-year&gt; &quot;1888&quot; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#death-year&gt; &quot;1969&quot; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#sex&gt; &lt;http://www.franz.com/simple#male&gt; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#spouse&gt; &lt;http://www.franz.com/simple#person2&gt; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#has-child&gt; &lt;http://www.franz.com/simple#person3&gt; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#profession&gt; &lt;http://www.franz.com/simple#banker&gt; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#birth-place&gt; &lt;http://www.franz.com/simple#place5&gt; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;http://www.franz.com/simple#person&gt; . </pre>

<p>Note that AllegroGraph can segregate triples into contexts (subgraphs) by treating them as quads. The fourth field contains the URI of a subgraph. The Jena GraphMaker object, however, explicitly creates subgraphs (by creating model objects). Each model object addresses the content of a specific subgraph. There is always an unnamed &quot;default background graph&quot; available, and you may create any number of named subgraphs to compliment it. It is important to address your queries to the right graph, of course. </p>
<p>In example6() we use the default background graph from example1(), which is initially empty, plus a second subgraph named &quot;http://example.org#vcards". Note that it is traditional to name subgraphs using appropriate URIs. </p>
<pre class="input">	public static AGGraphMaker example6() throws Exception {<br>		AGGraphMaker maker = example1(false);<br>		AGModel model = new AGModel(maker.getGraph());<br>		AGModel model_vcards = new AGModel(maker.createGraph(&quot;http://example.org#vcards&quot;));</pre>
<p><strong>Model</strong> addresses the default background graph. <strong>Model_vcards</strong> addresses a second subgraph where we will load v-card data. </p>
<p>The variables path1 and path2 are bound to the RDF/XML and NTriples files, respectively. You may have to redefine these paths depending on your platform and how you have set up the project. The data files are in the same directory as JenaTutorialExamples.java.</p>
<pre class="input">		String path1 = &quot;src/tutorial/java-vcards.rdf&quot;;<br>		String path2 = &quot;src/tutorial/java-kennedy.ntriples&quot;;</pre>
<p>Both examples need a base URI as one of the required arguments to the asserting methods: </p>
<pre class="input">		String baseURI = &quot;http://example.org/example/local&quot;;</pre>
<p>In the next step we use the <strong>read()</strong> method to load the vcard triples into the <strong>model_vcards</strong> subgraph: </p>
<pre class="input">		model_vcards.read(new FileInputStream(path1), baseURI);</pre>
<p>Then we use read() to load the Kennedy family tree into the background graph: </p>
<pre class="input"> 		model.read(new FileInputStream(path2), baseURI, &quot;N-TRIPLE&quot;);</pre>
<p>Now we'll ask AllegroGraph to report on how many triples it sees in the null context and in the #vcards context: </p>
<pre class="input">		println(&quot;After loading, model_vcards contains &quot; + model_vcards.size()<br>				+ &quot; triples in graph '&quot; + model_vcards.getGraph() <br>				+ &quot;'\n    and model contains &quot; + model.size() <br>				+ &quot; triples in graph '&quot; + model.getGraph() + &quot;'.&quot;);</pre>
<p>The output of this report was:</p>
<pre class="output">After loading, model_vcards contains 16 triples in graph 'http://example.org#vcards'<br>    and model contains 1214 triples in graph 'default-graph'.</pre>
<p>Example6() concludes by returning the GraphMaker object so it can be passed on to simplify the creation/load phase of subsequent examples. </p>
<p><strong>Example7()</strong> borrows the same triples we loaded in example6(), above, and runs two unconstrained retrievals. It retrieves the GraphMaker object from example6() and uses it to reacquire the <strong>model</strong> and <strong>model_vcards</strong>  objects. The first uses <strong>model.listStatements()</strong> to print out the subject value and subgraph identifier of each triple found in the default background graph. We placed a limit on the output because otherwise it would flood the screen with more than a thousand Kennedy triples. </p>
<pre class="input">	public static void example7() throws Exception {<br>		AGGraphMaker maker = example6();<br>		AGModel model = new AGModel(maker.getGraph());<br>		AGModel model_vcards = new AGModel(maker.openGraph(&quot;http://example.org#vcards&quot;));<br>		println(&quot;\nMatch all and print subjects and graph (model)&quot;);<br>		StmtIterator statements = model.listStatements();<br>		for (int i = 0; i &lt; 25 &amp;&amp; statements.hasNext(); i++) {<br>			Statement stmt = statements.next();<br>			println(stmt.getSubject() + &quot;  &quot; + stmt.getModel().getGraph());<br>		}</pre>
<pre class="output">Match all and print subjects and graph (model)<br>http://www.franz.com/simple#person1  default-graph<br>http://www.franz.com/simple#person1  default-graph<br>http://www.franz.com/simple#person1  default-graph<br>http://www.franz.com/simple#person1  default-graph... [and 21 more]</pre>
<p>This loop prints out triples from the default graph only, because that is the only graph that <strong>model</strong> can access. </p>
<p>The following loop performs the same experiment using <strong>model_vcards</strong>. </p>
<pre class="input">		println(&quot;\nMatch all and print subjects and graph (model_vcards)&quot;);<br>		statements = model_vcards.listStatements();<br>		for (int i = 0; i &lt; 25 &amp;&amp; statements.hasNext(); i++) {<br>			Statement stmt = statements.next();<br>			println(stmt.getSubject() + &quot;  &quot; + stmt.getModel().getGraph());<br>		}<br>		statements.close();</pre>
<pre class="output">Match all and print subjects and graph (model_vcards)<br>http://somewhere/JohnSmith/  http://example.org#vcards<br>http://somewhere/JohnSmith/  http://example.org#vcards<br>1  http://example.org#vcards<br>1  http://example.org#vcards<br>http://somewhere/RebeccaSmith/  http://example.org#vcards... [and 11 more]</pre>
<p>In this case, the loop prints out only v-card triples from model_vcards. The two odd-looking triples are from &quot;blank&quot; nodes in the v-cards model. </p>

<h2 id="Exporting Triples">Exporting Triples (example8() and example9()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>The next examples show how to write triples out to a file in either NTriples format or RDF/XML format. The output of either format may be optionally redirected to standard output (the Java command window) for inspection.</p>
<p>Example example8() begins by obtaining a GraphMaker object from example6(). This means the repository contains Kennedy family tree triples in the<strong> </strong>the default graph. We'll create a new model object to give us access to the default graph: </p>
<pre class="input">	public static void example8() throws Exception {<br>		AGGraphMaker maker = example6();<br>		AGModel model = new AGModel(maker.getGraph());</pre>
<p>To write triples in
NTriples format, call <strong>model.write(),</strong> which dumps all triples. You have to a give it an output stream, which could be either a file path or standard output. You must also tell model.write() which output format you want. In the first case we'll use N-TRIPLE format. The code below gives you the choice of writing to a file or to the standard-output window. </p>
<pre class="input">		String outputFile = TEMPORARY_DIRECTORY + &quot;temp.nt&quot;;<br>		// outputFile = null;<br>		if (outputFile == null) {<br>			println(&quot;\nWriting n-triples to Standard Out instead of to a file&quot;);<br>		} else {<br>			println(&quot;\nWriting n-triples to: &quot; + outputFile);<br>		}<br>		OutputStream output = (outputFile != null) ? new FileOutputStream(<br>				outputFile) : System.out;<br>		model.write(output, &quot;N-TRIPLE&quot;);<br>		output.close();</pre>
<p>To write triples in RDF/XML format, the process is the same, except that you don't have to prompt model.write() with a format. The RDF format is the default for this method. </p>
<pre class="input">		String outputFile2 = TEMPORARY_DIRECTORY + &quot;temp.rdf&quot;;<br>		// outputFile2 = null;<br>		if (outputFile2 == null) {<br>			println(&quot;\nWriting RDF to Standard Out instead of to a file&quot;);<br>		} else {<br>			println(&quot;\nWriting RDF to: &quot; + outputFile2);<br>		}<br>		output = (outputFile2 != null) ? new FileOutputStream(outputFile2)<br>				: System.out;<br>		model.write(output);<br>		output.close();<br>	}</pre>
<p>
The <strong>write()</strong> method writes
  out all triples in a subgraph.  This provides a convenient means for making
local backups of sections of your RDF store.  </p>
<p>Finally, if the objective is to write out a filtered set of triples,
  the following approach may be used. First capture the query results as a StmtIterator. Then add the statements to a new, empty model. Finally, use model.write() to dump all the statements of that model to a file to to standard output. </p>
<pre class="input">	public static void example9() throws Exception {<br>		AGGraphMaker maker = example6();<br>		AGModel model = new AGModel(maker.getGraph());<br>		StmtIterator statements = model.listStatements(null,RDF.type, (RDFNode)null);<br>		Model m = ModelFactory.createDefaultModel();<br>		m.add(statements);<br>		m.write(System.out);<br>	}</pre>
<!--
<h2 id="Datasets and Contexts">Datasets and Contexts (example10()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>
We have already seen contexts at work when loading and saving files.  In example10() we provide more realistic examples of contexts, and we introduce the dataset object. A dataset is a list of contexts that should all be searched simultaneously. </p>
<p>To set up the example, we create six statements, and add two
  of each to three different contexts: context1, context2, and the null context. The process of setting up the six statements follows the same pattern as we used in the previous examples: </p>
<pre class="input">    public static void example10 () throws Exception {<br>        RepositoryConnection conn = example1(false);<br>        Repository myRepository = conn.getRepository();<br>        ValueFactory f = myRepository.getValueFactory();<br>        String exns = &quot;http://example.org/people/&quot;;<br>        URI alice = f.createURI(exns, &quot;alice&quot;);<br>        URI bob = f.createURI(exns, &quot;bob&quot;);<br>        URI ted = f.createURI(exns, &quot;ted&quot;);        <br>        URI person = f.createURI(&quot;http://example.org/ontology/Person&quot;);<br>        URI name = f.createURI(&quot;http://example.org/ontology/name&quot;);<br>        Literal alicesName = f.createLiteral(&quot;Alice&quot;);<br>        Literal bobsName = f.createLiteral(&quot;Bob&quot;);<br>        Literal tedsName = f.createLiteral(&quot;Ted&quot;);        <br>        URI context1 = f.createURI(exns, &quot;cxt1&quot;);      <br>        URI context2 = f.createURI(exns, &quot;cxt2&quot;);         <br>        conn.add(alice, RDF.TYPE, person, context1);<br>        conn.add(alice, name, alicesName, context1);<br>        conn.add(bob, RDF.TYPE, person, context2);<br>        conn.add(bob, name, bobsName, context2);<br>        conn.add(ted, RDF.TYPE, person);<br>        conn.add(ted, name, tedsName);</pre>
<p>The first test uses getStatements() to return all triples in all contexts (context1, context2, and null). </p>
<pre class="input">        RepositoryResult&lt;Statement&gt; statements = conn.getStatements(null, null, null, false);<br>        println(&quot;All triples in all contexts:&quot;);        <br>        while (statements.hasNext()) {<br>            println(statements.next());            <br>        }</pre>
<p>The output of this loop is shown below. The context URIs are in the fourth position. Triples from the null context have [null] in the fourth position. </p>
<pre class="output">All triples in all contexts:<br>(http://example.org/people/alice, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/ontology/Person) [http://example.org/people/cxt1]<br>(http://example.org/people/alice, http://example.org/ontology/name, &quot;Alice&quot;) [http://example.org/people/cxt1]<br>(http://example.org/people/bob, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/ontology/Person) [http://example.org/people/cxt2]<br>(http://example.org/people/bob, http://example.org/ontology/name, &quot;Bob&quot;) [http://example.org/people/cxt2]<br>(http://example.org/people/ted, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/ontology/Person) [null]<br>(http://example.org/people/ted, http://example.org/ontology/name, &quot;Ted&quot;) [null]</pre>
<p>The next match explicitly lists 'context1' and 'context2' as the only contexts to participate in the match. It returns four statements. </p>
<pre class="input">        statements = conn.getStatements(null, null, null, false, context1, context2);<br>        println(&quot;\nTriples in contexts 1 or 2:&quot;);        <br>        while (statements.hasNext()) {<br>            println(statements.next());<br>        }</pre>
<p>The output of this loop shows that the triples in the null context have been excluded. </p>
<pre class="output">Triples in contexts 1 or 2:<br>(http://example.org/people/bob, http://example.org/ontology/name, &quot;Bob&quot;) [http://example.org/people/cxt2]<br>(http://example.org/people/bob, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/ontology/Person) [http://example.org/people/cxt2]<br>(http://example.org/people/alice, http://example.org/ontology/name, &quot;Alice&quot;) [http://example.org/people/cxt1]<br>(http://example.org/people/alice, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/ontology/Person) [http://example.org/people/cxt1]</pre>
<p>This time we use getStatements() to search explicitly for triples in the null context or in context 2.</p>
<pre class="input">        statements = conn.getStatements(null, null, null, false, null, context2);<br>        println(&quot;\nTriples in contexts null or 2:&quot;);        <br>        while (statements.hasNext()) {<br>            println(statements.next());<br>        }</pre>
<p>The output of this loop is:</p>
<pre class="output">Triples in contexts null or 2:<br>(http://example.org/people/bob, http://example.org/ontology/name, &quot;Bob&quot;) [http://example.org/people/cxt2]<br>(http://example.org/people/bob, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/ontology/Person) [http://example.org/people/cxt2]<br>(http://example.org/people/ted, http://example.org/ontology/name, &quot;Ted&quot;) [null]<br>(http://example.org/people/ted, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/ontology/Person) [null]</pre>
<p>Next, we switch to SPARQL queries. Named contexts may be included in the FROM and FROM-NAMED clauses in a SPARQL query. Below, we illustrate the procedural equivalent, which is to create a <strong>dataset</strong> object, add the contexts to that, and then to attach the dataset to the query object. The query is (again) restricted to only those statements in contexts 1 and 2.</p>
<pre class="input">        String queryString = &quot;SELECT ?s ?p ?o ?c WHERE { GRAPH ?c {?s ?p ?o . } }&quot;;        <br>        DatasetImpl ds = new DatasetImpl();<br>        ds.addNamedGraph(context1);<br>        ds.addNamedGraph(context2);<br>        TupleQuery tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString);<br>        tupleQuery.setDataset(ds);<br>        TupleQueryResult result = tupleQuery.evaluate();    <br>        println(&quot;\nQuery over contexts 1 and 2.&quot;);<br>        while (result.hasNext()) {<br>            BindingSet bindingSet = result.next();<br>            println(bindingSet.getBinding(&quot;s&quot;) + &quot; &quot; + bindingSet.getBinding(&quot;c&quot;));<br>        }    </pre>
<p>The output of this loop contains four triples, as expected. </p>
<pre class="output">Query over contexts 1 and 2.<br>s=http://example.org/people/alice p=http://www.w3.org/1999/02/22-rdf-syntax-ns#type o=http://example.org/ontology/Person c=http://example.org/people/cxt1<br>s=http://example.org/people/alice p=http://example.org/ontology/name o=&quot;Alice&quot; c=http://example.org/people/cxt1<br>s=http://example.org/people/bob p=http://www.w3.org/1999/02/22-rdf-syntax-ns#type o=http://example.org/ontology/Person c=http://example.org/people/cxt2<br>s=http://example.org/people/bob p=http://example.org/ontology/name o=&quot;Bob&quot; c=http://example.org/people/cxt2</pre>
<p> Currently, its not possible to combine the null context with other contexts in a SPARQL query. Below, we illustrate how to evaluate a query against only the null context.</p>
<pre class="input">        queryString = &quot;SELECT ?s ?p ?o WHERE {?s ?p ?o . }&quot;;<br>        ds = new DatasetImpl();<br>        tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString);<br>        tupleQuery.setDataset(ds);<br>        result = tupleQuery.evaluate();    <br>        println(&quot;\nQuery over the null context.&quot;);<br>        while (result.hasNext()) {<br>            println(result.next());<br>        }</pre>

<p>The output of this loop is:</p>

<pre class="output">Query over the null context.<br>['&lt;http://example.org/people/ted&gt;', '&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;', '&lt;http://example.org/people/Person&gt;']
['&lt;http://example.org/people/ted&gt;', '&lt;http://example.org/people/name&gt;', '&quot;Ted&quot;']</pre>
-->
<h2 id="Namespaces">Namespaces (example11()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>
A <i>namespace</i> is that portion of a URI that precedes the last '#',
'/', or ':' character, inclusive.  The remainder of a URI is called the
<i>localname</i>.  For example, with respect to the URI "http://example.org/people/alice",
the namespace is "http://example.org/people/" and the localname is "alice".
When writing SPARQL queries, it is convenient to define prefixes or nicknames
for the namespaces, so that abbreviated URIs can be specified.  For example,
if we define "ex" to be a nickname for "http://example.org/people/", then the
string "ex:alice" is a recognized abbreviation for "http://example.org/people/alice".
This abbreviation is called a <i>qname</i>.
</p>
<p>
In the SPARQL query in the example below, we see two qnames, "rdf:type" and
"ex:alice".  Ordinarily, we would expect to see "PREFIX" declarations in
SPARQL that define namespaces for the "rdf" and "ex" nicknames.  However,
the RepositoryConnection and Query machinery can do that job for you.  The
mapping of prefixes to namespaces includes the built-in prefixes RDF, RDFS, XSD, and OWL.
Hence, we can write "rdf:type" in a SPARQL query, and the system already knows
its meaning.  In the case of the 'ex' prefix, we need to instruct it.  The
setNamespace() method of the connection object registers a new namespace.  In the example
below, we first register the 'ex' prefix, and then submit the SPARQL query.
It is legal, although not recommended, to redefine the built-in prefixes RDF, etc..
</p>
<p>The example example11() begins by borrowing a connection object from example1(). Then we retrieve the repository object and its associated valueFactory. </p>
<pre class="input">	public static void example11() throws Exception {<br>		AGGraphMaker maker = example1(false);<br>		AGModel model = new AGModel(maker.getGraph());</pre>
<p>We need a namespace string (bound to the variable <strong>exns</strong>) to use when generating the <strong>alice</strong> and <strong>person</strong> URIs. </p>
<pre class="input">		String exns = &quot;http://example.org/people/&quot;;<br>		Resource alice = model.createResource(exns + &quot;alice&quot;);<br>		Resource person = model.createResource(exns + &quot;Person&quot;);</pre>
<p>Now we can assert Alice's RDF:TYPE triple. </p>
<pre class="input">		model.add(alice, RDF.type, person);</pre>
<p>Now we register the exns namespace with the connection object, so we can use it in a SPARQL query. The query looks for triples that have &quot;rdf:type&quot; in the predicate position, and &quot;ex:Person&quot; in the object position. </p>
<pre class="input">		model.setNsPrefix(&quot;ex&quot;, exns);<br>		String queryString = <br>			&quot;SELECT ?s ?p ?o&quot; + <br>		        &quot;WHERE { ?s ?p ?o . FILTER ((?p = rdf:type) &amp;&amp; (?o = ex:Person) ) }&quot;;<br>        AGQuery query = AGQueryFactory.create(queryString);<br>        QueryExecution qe = AGQueryExecutionFactory.create(query, model);<br>		try {<br>			ResultSet results = qe.execSelect();<br>			while (results.hasNext()) {<br>				println(results.next());<br>			}</pre>
<p>The output shows the single triple with its fully-expanded URIs.  This demonstrates that the qnames in the SPARQL query successfully matched the fully-expanded URIs in the triple. </p>
<pre class="output">[s=http://example.org/people/alice;p=http://www.w3.org/1999/02/22-rdf-syntax-ns#type;o=http://example.org/people/Person]</pre>
<p>It is worthwhile to briefly discuss performance here.  In the current
  AllegroGraph system, queries run more efficiently if constants appear inside
  of the "where" portion of a query, rather than in the "filter" portion.  For
  example, the SPARQL query below will evaluate more efficiently than the one
  in the above example.  However, in this case, you have lost the ability to
  output the constants "http://www.w3.org/1999/02/22-rdf-syntax-ns#type" and
"http://example.org/people/alice".  Occasionally you may find it useful to
  output constants in the output of a 'select' clause; in general though,
  the above code snippet illustrates a query syntax that is discouraged. </p>
<pre class="input">
SELECT ?s  
WHERE { ?s rdf:type ex:person } 
</pre>
<!--
<h2 id="Free Text Search">Free Text Search (example12()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>
It is common for users to build RDF applications that combine
some form of "keyword search" with their queries. For example, a user
might want to retrieve all triples for which the string "Alice" appears
as a word within the third (object) argument to the triple.  AllegroGraph
provides a capability for including free text matching within a SPARQL
query.  It requires, however, that you register the predicates that will participate in text searches so they can be indexed. </p>
<p> The example example12() begins by borrowing the connection object from example1(). Then it creates a namespace string and registers the namespace with the connection object, as in the previous example. </p>
<pre class="input">	public static void example12 () throws Exception {    <br>        AGRepositoryConnection conn = example1(false);<br>	    ValueFactory f = conn.getValueFactory();<br>	    String exns = &quot;http://example.org/people/&quot;;<br>	    conn.setNamespace(&quot;ex&quot;, exns);</pre>
<p>We have to register the predicates that will participate in text indexing. In the example12() example below, we have
called the connection method <strong>registerFreeTextPredicate()</strong> to register the predicate "http://example.org/people/fullname" for text indexing. Generating the predicate's URI is a separate step. </p>
<pre class="input">	    conn.registerFreetextPredicate(f.createURI(exns,&quot;fullname&quot;));</pre>
<p>The next step is to create two new resources, &quot;Alice1&quot; named &quot;Alice B. Toklas,&quot; and &quot;book1&quot; with the title &quot;Alice in Wonderland.&quot; Notice that we did not register the book title predicate for text indexing. </p>
<pre class="input">	    URI alice = f.createURI(exns, &quot;alice1&quot;);<br>	    URI persontype = f.createURI(exns, &quot;Person&quot;);<br>	    URI fullname = f.createURI(exns, &quot;fullname&quot;);    <br>	    Literal alicename = f.createLiteral(&quot;Alice B. Toklas&quot;);<br>	    URI book =  f.createURI(exns, &quot;book1&quot;);<br>	    URI booktype = f.createURI(exns, &quot;Book&quot;);<br>	    URI booktitle = f.createURI(exns, &quot;title&quot;);    <br>	    Literal wonderland = f.createLiteral(&quot;Alice in Wonderland&quot;);</pre>
<p>Clear the repository, so our new triples are the only ones available. </p>
<pre class="input">
        conn.clear()    </pre>
<p>Add the resource for the new person, Alice B. Toklas: </p>
<pre class="input">	    conn.add(alice, RDF.TYPE, persontype);<br>	    conn.add(alice, fullname, alicename);</pre>
<p>Add the new book, <em>Alice in Wonderland</em>. </p>
<pre class="input">	    conn.add(book, RDF.TYPE, booktype);    <br>	    conn.add(book, booktitle, wonderland); </pre>
<p>Now we set up the SPARQL query that looks for triples containing &quot;Alice&quot; in the object position. </p>
<p>The text match occurs through a &quot;magic&quot; predicate called <strong>fti:match</strong>. This is not an RDF &quot;predicate&quot; but a LISP &quot;predicate,&quot; meaning that it behaves as a true/false test. This predicate  has two arguments. One is  the subject URI of the resources to search. The other is the string pattern to search for, such as &quot;Alice&quot;. Only registered text predicates will be searched. Only full-word matches will be found. </p>
<pre class="input">	    String queryString = <br>	        &quot;SELECT ?s ?p ?o &quot; +<br>	        &quot;WHERE { ?s ?p ?o . ?s fti:match 'Alice' . }&quot;;</pre>
<p>There is no need to include a prefix declaration for the 'fti' nickname. That is because 'fti' is included among the built-in namespace/nickname mappings in AllegroGraph.</p>
<p>When we execute our SPARQL query, it matches the "Alice" within the literal "Alice B. Toklas" because that literal occurs in a triple having the registered <strong>fullname</strong> predicate, but it does not match the "Alice" in the literal "Alice in Wonderland" because the <strong>booktitle</strong> predicate was not registered for text indexing. This query returns <em>all triples</em> of a resource that had a successful match in at least one object value. </p>
<pre class="input">        TupleQuery tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString);<br>        TupleQueryResult result = (TupleQueryResult)tupleQuery.evaluate();<br>        int count = 0;<br>        while (result.hasNext()) {<br>            BindingSet bindingSet = result.next();<br>            if (count &lt; 5) {<br>                println(bindingSet);<br>            }<br>            count += 1;<br>        }</pre>
<p>The output of this loop is:</p>
<pre class="output">Whole-word match for 'Alice'.<br>[s=http://example.org/people/alice1;p=http://example.org/people/fullname;o=&quot;Alice B. Toklas&quot;]<br>[s=http://example.org/people/alice1;p=http://www.w3.org/1999/02/22-rdf-syntax-ns#type;o=http://example.org/people/Person]</pre>
<p>The text index supports simple wildcard queries. The asterisk (*) may be appended to the end of the pattern to indicate &quot;any number of additional characters.&quot; For instance, this query looks for whole words that begin with &quot;Ali&quot;:</p>
<pre class="input">        queryString = <br>        	&quot;SELECT ?s ?p ?o &quot; +<br>        	&quot;WHERE { ?s ?p ?o . ?s fti:match 'Ali*' . }&quot;;</pre>
<p>It finds the same two triples as before.</p>
<p>There is also a single-character wildcard, the questionmark.  You can add as many question marks as you need to the string pattern.  This query looks for a five-letter word that has "l" in the second position, and "c" in the fourth position:</p>
<pre class="input">        queryString = <br>        	&quot;SELECT ?s ?p ?o &quot; +<br>        	&quot;WHERE { ?s ?p ?o . ?s fti:match '?l?c?' . }&quot;;</pre>
<p>This query finds the same two triples as before. </p>
<p>This time we'll do something a little different.  The free text indexing matches whole words only, even when using wildcards. What if you really need to match a substring in a word of unknown length? You can write a SPARQL query that performs a <strong>regex </strong>match against object values. This can be inefficient compared to indexed search, and the match is not confined to the registered free-text predicates. The following query looks for the substring &quot;lic&quot; in all literal object values:</p>
<pre class="input">        queryString = <br>        	&quot;SELECT ?s ?p ?o &quot; +<br>        	&quot;WHERE { ?s ?p ?o . FILTER regex(?o, \&quot;lic\&quot;) }&quot;;</pre>
<p>This query returns two triples, but they are not quite the same as before:</p>
<pre class="output">Substring match for 'lic'.<br>[s=http://example.org/people/alice1;p=http://example.org/people/fullname;o=&quot;Alice B. Toklas&quot;]<br>[s=http://example.org/people/book1;p=http://example.org/people/title;o=&quot;Alice in Wonderland&quot;]</pre>
<p>As you can see, the regex match found &quot;lic&quot; in &quot;Alice in Wonderland,&quot; which was not a registered free-text predicate. It made this match by doing a string comparison against every object value in the triple store. Even though you can streamline the SPARQL query considerably by writing more restrictive patterns, this is still inherently less efficient than using the indexed approach. </p>
-->
<h2 id="Ask, Describe, and Construct Queries">Select, Ask, Describe, Construct, and Update Queries (example13())&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>SPARQL provides alternatives to the standard SELECT query. Example example13() exercises these alternatives to show how AllegroGraph Server handles them using the Java Jena API. </p>
<ul>
  <li>SELECT: Returns variables bound in a query pattern match. </li>
  <li>ASK: Returns a boolean indicating whether a query matches or not. </li>
  <li>CONSTRUCT: Returns triples constructed by substituting variables in a set of triple templates. </li>
  <li>DESCRIBE: Returns a concise bounded description of a matching resource. </li>
  <li>Updates: Executes <a href="http://www.w3.org/TR/sparql11-update/">SPARQL Update</a> queries to modify the model/repository. </li>
</ul>
<p>The example begins by borrowing an AGGraphMaker object from example6(). From the maker object we can generate an AGModel object. This connects to an existing repository that contains vcard and Kennedy data. We'll need to register a Kennedy namespace to make the queries easier to read. 
<pre class="input">	public static void example13() throws Exception {<br>		AGGraphMaker maker = example6();<br>		AGModel model = new AGModel(maker.getGraph());<br>		model.setNsPrefix(&quot;kdy&quot;, &quot;http://www.franz.com/simple#&quot;);</pre>
<p>As it happens, we don't need the vcard data this time, so we'll remove it. This is an example of how to delete an entire subgraph (the vcards &quot;context&quot;) using Jena:</p>
<pre class=input>		maker.removeGraph(&quot;http://example.org#vcards&quot;);</pre>
<p>The example begins with a SELECT query so we can see some of the Kennedy resources. Note the use of the <strong>qe.exectSelect()</strong> method to evaluate the query. </p>
<pre class="input">        String queryString = &quot;select ?s where { ?s rdf:type kdy:person} limit 5&quot;;<br>        AGQuery query = AGQueryFactory.create(queryString);<br>        QueryExecution qe = AGQueryExecutionFactory.create(query, model);<br>        println(&quot;\nSELECT some persons:&quot;);        <br>		try {<br>			ResultSet results = <strong>qe.execSelect();</strong><br>			while (results.hasNext()) {<br>				println(results.next());<br>			}<br>		} finally {<br>			qe.close();<br>		}</pre>
Note that SELECT returns variable bindings. In this case it returns subject URIs of five people:
<pre class="output">SELECT some persons:<br>[s=http://www.franz.com/simple#person1]<br>[s=http://www.franz.com/simple#person2]<br>[s=http://www.franz.com/simple#person3]<br>[s=http://www.franz.com/simple#person4]<br>[s=http://www.franz.com/simple#person5]</pre>
<p>The ASK query returns a Boolean, depending on whether the triple pattern matched any triples. In this case we ran two tests; one seeking &quot;John&quot; and the other looking for &quot;Alice.&quot; Note that the ASK query uses a different construction method than the SELECT query:<strong> qe.execAsk()</strong>. </p>
<pre class="input">        queryString = &quot;ask { ?s kdy:first-name 'John' } &quot;;<br>        query = AGQueryFactory.create(queryString);<br>        qe = AGQueryExecutionFactory.create(query, model);<br>		try {<br>			println(&quot;\nASK: Is there anyone named John? &quot; + <strong>qe.execAsk()</strong>);<br>		} finally {<br>			qe.close();<br>		}
<br>        queryString = &quot;ask { ?s kdy:first-name 'Alice' } &quot;;<br>        query = AGQueryFactory.create(queryString);<br>        qe = AGQueryExecutionFactory.create(query, model);<br>		try {<br>			println(&quot;\nASK: Is there anyone named Alice? &quot; + <strong>qe.execAsk()</strong>);<br>		} finally {<br>			qe.close();<br>		}</pre>
<p>The output of this loop is:</p>
<pre class="output">ASK: Is there anyone named John? true
ASK: Is there anyone named Alice? false</pre>
<p>The CONSTRUCT query contructs new triples out of the matching values in the query. The point is that the query can bind variables from existing triples and then &quot;construct&quot; <em>new triples</em> by recombining the values. This query constructs new triples that use the <strong>kdy:has-grandchild</strong> predicate. </p>
<pre class="input">        queryString = &quot;construct {?a kdy:has-grandchild ?c}&quot; + <br>        &quot;    where { ?a kdy:has-child ?b . &quot; +<br>        &quot;            ?b kdy:has-child ?c . }&quot;;<br>        query = AGQueryFactory.create(queryString);<br>        qe = AGQueryExecutionFactory.create(query, model);<br>		try {<br>			Model m = qe.execConstruct();</pre>
<p>Note that the CONSTRUCT query <strong>qe.execConstruct()</strong>, which returns a new model object. This model contains new triples that have not yet been added to the triple store. Use model.add() to put them in the store. Note that we are adding one model to another: </p>
<pre class="input">			<strong>model.add(m)</strong>;   // add new triples to the store<br>		} finally {<br>			qe.close();<br>		}</pre>
<p>The DESCRIBE query returns another model, meaning all triples of the matching resources. It uses <strong>qe.execDescribe()</strong>. In this case we asked SPARQL to describe one grandparent and one grandchild. (This confirms that the kdy:has-grandchild triples successfully entered the triple store.) </p>
<pre class="input">		queryString = &quot;describe ?s ?o where { ?s kdy:has-grandchild ?o . } limit 1&quot;;<br>        query = AGQueryFactory.create(queryString);<br>        qe = AGQueryExecutionFactory.create(query, model);<br>		try {<br>			Model m = qe.execDescribe();<br>			println(&quot;\nDescribe one grandparent and one grandchild:&quot;);<br>			m.write(System.out);<br>		} finally {<br>			qe.close();<br>		}</pre>
<p>Printing the result model to standard output reveals that the &quot;model&quot; is expressed as RDF/XML. The actual output is too lengthy to show here, but one block confirms that the has-grandchild triples are present as expected: </p>
<pre class="output">  &lt;rdf:Description rdf:about=&quot;http://www.franz.com/simple#person2&quot;&gt;<br>    &lt;j.0:has-grandchild rdf:resource=&quot;http://www.franz.com/simple#person44&quot;/&gt;<br>    &lt;j.0:has-grandchild rdf:resource=&quot;http://www.franz.com/simple#person76&quot;/&gt;<br>    &lt;j.0:has-grandchild rdf:resource=&quot;http://www.franz.com/simple#person42&quot;/&gt;<br>    &lt;j.0:has-grandchild rdf:resource=&quot;http://www.franz.com/simple#person51&quot;/&gt;
...</pre>
<p><a href="http://www.w3.org/TR/sparql11-update/">SPARQL Update</a> queries can also be evaluated to modify the model/repository.  A SPARQL Update can be executed as follows:</p>
<pre class="input">
		queryString = "insert data { kdy:person4 kdy:nickname 'Jack'}";
		query = AGQueryFactory.create(queryString);
		qe = AGQueryExecutionFactory.create(query, model);
		try {
			qe.execUpdate();
		} finally {
			qe.close();
		}
</pre>

<h2 id="RDFS++ Inference">RDFS++ Inference (example19())&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>The great promise of the semantic web is that we can use RDF metadata to combine information from multiple sources into a single, common model.&nbsp; The great problem of the semantic web is that it is so difficult to recognize when two resource descriptions from different sources actually represent the same thing.&nbsp; This problem arises because there is no uniform or universal way to generate URIs identifying resources.&nbsp; As a result, we may create two resources, Bob and Robert, that actually represent the same person. </p>
<p>This problem has generated much creativity in the field. One way to approach the problem is through inference.&nbsp; There are certain relationships and circumstances where an inference engine can deduce that two resource descriptions actually represent one thing, and then automatically merge the descriptions.&nbsp; AllegroGraph's <a href="../reasoner-tutorial.html">inference engine</a> can be turned on or off each time you run a query against the triple store.&nbsp;  (Note that inference is turned off by default, which is the opposite of standard Jena behavior.) </p>
<p>In example example19(), we will create four resources: Bob, with son Bobby, and Robert with daughter Roberta.&nbsp; </p>
<p><img src="inferenceSetup.jpg" width="448" height="101"></p>
<p>First we have to set up the data. We begin by generating four new resources. </p>
<pre class="input">	public static void example19() throws Exception {<br>		AGGraphMaker maker = example1(false);<br>		AGModel model = new AGModel(maker.getGraph());<br>		Resource robert = model.createResource(&quot;http://example.org/people/robert&quot;);<br>		Resource roberta = model.createResource(&quot;http://example.org/people/roberta&quot;);<br>		Resource bob = model.createResource(&quot;http://example.org/people/bob&quot;);<br>		Resource bobby = model.createResource(&quot;http://example.org/people/bobby&quot;);</pre>
The next step is to create URIs for the predicates we'll need (<em>name</em> and <em>fatherOf</em>), plus one for the Person class. <br>
<pre class="input">		// create name and child predicates, and Person class.<br>		Property name = model.createProperty(&quot;http://example.org/ontology/name&quot;);<br>		Property fatherOf = model.createProperty(&quot;http://example.org/ontology/fatherOf&quot;);<br>		Resource person = model.createResource(&quot;http://example.org/ontology/Person&quot;);</pre>
The names of the four people will be literal values. <br>
<pre class="input">		// create literal values for names<br>		Literal bobsName = model.createLiteral(&quot;Bob&quot;);<br>		Literal bobbysName = model.createLiteral(&quot;Bobby&quot;);<br>		Literal robertsName = model.createLiteral(&quot;Robert&quot;);<br>		Literal robertasName = model.createLiteral(&quot;Roberta&quot;);</pre>
<p>Robert, Bob and the children are all instances of class Person.&nbsp; It is good practice to identify all resources by an rdf:type link to a class.</p>
<pre class="input">		// Robert, Bob, and children are people<br>		model.add(robert, RDF.type, person);<br>		model.add(roberta, RDF.type, person);<br>		model.add(bob, RDF.type, person);<br>		model.add(bobby, RDF.type, person);</pre>
The four people all have literal names. <br>
<pre class="input">		// They all have names.<br>		model.add(robert, name, robertsName);<br>		model.add(roberta, name, robertasName);<br>		model.add(bob, name, bobsName);<br>		model.add(bobby, name, bobbysName);</pre> 
Robert and Bob have links to the child resources:
<br>
<pre class="input">		// robert has a child<br>		model.add(robert, fatherOf, roberta);<br>		// bob has a child<br>		model.add(bob, fatherOf, bobby);</pre> 
<h3>SameAs</h3>
<p>Now that the basic resources and relations are in place, we'll seed the triple store with a statement that &quot;Robert is the same as Bob,&quot; using the <strong>owl:sameAs</strong> predicate.&nbsp; The AllegroGraph inference engine recognizes the semantics of owl:sameAs, and automatically infers that Bob and Robert share the same attributes.&nbsp; Each of them originally had one child.&nbsp; When inference is turned on, however, they each have two children.&nbsp; </p>
<p><img src="inferenceSaveAs.jpg" width="459" height="182"></p>
<p>Note that SameAs does not combine the two resources.&nbsp; Instead it links each of the two resources to all of the combined children.&nbsp; The red links in the image are &quot;inferred&quot; triples.&nbsp; They have been deduced to be true, but are not actually present in the triple store. </p>
<p>This is the critical link that tells the inference engine to regard Bob and Robert as the same resource. </p>
<pre class="input">		// Bob is the same person as Robert<br>		model.add(bob, OWL.sameAs, robert);</pre>
<p>This is a simple listStatements() search asking for the children of Robert, with inference turned OFF. This is the default behavior of a model.</p>
<pre class="input">		println(&quot;\nChildren of Robert, inference OFF&quot;);<br>		printRows(model.listStatements(robert, fatherOf, (RDFNode) null));</pre> 
<p>The search returns one triple, which is the link from Robert to his direct child, Roberta. </p>
<pre class="output">Children of Robert, inference OFF<br>[http://example.org/people/robert, http://example.org/ontology/fatherOf, http://example.org/people/roberta]</pre>
<p>In the AllegroGraph Java API, we can take one graph and turn inference on and off at will. In the Java Jena API, however, a model either permits inferencing or it doesn't. Therefore, to compare queries with and without inferencing, we'll need a second model. Fortunately, both &quot;models&quot; can address the same graph. The second model is not a duplicate graph, but a second interface to the same graph. </p>
<p>First we need a reasoning engine, which is an instance of AGReasoner. Then we combine the reasoner with the old model to create a new, inferencing model (called<strong> InfModel</strong>).</p>
<pre class="input">		println(&quot;\nChildren of Robert, inference ON&quot;);<br>		AGReasoner reasoner = new AGReasoner();<br>		InfModel infmodel = new AGInfModel(reasoner, model);</pre>
<p>The query is the same as before, but the results are different: </p>
<pre class="input">		printRows(infmodel.listStatements(robert, fatherOf, (RDFNode)null));</pre>
<pre class="output">Children of Robert, inference ON<br>[http://example.org/people/robert, http://example.org/ontology/fatherOf, http://example.org/people/roberta]<br>[http://example.org/people/robert, http://example.org/ontology/fatherOf, http://example.org/people/bobby]</pre>
<p>Note that with inference ON, Robert suddenly has two children because Bob's child has been included.&nbsp; Also note that the final triple (robert fatherOf bobby) has been inferred.&nbsp; The inference engine has determined that this triple logically must be true, even though it does not appear in the repository. </p>
<h3>InverseOf</h3>
<p>We can reuse the Robert family tree to see how the inference engine can deduce the presence of inverse relationships. </p>
<p>Up to this point in this tutorial, we have created new predicates simply by creating a URI and using it in the predicate position of a triple.&nbsp; This time we need to create a predicate<em> resource</em> so we can set an attribute of that resource.&nbsp; We're going to declare that the <strong>hasFather</strong> predicate is the <strong>owl:inverseOf</strong> the existing fatherOf predicate. </p>
<p>The first step is to remove the owl:sameAs link, because we are done with it. </p>
<pre class="input">		model.remove(bob, OWL.sameAs, robert);</pre>
<p>We'll need a URI for the new hasFather predicate:</p>

<pre class="input">		Property hasFather = model.createProperty(&quot;http://example.org/ontology/hasFather&quot;);
</pre>
<p>This is the line where we create a predicate resource.&nbsp; It is just a triple that describes a property of the predicate.&nbsp; The hasFather predicate is the inverse of the fatherOf predicate: </p>

<pre class="input">		model.add(hasFather, OWL.inverseOf, fatherOf);</pre>
<p>First, we'll search for hasFather triples, leaving inference OFF to show that there are no such triples in the repository: </p>

<pre class="input">		println(&quot;\nPeople with fathers, inference OFF&quot;);<br>		printRows(model.listStatements(null, hasFather, (RDFNode)null));</pre>
<pre class="output">People with fathers, inference OFF<br></pre>
<p>Now we'll turn inference ON.&nbsp; This time, the AllegroGraph inference engine discovers two &quot;new&quot; hasFather triples. </p>
<pre class="input">		println(&quot;\nPeople with fathers, inference ON&quot;);<br>		printRows(infmodel.listStatements(null, hasFather, (RDFNode)null));</pre>
<pre class="output">People with fathers, inference ON<br>[http://example.org/people/roberta, http://example.org/ontology/hasFather, http://example.org/people/robert]<br>[http://example.org/people/bobby, http://example.org/ontology/hasFather, http://example.org/people/bob]</pre>
<p>Both of these triples are inferred by the inference engine.</p>
<h3>SubPropertyOf</h3>
<p>Invoking inference using the <strong>rdfs:subPropertyO</strong>f predicate lets us &quot;combine&quot; two predicates so they can be searched as one.&nbsp; For instance, in our Robert/Bob example, we have explicit fatherOf relations.&nbsp; Suppose there were other resources that used a parentOf relation instead of fatherOf.&nbsp; By making fatherOf a subproperty of parentOf, we can search for parentOf triples and automatically find the fatherOf triples at the same time. </p>
<p>First we should remove the owl:inverseOf relation from the previous example. We don't have to, but it keeps things simple. </p>
<pre class="input">		model.remove(hasFather, OWL.inverseOf, fatherOf);</pre>
<p>We'll need a parentOf URI to use as the new predicate.&nbsp; Then we'll add a triple saying that fatherOf is an rdfs:subPropertyOf the new predicate, parentOf:</p>
<pre class="input">		Property parentOf = model.createProperty(&quot;http://example.org/ontology/parentOf&quot;);<br>		model.add(fatherOf, RDFS.subPropertyOf, parentOf);</pre>
<p>If we now search for parentOf triples with inference OFF, we won't find any. No such triples exist in the repository. </p>
<pre class="input">		println(&quot;\nPeople with parents, inference OFF&quot;);<br>		printRows(model.listStatements(null, parentOf, (RDFNode)null));</pre>
<pre class="output">People with parents, inference OFF

</pre>
<p>With inference ON, however, AllegroGraph infers two new triples: </p>
<pre class="input">		println(&quot;\nPeople with parents, inference ON&quot;);<br>		printRows(infmodel.listStatements(null, parentOf, (RDFNode)null));</pre>
<pre class="output">People with parents, inference ON<br>[http://example.org/people/robert, http://example.org/ontology/parentOf, http://example.org/people/roberta]<br>[http://example.org/people/bob, http://example.org/ontology/parentOf, http://example.org/people/bobby]</pre>
<p>The fact that two fatherOf triples exist means that two correponding parentOf triples must be valid.&nbsp; There they are.</p>
<p>Before setting up the next example, we should clean up:</p>
<pre class="input">		model.remove(fatherOf, RDFS.subPropertyOf, parentOf);</pre>
<h3>Domain and Range</h3>
<p>When you declare the domain and range of a predicate, the AllegroGraph inference engine can infer the rdf:type of resources found in the subject and object positions of the triple.&nbsp; For instance, in the triple &lt;<em>subject</em>, fatherOf, <em>object</em>&gt; we know that the <em>subject</em> is always an instance of class Parent, and the <em>object</em> is always an instance of class Child.&nbsp;</p>
<p>In RDF-speak, we would say that the <strong>domain</strong> of the fatherOf predicate is rdf:type Parent.&nbsp; The <strong>range</strong> of fatherOf is rdf:type Child.&nbsp; </p>
<p>This lets the inference engine determine the rdf:type of every resource that participates in a fatherOf relationship.&nbsp; </p>
<p>We'll need two new classes, Parent and Child.&nbsp; Note that RDF classes are always capitalized, just as predicates are always lowercase.</p>
<pre class="input">		Resource parent = model.createResource(&quot;http://example.org/ontology/Parent&quot;);<br>		Resource child = model.createResource(&quot;http://exmaple.org/ontology/Child&quot;);</pre>
<p>Now we add two triples defining the domain and rage of the fatherOf predicate: </p><pre class="input">		model.add(fatherOf, RDFS.domain, parent);<br>		model.add(fatherOf, RDFS.range, child);</pre>
<p>Now we'll search for resources of rdf:type Parent.&nbsp; The inference engine supplies the appropriate triples: </p>
<pre class="input">		println(&quot;\nWho are the parents?  Inference ON.&quot;);<br>		printRows(infmodel.listStatements(null, RDF.type, parent));</pre>
<pre class="output">Who are the parents?  Inference ON.<br>[http://example.org/people/robert, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/ontology/Parent]<br>[http://example.org/people/bob, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/ontology/Parent]</pre>
<p>Bob and Robert are parents.&nbsp; Who are the children? </p>
<pre class="input">		println(&quot;\nWho are the children?  Inference ON.&quot;);<br>		printRows(infmodel.listStatements(null, RDF.type, child));</pre>
<pre class="output">Who are the children?  Inference ON.<br>[http://example.org/people/roberta, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://exmaple.org/ontology/Child]<br>[http://example.org/people/bobby, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://exmaple.org/ontology/Child]</pre>
<p>Bobby and Roberta are the children. &nbsp;  </p>
<!--
<h2 id="Geospatial Search">Geospatial Search (example20())&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>AllegroGraph provides the ability to locate resources within a geospatial coordinate system. You can set up either a flat (X,Y Cartesian) or spherical (latitude, longitude) system. The systems are two-dimensional only. (There is no Z or altitude dimension available). </p>
<p>The purpose of the geospatial representation is to efficiently find all entities that are located within a specific circular, rectangular or polygonal area. </p>
<h3>Cartesian System </h3>
<p>A Cartesian system is a flat (X,Y) plane. Locations are designated by (X,Y) pairs. At this time, AllegroGraph does not support real-world measurement units (km, miles, latitude, etc.,) in the Cartesian system. </p>
<p>The first example uses a Cartesian (X,Y) system that is 100 units square, and contains three people located at various points along the X = Y diagonal.</p>
<p><img src="gepCartesian.jpg" width="417" height="333"> </p>
<p>The example is in the function example20(). After establishing a connection, it begins by creating URIs for the three people.</p>
<pre class="input">        String exns = &quot;http://example.org/people/&quot;;<br>        conn.setNamespace(&quot;ex&quot;, exns);<br>        URI alice = vf.createURI(exns, &quot;alice&quot;);<br>        URI bob = vf.createURI(exns, &quot;bob&quot;);<br>        URI carol = vf.createURI(exns, &quot;carol&quot;);</pre>
<p>Then we have the connection object generate a rectangular coordinate system for us to use. A rectangular (Cartesian) system can be used to represent anything that can be plotted using (X,Y) coordinates, such as the location of transistors on a silicon chip. </p>
<pre class="input">        URI cartSystem = conn.registerCartesianType(10, 0, 100, 0, 100);</pre>
<p>The first parameter is called the <strong>stripWidth</strong>. The stripWidth parameter influences how the coordinate data is stored and retrieved, and impacts search performance. The task is to locate the people who are within a specific region. As a rule of thumb, set the stripWidth parameter to approximately the same value as the height (Y-axis) of your typical search region. You can be off by a factor of ten without impacting performance too badly, but if your application will search regions that are orders of magnitude different in size, you'll want to create multiple coordinate systems that are scaled for different sized search regions. In this case, our search region is about 20 units high (Y), and we have set the stripWidth parameter to 10 units. That's close enough.</p>
<p>The remaining parameters describe the overall size of the system. The size of the coordinate system is determined by the <strong>xMin, xMax, yMin</strong> and <strong>yMax</strong> parameters. This system is 0 to 100 in the X dimension, and 0 to 100 in the Y dimension. </p>
<p>The next step is to create a &quot;location&quot; predicate and enter the locations of the three people. </p>
<pre class="input">        URI location = vf.createURI(exns, &quot;location&quot;);<br>		Literal alice_loc = vf.createLiteral(&quot;+30.0+30.0&quot;, cartSystem);<br>		Literal bob_loc = vf.createLiteral(&quot;+40.0+40.0&quot;, cartSystem);<br>		Literal carol_loc = vf.createLiteral(&quot;+50.0+50.0&quot;, cartSystem);<br>		conn.add(alice, location, alice_loc);<br>		conn.add(bob, location, bob_loc);<br>		conn.add(carol, location, carol_loc);</pre>
<p>Note that the coordinate pairs need to be encapsulated in a literal value that references the appropriate coordinate system. </p>
<p>The problem is to find the people whose locations lie within this box:</p>
<p><img src="geoBox1.jpg" width="412" height="330"></p>
<p>Locating the matching entities is remarkably easy to do. The <strong>getStatementsInBox()</strong> method requires the coordinate system object and the location predicate, plus the <strong>xmin</strong>, <strong>xmax</strong>, <strong>ymin</strong> and <strong>ymax</strong> limits of the search region. The last two arguments of the method let you place a limit on the number of results (0 means no limit), and you can optionally turn on inferencing. </p>
<pre class="input">        RepositoryResult result = conn.getStatementsInBox(cartSystem, location, 20, 40, 20, 40, 0, false);<br>        printRows(result);<br>        result.close();</pre>
<p>This retrieves all the location triples whose coordinates fall within the region. Here are the resulting triples:</p>
<pre class="output">(&lt;http://example.org/people/alice&gt;, &lt;http://example.org/people/location&gt;, 
&quot;+30.000000004656613+30.000000004656613&quot;^^&lt;http://franz.com/ns/allegrograph/3.0/geospatial/cartesian/0.0/100.0/0.0/100.0/1.0&gt;)<br>(&lt;http://example.org/people/bob&gt;, &lt;http://example.org/people/location&gt;, 
&quot;+39.999999990686774+39.999999990686774&quot;^^&lt;http://franz.com/ns/allegrograph/3.0/geospatial/cartesian/0.0/100.0/0.0/100.0/1.0&gt;) </pre>
<p>AllegroGraph has located Alice and Bob, as expected. Note that Bob was exactly on the corner of the search area, showing that the boundaries are inclusive. </p>
<p>We can also find all objects within a circle with a known center and radius. </p>

<p><img src="geoCircle1.jpg" width="415" height="333"></p>
<p>The getStatementsInCircle() method asks for the coordinate system object, the location predicate, the X and Y location of the circle's center, and the radius. The final two arguments are the limit and the inferencing switch. </p>
<pre class="input">        RepositoryResult result2 = conn.getStatementsInCircle(cartSystem, location, 35, 35, 10, 0, false);<br>        printRows(result2);<br>        result2.close();</pre>
<p>A search within circle1 finds Alice and Bob again:</p>
<pre class="output">(&lt;http://example.org/people/alice&gt;, &lt;http://example.org/people/location&gt;, 
&quot;+30.000000004656613+30.000000004656613&quot;^^&lt;http://franz.com/ns/allegrograph/3.0/geospatial/cartesian/0.0/100.0/0.0/100.0/1.0&gt;)<br>(&lt;http://example.org/people/bob&gt;, &lt;http://example.org/people/location&gt;, 
&quot;+39.999999990686774+39.999999990686774&quot;^^&lt;http://franz.com/ns/allegrograph/3.0/geospatial/cartesian/0.0/100.0/0.0/100.0/1.0&gt;) </pre>
<p>AllegroGraph can also locate points that lie within an irregular polygon. First we need to define the polygon. The polygon has to be assembled as a list of vertices which is then registered with the connection object. </p>
<pre class="input"> URI polygon1 = vf.createURI(&quot;http://example.org/polygon1&quot;);
 List&lt;Literal&gt; polygon1_points = new ArrayList&lt;Literal&gt;(4);
 polygon1_points.add(vf.createLiteral(&quot;+10.0+40.0&quot;, cartSystem));
 polygon1_points.add(vf.createLiteral(&quot;+50.0+10.0&quot;, cartSystem));
 polygon1_points.add(vf.createLiteral(&quot;+35.0+40.0&quot;, cartSystem));
 polygon1_points.add(vf.createLiteral(&quot;+50.0+70.0&quot;, cartSystem));
 conn.registerPolygon(polygon1, polygon1_points); </pre>
<p><img src="geoPolygon1.jpg" width="423" height="330"></p>
<p>When we ask what people are within polygon1, AllegroGraph finds Alice.</p>
<pre class="input">        RepositoryResult result3 = conn.getStatementsInPolygon(cartSystem, location, polygon1, 0, false);<br>        printRows(result3);<br>        result3.close();</pre>
<pre class="output">(&lt;http://example.org/people/alice&gt;, &lt;http://example.org/people/location&gt;, 
&quot;+30.000000004656613+30.000000004656613&quot;^^&lt;http://franz.com/ns/allegrograph/3.0/geospatial/cartesian/0.0/100.0/0.0/100.0/1.0&gt;)</pre>
<h3>Spherical System</h3>
<p>A spherical coordinate system projects (X,Y) locations on a spherical surface, simulating locations on the surface of the earth. AllegroGraph supports the usual units of latitude and longitude in the spherical system. The default unit of distance is the kilometer (km). (These functions presume that the sphere is the size of the planet earth. For spherical coordinate systems of other sizes, you will have to work with the Lisp radian functions that underlie this interface.)</p>
<p><img src="geoWorld.jpg" width="602" height="340"></p>
<p>To establish a global coordinate system, use the connection object's createLatLongSystem() method. </p>
<pre class="input">         URI sphericalSystemDegree = conn.registerSphericalType(5, &quot;degree&quot;);</pre>
<p>Once again, the <strong>stripWidth</strong> parameter is an estimate of the size of a typical search area, in the longitudinal direction this time. The default unit is the &quot;degree&quot;, but the method also accepts kilometers (&quot;km&quot;). For this system, we expect a typical search to cover about five degrees in the east-west direction. Actual search regions may be as much as ten times larger or smaller without significantly impacting performance. If the application will use search regions that are significantly larger or smaller, then you will want to create multiple coordinate systems that have been optimized for different scales. </p>
<p>First we set up the resources for the entities within the spherical system. We'll need these subject URIs:</p>
<pre class="input">        URI amsterdam = vf.createURI(exns, &quot;amsterdam&quot;);<br>        URI london = vf.createURI(exns, &quot;london&quot;);<br>        URI sanfrancisco = vf.createURI(exns, &quot;sanfrancisco&quot;);<br>        URI salvador = vf.createURI(exns, &quot;salvador&quot;);</pre>
<p>Then we'll need a <strong>geolocation</strong> predicate to describe the lat/long coordinates of each entity.</p>
<pre class="input">        location = vf.createURI(exns, &quot;geolocation&quot;);</pre>
<p>Now we can create the entities by asserting a geolocation for each one. Note that the coordinates have to be encapsulated in literal objects: </p>
<pre class="input">        conn.add(amsterdam, location, vf.createLiteral(&quot;+52.366665+004.883333&quot;,sphericalSystemDegree));<br>        conn.add(london, location, vf.createLiteral(&quot;+51.533333-000.08333333&quot;,sphericalSystemDegree));<br>        conn.add(sanfrancisco, location, vf.createLiteral(&quot;+37.783333-122.433334&quot;,sphericalSystemDegree));<br>        conn.add(salvador, location, vf.createLiteral(&quot;+13.783333-088.45&quot;,sphericalSystemDegree));</pre>
<p>The coordinates are decimal degrees. Northern latitudes and eastern longitudes are positive. </p>
<p>The next experiment is to search a box-shaped region on the surface of the sphere. (The &quot;box&quot; follows lines of latitude and longitude.) This region corresponds roughly to the contiguous United States. </p>
<p><img src="geoBox2.jpg" width="634" height="361"></p>
<p>Now we retrieve all the triples located within the search region:</p>
<pre class="input">        RepositoryResult result4 = conn.getStatementsInBox(sphericalSystemDegree, location, -130.0f, -70.0f, 25.0f, 50.0f, 0, false);<br>		printRows(result4);<br>		result4.close();</pre>
<p>AllegroGraph has located San Francisco:</p>
<pre class="output">(&lt;http://example.org/people/sanfrancisco&gt;, &lt;http://example.org/people/geolocation&gt;,
&quot;+374659.49909-1222600.00212&quot;^^&lt;http://franz.com/ns/allegrograph/3.0/geospatial/
spherical/degrees/-180.0/180.0/-90.0/90.0/5.0&gt;) 
</pre>
<p>This time let's search for entities within 2000 kilometers of Mexico City, which is located at 19.3994 degrees north latitude, -99.08 degrees west longitude. </p>

<p><img src="geoCircle2.jpg" width="630" height="365"></p>
<pre class="input">		RepositoryResult result5 = conn.getGeoHaversine(sphericalSystemDegree, location, 19.3994f, -99.08f, 2000.0f, &quot;km&quot;, 0, false);<br>		printRows(result5);<br>		result5.close();</pre>
<pre class="output">(&lt;http://example.org/people/salvador&gt;, &lt;http://example.org/people/geolocation&gt;, 
&quot;+134659.49939-0882700&quot;^^&lt;http://franz.com/ns/allegrograph/3.0/geospatial/spherical/degrees/-180.0/180.0/-90.0/90.0/5.0&gt;)</pre>
<p>And AllegroGraph returns the triple representing El Salvador. </p>
<p>In the next example, the search area is a triangle roughly enclosing the United Kingdom. We begin by registering the polygon: </p>
<pre class="input">        URI polygon2 = vf.createURI(&quot;http://example.org/polygon2&quot;);<br>        List&lt;Literal&gt; polygon2_points = new ArrayList&lt;Literal&gt;(3);<br>        polygon2_points.add(vf.createLiteral(&quot;+51.0+002.0&quot;, sphericalSystemDegree));<br>        polygon2_points.add(vf.createLiteral(&quot;+60.0-005.0&quot;, sphericalSystemDegree));<br>        polygon2_points.add(vf.createLiteral(&quot;+48.0-012.5&quot;, sphericalSystemDegree));<br>        conn.registerPolygon(polygon2, polygon2_points);</pre>
<p><em><img src="geoPolygon2.jpg" width="631" height="385"> </em></p>
<p>We ask AllegroGraph to find all entities within this triangle:</p>
<pre class="input">        RepositoryResult result6 = conn.getStatementsInPolygon(sphericalSystemDegree, location, polygon2, 0, false);<br>        printRows(result6);<br>        result6.close();</pre>
<pre class="output">(&lt;http://example.org/people/london&gt;, &lt;http://example.org/people/geolocation&gt;, 
&quot;+513159.49909-0000459.99970&quot;^^&lt;http://franz.com/ns/allegrograph/3.0/geospatial/spherical/degrees/-180.0/180.0/-90.0/90.0/5.0&gt;)</pre>
<p>AllegroGraph returns the location of London, but not the nearby Amsterdam.</p>

<h2 id="Social Network Analysis">Social Network Analysis  (example21())&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>AllegroGraph includes sophisticated algorithms for social-network analysis (SNA). It can examine an RDF graph of relationships among people (or similar entities, such as businesses) and discover:</p>
<ul>
  <li>Cliques of mutually-supporting individuals.</li>
  <li>The importance of a person within a clique. </li>
  <li>Paths from one individual to another.</li>
  <li>Bottlenecks where information flow might be controlled or break down. </li>
</ul>
<p>This section has multiple subsections:</p>
<ul>
  <li><a href="#Example Network">Example Network</a></li>
  <li><a href="#Setting Up the Example">Setting Up the Example</a></li>
  <li><a href="#Creating SNA Generators">Creating SNA Generators</a></li>
    <li><a href="#Creating Neighbor Matrices">Creating Neighbor Matrices</a></li>
    <li><a href="#Deleting Generators and Matrices">Deleting Generators and Matrices</a></li>
    <li><a href="#SNA Search - Ego Group">SNA Search - Ego Group</a></li>
    <li><a href="#SNA Search - Path from A to B">SNA Search - Path from A to B</a></li>
    <li><a href="#Graph Measures">Graph Measures</a></li>
    <li><a href="#Cliques">Cliques</a></li>
    <li><a href="#Actor Centrality">Actor Centrality</a></li> 
    <li><a href="#Group Centrality">Group Centrality</a></li> 
</ul>
<p>Most (but not all) of AllegroGraph's SNA features can be accessed from Java. We access them in multiple ways:</p>
<ul>
  <li>The Java API to AllegroGraph contains setup functions that let you create an SNA environment ready for queries.</li>
  <li>From Java, we can issue Prolog queries to AllegroGraph. Some of the SNA functions have Prolog equivalents that can be called directly from a query. These are explored in the sections below. </li>
  <li>Within a Prolog query, we can open a window into Lisp and reach for the AllegroGraph's Lisp SNA functions. </li>
</ul>
<h3 id="Example Network">Example Network</h3>
<p>The example file for this exercise is <strong>java-lesmis.rdf</strong>. It contains resources representing 80 characters from Victor Hugo's <em>Les Miserables</em>, a novel about Jean Valjean's search for redemption in 17th-century Paris. </p>
<p>The raw data behind the model measured the strength of relationships by counting the number of book chapters where two characters were both present. The five-volume novel has 365 chapters, so it was possible to create a relationship network that had some interesting features. This is a partial display of the graph in <a href="/agraph/gruff/index.lhtml">Franz's Gruff graphical browser</a>. </p>
<p><img src="lesmismap.jpg" width="768" height="426"> </p>
<p>There are four possible relationships between any two characters. </p>
<ul>
  <li><strong>No direct connection</strong>. (They never appeared in the same chapter.) AllegroGraph can locate indirect connections through their mutual acquaintances.</li>
  <li><strong>Barely knows.</strong> The characters barely know each other.</li>
  <li><span class="style2"><strong>Knows</strong></span><strong>.</strong> The two characters appear together in 15 or more chapters.</li>
  <li><span class="style3"><strong>Knows well</strong></span><strong>.</strong> The two characters appear together in 25 or more chapters. </li>
</ul>
<p>(The Gruff illustrations were made from a parallel repository in which the resources were altered to display the character's name in the graph node rather than his URI. That file is called<strong> lemisNames.rdf</strong>.) </p>
<h3 id="Setting Up the Example">Setting Up the Example</h3>
<p>The SNA examples are in function <strong>example21() </strong>in JenaTutorialExamples.java. These are the same initializing steps we have used in previous examples. </p>
<pre class="input">    	AGServer server = new AGServer(SERVER_URL, USERNAME, PASSWORD);<br>    	AGCatalog catalog = server.getCatalog(CATALOG_ID);<br>    	catalog.deleteRepository(REPOSITORY_ID);<br>    	AGRepository myRepository = catalog.createRepository(REPOSITORY_ID);<br>    	myRepository.initialize();<br>    	AGValueFactory vf = myRepository.getValueFactory();<br>    	AGRepositoryConnection conn = myRepository.getConnection();<br>    	closeBeforeExit(conn);</pre>
<p>The next step is to load the java-lesmis.rdf file.</p>
<pre class="input">    	conn.add(new File(&quot;src/tutorial/java-lesmis.rdf&quot;), null, RDFFormat.RDFXML);</pre>

<p>There are three predicates of interest in the Les Miserables repository. We need to create their URIs and bind them for later use. These are the <strong>knows, barely_knows,</strong> and <strong>knows_well</strong> predicates. </p>
<pre class="input">        // Create URIs for relationship predicates.<br>    	String lmns = &quot;http://www.franz.com/lesmis#&quot;;<br>        conn.setNamespace(&quot;lm&quot;, lmns);<br>        URI knows = vf.createURI(lmns, &quot;knows&quot;);<br>        URI barelyKnows = vf.createURI(lmns, &quot;barely_knows&quot;);<br>        URI knowsWell = vf.createURI(lmns, &quot;knows_well&quot;);</pre>
<p>We need to bind a URI Valjean as a convenience. </p>
<pre class="input">        URI valjean = vf.createURI(lmns, &quot;character11&quot;);</pre>
<h3 id="Creating SNA Generators">Creating SNA Generators</h3>
<p>The SNA functions use &quot;generators&quot; to describe the relationships  we want to analyze. A generator encapsulates a list of predicates to use in social network analysis. It also describes the directions in which each predicate is interesting. </p>
<p>In an RDF graph, two resources are linked by a single triple, sometimes called a &quot;resource-valued predicate.&quot; This triple has a resource URI in the <em>subject</em> position, and a different one in the <em>object</em> position. For instance:</p>
<pre>    (&lt;Cosette&gt;, knows_well, &lt;Valjean&gt;)</pre>
<p>This triple  is a one-way link unless we tell the generator to treat it as bidirectional. This is frequently necessary in RDF data, where inverse relations are often implied but not explicitly declared as triples. </p>
<p>For this exercise, we will declare three generators:</p>
<ul>
  <li>&quot;intimates&quot; uses <strong>knows_well</strong> as a bidirectional predicate.</li>
  <li>&quot;associates&quot; uses <strong>knows</strong> and <strong>knows_well</strong> as bidirectional predicates.</li>
  <li>&quot;everyone&quot; uses <strong>barely_knows</strong>, <strong>knows</strong>, and <strong>knows_well</strong> as bidirectional predicates. </li>
</ul>
<p>"Intimates" takes a narrow view of persons who know one another quite well. "Associates" follows both strong and medium relationships. "Everyone" follows all relationships, even the weak ones. This provides three levels of resolution for our analysis.</p>
<p>The connection object's <strong>registerSNAGenerator()</strong> method asks for a generator name (any label), and then for one or more predicates of interest. The predicates are bundled into lists, and then appropriate lists are assigned to the &quot;subjectOf&quot; direction, the &quot;objectOf&quot; direction, or the &quot;undirected&quot; direction (both ways at once). In addition, you may specify a &quot;generator query,&quot; which is a Prolog &quot;select&quot; query that lets you be more specific about the links you want to analyze. </p>
<p>&quot;Intimates&quot; follows &quot;knows_well&quot; links only, and it treats them as bidirectional. If Cosette knows Valjean, then we'll assume that Valjean knows Cosette. </p>
<pre class=input>        List&lt;URI&gt; intimates = new ArrayList&lt;URI&gt;(1);<br>        Collections.addAll(intimates, knowsWell);<br>        conn.registerSNAGenerator(&quot;intimates&quot;, null, null, intimates, null);</pre>
<p>&quot;Associates&quot; follows &quot;knows&quot; and &quot;knows_well&quot; links. </p>
<pre class="input">        List&lt;URI&gt; associates = new ArrayList&lt;URI&gt;(2);<br>        Collections.addAll(associates, knowsWell, knows);<br>        conn.registerSNAGenerator(&quot;associates&quot;, null, null, associates, null);</pre>
<p>&quot;Everyone&quot; follows all three relationship links. </p>
<pre class="input">        List&lt;URI&gt; everyone = new ArrayList&lt;URI&gt;(3);<br>        Collections.addAll(everyone, knowsWell, knows, barelyKnows);<br>        conn.registerSNAGenerator(&quot;everyone&quot;, null, null, everyone, null);</pre>
<p>In these examples of registerSNAGenerator(), the five arguments represnet the name of the generator, the predicates to follow in the &quot;object&quot; direction, the predicates to follow in the &quot;subject&quot; direction, the predicates to follow in both directions, and finally, an optional Prolog query to further refine the links that are cataloged by the generator. </p>		

<h3 id="Creating Neighbor Matrices">Creating Neighbor Matrices</h3>
<p>A generator provides a powerful and flexible tool for examining a graph, but it performs repeated queries against the repository in order to extract the subgraph appropriate to your query. If your data is static, the generator will extract the same subgraph each time you use it. It is better to run the generator once and store the results for quick retrieval. </p>
<p>That is the purpose of  a &quot;neighbor matrix.&quot; This is a persistent, in-memory cache of a generator's output. You can substitute the matrix for the generator in AllegroGraph's SNA functions. </p>
<p>The advantage of using a matrix instead of a generator is a many-fold increase in speed. This benefit is especially visible if you are searching for paths between two nodes in your graph. The exact difference in speed is difficult to estimate because there can be complex trade-offs and scaling issues to consider, but it is easy to try the experiment and observe the effect. </p>
<p>To create a matrix, use the connection object's <strong>registerNeighborMatrix()</strong> method. You must supply a matrix name (any symbol), the name of the generator, the URI of a resource to serve as the starting point, and a maximum depth. The idea is to place limits on the subgraph so that the search algorithms can operate in a restricted space rather than forcing them to analyze the entire repository. </p>
<p>In the following excerpt, we are creating three matrices to match the three generators we created. In this example, &quot;matrix1&quot; is the matrix for generator &quot;intimates,&quot; and so forth. </p>
<pre class="input">        List&lt;URI&gt; startNodes = new ArrayList&lt;URI&gt;(1);<br>        startNodes.add(valjean);<br>        conn.registerSNANeighborMatrix(&quot;matrix1&quot;, &quot;intimates&quot;, startNodes, 2);<br>        conn.registerSNANeighborMatrix(&quot;matrix2&quot;, &quot;associates&quot;, startNodes, 5);<br>        conn.registerSNANeighborMatrix(&quot;matrix3&quot;, &quot;everyone&quot;, startNodes, 2);</pre>
<p>A matrix is a static snapshot of the output of a generator.  If your data is dynamic, you should regenerate the matrix at intervals.</p>

<h3 id="Deleting Generators and Matrices">Deleting Generators and Matrices</h3>
<p>There is no direct way to delete individual matrices and generators, but closing the connection frees all of the resources formerly used by all of the objects and structures that were created there. </p>

<h3 id="SNA Search - Ego Group"><strong>SNA Search - Ego Group</strong></h3>
<p>Our first search will enumerate Valjean's &quot;ego group members.&quot; This is the set of nodes (characters) that can be found by following the interesting predicates out from Valjean's node of the graph to some specified depth. We'll use the &quot;associates&quot; generator (&quot;knows&quot; and &quot;knows_well&quot;) to specify the predicates, and we'll impose a depth limit of one link. This is the group we expect to find:</p>
<p><img src="snaEgoGroup.jpg" width="599" height="203"></p>
<p>The following Java code sends a Prolog query to AllegroGraph and returns the result to Java. </p>
<pre class="input">        println(&quot;\nValjean's ego group members (using associates).&quot;);<br>        String queryString = &quot;(select (?member ?name)&quot; +<br>          &quot;(ego-group-member !lm:character11 1 associates ?member)&quot; +<br>          &quot;(q ?member !dc:title ?name))&quot;;<br>        TupleQuery tupleQuery = conn.prepareTupleQuery(AGQueryLanguage.PROLOG, queryString);<br>        TupleQueryResult result = tupleQuery.evaluate();<br>        int count = 0;<br>        while (result.hasNext()) {<br>            BindingSet bindingSet = result.next();<br>            Value p = bindingSet.getValue(&quot;member&quot;);<br>            Value n = bindingSet.getValue(&quot;name&quot;);<br>            println(&quot;Member: &quot; + p + &quot;, name: &quot; + n);<br>            count++;<br>        }<br>        println(&quot;Number of results: &quot; + count);<br>        result.close();</pre>
<p>This is the iconic block of code that is repeated in all of the SNA examples, below, with minor variations in the display of bindingSet values. To save virtual trees, we'll focus more tightly on the Prolog query from this point on:</p>
<pre class="input">    (select (?member ?name)
      (ego-group-member !lm:character11 1 associates ?member)
      (q ?member !dc:title ?name))
</pre>
<p>In this example, <strong>ego-group-member</strong> is an AllegroGraph SNA function that has been adapted for use in Prolog queries. There is a list of such functions on the <a href="/agraph/support/documentation/current/reference-guide.html#sna">AllegroGraph documentation reference page</a>. </p>
<p>The query will execute <strong>ego-group-member</strong>, using Valjean (character11) as the starting point, following the predicates described in &quot;associates,&quot; to a depth of 1 link. It binds each matching node to <strong>?member</strong>. Then, for each binding of ?member, the query looks for the member's <strong>dc:title</strong> triple, and binds the member's <strong>?name</strong>.  The query returns multiple results, where each result is a (?member ?name) pair. The result object is passed back to Java, where we can iterate over the results and print out their values. </p>
<p>This is the output of the example:</p>
<pre class="output">Valjean's ego group members (using associates).<br>Member: http://www.franz.com/lesmis#character27, name: &quot;Javert&quot;<br>Member: http://www.franz.com/lesmis#character25, name: &quot;Thenardier&quot;<br>Member: http://www.franz.com/lesmis#character28, name: &quot;Fauchelevent&quot;<br>Member: http://www.franz.com/lesmis#character23, name: &quot;Fantine&quot;<br>Member: http://www.franz.com/lesmis#character26, name: &quot;Cosette&quot;<br>Member: http://www.franz.com/lesmis#character55, name: &quot;Marius&quot;<br>Member: http://www.franz.com/lesmis#character11, name: &quot;Valjean&quot;<br>Member: http://www.franz.com/lesmis#character24, name: &quot;MmeThenardier&quot;<br>Number of results: 8</pre>
<p>If you compare this list with the Gruff-generated image of Valjean's ego group, you'll see that AllegroGraph has found all eight expected nodes. You might be surprised that Valjean is regarded as a member of his <em>own</em> ego group, but that is a logical result of the definition of &quot;ego group.&quot; The ego group is the set of all nodes within a certain depth of the starting point, and certainly the starting point must be is a member of that set. </p>
<p>We can perform the same search using a neighbor matrix, simply by substituting &quot;matrix2&quot; for &quot;associates&quot; in the query:</p>
<pre class="input">    (select (?member ?name)
      (ego-group-member !lm:character11 1 <strong>matrix2</strong> ?member)
      (q ?member !dc:title ?name))
</pre>
<p>This produces the same set of result nodes, but under the right circumstances the matrix would run a lot faster than the generator. </p>
<p>This variation returns Valjean's ego group as a single list:</p>
<pre class="input">    (select ?group
      (ego-group !lm:character11 1 associates ?group))</pre>
The result in the Java interaction window is:
<pre class="output">Valjean's ego group in one list depth 1 (using associates).<br>Group: &quot;({character27} {character25} {character28} {character23} {character26}<br> {character55} {character11} {character24})&quot;<br>Number of results: 1</pre>
<h3 id="SNA Search - Path from A to B">SNA Search - Path from A to B</h3>
<p>In the following examples, we explore the graph for the shortest path from Valjean to Bossuet, using the three generators to place restrictions on the quality of the path. These are the relevant paths between these two characters:</p>
<img src="pathsValBos.jpg" width="913" height="254"> 
<p>Our first query asks AllegroGraph to use <strong>intimates</strong> to find the shortest possible path between Valjean and Bossuet that is composed entirely of &quot;knows_well&quot; links. Those would be the green arrows in the diagram above. The <strong>breadth-first-search-paths</strong> function asks for a start node and an end node, a generator, an optional maximum path length, and a variable to bind to the resulting path(s). Valjean is character11, and Bossuet is character64.</p>
<pre class="input">    (select ?path
      (breadth-first-search-paths !lm:character11 !lm:character64 intimates 10 ?path))</pre>
<p>It is easy to examine the diagram and see that there is no such path. Valjean and Bossuet are not well-acquainted, and do not have any chain of well-acquainted mutual friends. AllegroGraph lets us know that.</p>
<pre class="output">Shortest breadth-first path connecting Valjean to Bossuet using intimates. (Should be no path.)<br>Number of results: 0</pre>
<p>This time we'll broaden the criteria. What is the shortest path from Valjean to Bossuet, using <strong>associates</strong>? We can follow either &quot;knows_well&quot; or &quot;knows&quot; links across the graph. Those are the green and the blue links in the diagram. </p>
<pre class="input">(select ?path
      (breadth-first-search-paths !lm:character11 !lm:character64 associates 10 ?path))</pre>
<p>Although there are multiple such paths, there are only two that are &quot;shortest&quot; paths. </p>
<pre class="output">Shortest breadth-first path connecting Valjean to Bossuet using associates.<br>Path: &quot;({character11} {character55} {character58} {character64})&quot;<br>Path: &quot;({character11} {character55} {character62} {character64})&quot;<br>Number of results: 2</pre>
<p>These are the paths &quot;Valjean &gt; Marius &gt; Enjolras &gt; Bossuet&quot; and &quot;Valjean &gt; Marius &gt; Courfeyrac &gt; Bossuet.&quot; AllegroGraph returns two paths because they are of equal length. If one of the paths had been shorter, it would have returned only the short path. </p>
<p>Our third query asks for the shortest path from Valjean to Bossuet using <strong>everyone</strong>, which means that &quot;barely-knows&quot; links are permitted in addition to &quot;knows&quot; and &quot;knows_well&quot; links. </p>
<pre class="input">    (select ?path
      (breadth-first-search-paths !lm:character11 !lm:character64 everyone 10 ?path))
</pre>
<p>This time AllegroGraph returns a single, short path:</p>
<pre class="output">Shortest breadth-first path connecting Valjean to Bossuet using everyone.<br>Path: &quot;({character11} {character64})&quot;<br>Number of results: 1</pre>
<p>This is the &quot;barely-knows&quot; link directly from from Valjean to Bossuet. </p>
<p>The Prolog select query can also use <strong>depth-first-search-path()</strong> and <strong>bidirectional-search-paths()</strong>. Their syntax is essentially identical to that shown above. These algorithms offer different efficiencies:</p>
<ul>
  <li>Breadth-first and bidirectional searches explore all paths by incrementing the search radius until a success is achieved. This guarantees that the returned path(s) will be &quot;shortest&quot; paths. They return one or more paths of equal length. </li>
  <li>Depth-first search tries to bypass the costly expansion of all paths by exploring each path to its end, and aborting the search when it locates a successful path. There is no implication that this path is the &quot;shortest&quot; path through the graph. </li>
</ul>
<p>In addition, the depth-first algorithm uses less memory than the others, so a depth-first search may succeed when a breadth-first search would run out of memory. </p>
<h3 id="Graph Measures">Graph Measures</h3>
<p>AllegroGraph provides several utility functions that measure the characteristics of a node, such as the number of connections it has to other nodes, and its importance as a communication path in a clique. </p>
<p>For instance, we can use the <strong>nodal-degree</strong> function to ask how many nodal neighbors Valjean has, using <strong>everyone</strong> to catalog all the nodes connected to Valjean by &quot;knows,&quot; &quot;barely_knows&quot;, and &quot;knows_well&quot; predicates. There are quite a few of them:</p>
<p><img src="allLinksValjean.jpg" width="720" height="341"> </p>
<p>The nodal-degree function requires the URI of the target node (Valjean is character11), the generator, and a variable to bind the returned value to. </p>
<pre class="input">        println(&quot;\nHow many neighbors are around Valjean? (should be 36).&quot;);<br>        queryString = &quot;(select ?neighbors&quot; +<br>          &quot;(nodal-degree !lm:character11 everyone ?neighbors))&quot;;<br>        tupleQuery = conn.prepareTupleQuery(AGQueryLanguage.PROLOG, queryString);<br>        result = tupleQuery.evaluate();<br>        while (result.hasNext()) {<br>            BindingSet bindingSet = result.next();<br>            Value p = bindingSet.getValue(&quot;neighbors&quot;);<br>            println(&quot;Neighbors: &quot; + p );<br>            println(&quot;Neighbors: &quot; + p.stringValue());<br>        }<br>        result.close();</pre>

<p>Note that this function returns a string that describes an integer, which in its raw form is difficult for Java to use. We convert the raw value to a Java integer using the <strong>.stringValue() </strong>method that is available to all literal values in the Java API to AllegroGraph. This example prints out both the string value and the converted number.</p>
<pre class="output">How many neighbors are around Valjean? (should be 36).
"36"^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;
36</pre>
<p>If you want to see the names of these neighbors, you can use either the <strong>ego-group-member</strong> function described earlier on this page, or the <strong>nodal-neighbors</strong> function shown below:</p>
<pre class="input">        println(&quot;\nWho are Valjean's neighbors? (using everyone).&quot;);<br>        queryString = &quot;(select ?name&quot; +<br>          &quot;(nodal-neighbors !lm:character11 everyone ?member)&quot; +<br>          &quot;(q ?member !dc:title ?name))&quot;;<br>        tupleQuery = conn.prepareTupleQuery(AGQueryLanguage.PROLOG, queryString);<br>        result = tupleQuery.evaluate();<br>        count = 0;<br>        while (result.hasNext()) {<br>            BindingSet bindingSet = result.next();<br>            Value p = bindingSet.getValue(&quot;name&quot;);<br>            count++;<br>            println(count + &quot;. &quot; + p.stringValue());<br>        }<br>        result.close();</pre>
<p>This example enumerates all immediate neighbors of Valjean and returns their names in a numbered list. There are 36 names in the full list. <pre class="output">Who are Valjean's neighbors? (using everyone).<br>1. Isabeau<br>2. Fantine<br>3. Labarre<br>4. Bossuet<br>5. Brevet ...</pre>

<p>Another descriptive statistic is <strong>graph-density</strong>, which measures the density of connections within a subgraph. </p>
<p>For instance, this is Valjean's ego group with all <strong>associates</strong>  included. </p>
<p><img src="graphDensity.jpg" width="806" height="297"> </p>
<p>Only 9 of 28 possible links are in place in this subgraph, so the graph density is 0.32. The following query asks AllegroGraph to calculate this figure for Valjean's ego group:</p>
<pre class="input">
    (select ?density
      (ego-group !lm:character11 1 associates ?group)
      (graph-density ?group associates ?density))
</pre>
<p>We used the<strong> ego-group</strong> function to return a list of Valjean's ego-group members, bound to the variable <strong>?group</strong>, and then we used ?group to feed that subgraph to the <strong>graph-density</strong> function. The return value, <strong>?density</strong>, came back as a string describing a float, and had to be converted to a Java float using <strong>.toJava()</strong>.</p>
<pre class="output">Graph density of Valjean's ego group? (using associates).<br>Graph density: 3.2142857e-1</pre>
<h3 id="Cliques">Cliques</h3>
<p>A &quot;clique&quot; is a subgraph where every node is connected to every other node by predicates specified in some generator. AllegroGraph, using everyone (&quot;knows,&quot; &quot;knows_well,&quot; and &quot;barely_knows&quot;), found that Valjean participates in 239 cliques! </p>
<p><img src="valjeanBigClique.jpg" width="859" height="301"> </p>
<p>It is counterintuitive that a &quot;clique&quot; should be composed mainly of people who &quot;barely_know&quot; each other, so let's try the same experiment using &quot;associates,&quot; which restricts the cliques to people Valjean &quot;knows&quot; or &quot;knows_well.&quot; In this case, AllegroGraph returns two cliques. One contains Valjean, Cosette, and Marius. The other contains Valjean and the Thenardiers. </p>
<p><img src="valjeanSmallCliques.jpg" width="397" height="248"> </p>
<p>This is the query that finds Valjean's &quot;associates&quot; cliques:</p>
<pre class="input">
    (select ?clique
      (clique !lm:character11 associates ?clique))
</pre>



<p>AllegroGraph returns two cliques:</p>
<pre class="output">Valjean's cliques? Should be two (using associates).<br>Clique: &quot;({character11} {character25} {character24})&quot;<br>Clique: &quot;({character11} {character55} {character26})&quot;<br>Number of results: 2</pre>
<p>The first list is the clique with Marius and Cosette. The second one represents the Thernardier clique. </p>
<h3 id="Actor Centrality">Actor Centrality </h3>
<p>AllegroGraph lets us measure the relative importance of a node in a subgraph using the <strong>actor-degree-centrality()</strong> function. For instance, it should be obvious that Valjean is very &quot;central&quot; to his own ego group (depth of one link), because he is linked directly to all other links in the subgraph. In that case he is linked to 7 of 7 possible nodes, and his actor-degree-centrality value is 7/7 = 1. </p>
<p>However, we can regenerate Valjean's ego group using a depth of 2. This adds three nodes that are not directly connected to Valjean. How &quot;central&quot; is he then?</p>
<p><img src="valjeanActorCentrality.jpg" width="875" height="303"> </p>
<p>In this subgraph, Valjean's actor-degree-centrality is 0.70, meaning that he is connected to 70% of the nodes in the subgraph. </p>
<p>This example asks AllegroGraph to generate the expanded ego group, and then to measure Valjean's actor-degree-centrality:</p>
<pre class="input">
    (select (?centrality)
      (ego-group !lm:character11 2 associates ?group)
      (actor-degree-centrality !lm:character11 ?group associates ?centrality))
</pre>
<p>Note that we asked <strong>ego-group()</strong> to explore to a depth of two links, and then fed its result (<strong>?group</strong>) to <strong>actor-degree-centrality()</strong>. This is the output:</p>
<pre class="output">Valjean's actor-degree-centrality to his ego group at depth 2 (using associates).<br>Centrality: 7.0e-1</pre>
<p>This confirms our expectation that Valjean's actor-degree-centrality should be 0.70 in this circumstance.</p>
<p>We can also measure actor centrality by calculating the average path length from a given node to the other nodes of the subgraph. This is called <strong>actor-closeness-centrality</strong>. For instance, we can calculate the average path length from Valjean to the ten nodes of his ego group (using associates and depth 2). Then we take the inverse of the average, so that bigger values will be &quot;more central.&quot; </p>
<p><img src="valjeanActorClosenessCentrality.jpg" width="875" height="303"> </p>
<p>The actor-closeness-centrality for Marius is 0.60, showing that Valjean is more central and important to the group than is Marius. </p>
<p>This example calculates Valjean's <strong>actor-closeness-centrality</strong> for the associates ego group of depth 2. </p>
<pre class="input">
    (select (?centrality)
      (ego-group !lm:character11 2 associates ?group)
      (actor-closeness-centrality !lm:character11 ?group associates ?centrality))
</pre>
<pre class="output">Valjean's actor-closeness-centrality to his ego group at depth 2 (using associates).<br>Centrality: 7.692308e-1</pre>
<p>That is the expected value of 0.769. </p>
<p>Another approach to centrality is to count the number of information paths that are &quot;controlled&quot; by a specific node. This is called<strong> actor-betweenness-centrality</strong>. For instance, there are 45 possible &quot;shortest paths&quot; between pairs of nodes in Valjean's associates depth-2 ego group. Valjean can act as an information valve, potentially cutting off communication on 34 of these 45 paths. Therefore, he controls 75% of the communication in the group. </p>
<p><img src="valjeanActorBetweenCentrality.jpg" width="875" height="303"></p>
<p>This example calculates Valjean's actor-betweenness-centrality:</p>
<pre class="input">
    (select (?centrality)
      (ego-group !lm:character11 2 associates ?group)
      (actor-betweenness-centrality !lm:character11 ?group associates ?centrality))
</pre>

<pre class="output">Valjean's actor-betweenness-centrality to his ego group at depth 2 (using associates).<br>Centrality: 7.5555557e-1</pre>
<p>That's the expected result of 0.755. </p>
<h3 id="Group Centrality">Group Centrality</h3>
<p>Group-centrality measures express the &quot;cohesiveness&quot; of a group. There are three group-centrality measures in AllegroGraph: <strong>group-degree-centrality()</strong>, <strong>group-closeness-centrality()</strong>, and <strong>group-betweenness-centrality()</strong>.</p>
<p>To demonstrate these measures, we'll use Valjean's ego group, first at radius 1 and then at radius 2. As you recall, the smaller ego group is radially symmetrical, but the larger one is quite lop-sided. That makes the smaller group &quot;more cohesive&quot; than the larger one.</p>
<p> <strong>Group-degree-centrality()</strong> measures group cohesion by finding the maximum actor centrality in the group, summing the difference between this and each other actor's degree centrality, and then normalizing. It ranges from 0 (when all actors have equal degree) to 1 (when one actor is connected to every other and no other actors have connections.</p>
<p>The prolog query takes this form:</p>
<pre class="input"> (select (?centrality)
   (ego-group !lm:character11 1 associates ?group)
   (group-degree-centrality ?group associates ?centrality))</pre>
<p>The query first generates Valjean's (character11) ego group at radius 1, and binds that list of characters to ?group. Then it calls group-degree-centrality() on the group and returns the answer as ?centrality. </p>
<p>The group-degree-centrality for Valjean's radius-1 ego group is 0.129. When we expand to radius 2, the group-degree-centrality drops to 0.056. The larger group is less cohesive than the smaller one. </p>
<p>The following examples were all generated from queries that strongly resemble the one above. </p>
<p> <strong>Group-closeness-centrality()</strong> is measured by first finding the actor whose `closeness-centrality` <br>
  is maximized and then summing the difference between this maximum value and the actor-closeness-centrality of all other actors. This value is then normalized so that it ranges between 0 and 1. </p>
<p>The group-closeness-centrality of Valjean's smaller ego group is 0.073. The expanded ego group has a group-closeness-centrality of 0.032. Again, the larger group is less cohesive.</p>
<p> Group-betweenness-centrality() is measured by first finding the actor whose actor-betweenness-centrality<br>
  is maximized and then summing the difference between this maximum value and the actor-betweenness-centrality of all other actors. This value is then normalized so that it ranges between 0 and 1. </p>
<p>Valjean's smaller ego group has a group-betweenness-centrality of 0.904. The value for the larger ego group is 0.704. Even by this measure, the larger group is less cohesive. </p>
<p>&nbsp;</p>
<h2 id="Transaction">Transaction (example22())</h2>
<p>Triples are normally loaded one at a time in &quot;auto-commit&quot; mode. Each triple enters the triple store individually. It is possible that a batch of incoming triples, all describing the same resource, might be interrupted for some reason. An interrupted load can leave the triple store in an unknown state. </p>
<p>In some applications we can't run the risk of having a resource that is incomplete.  To guard against this hazard, AllegroGraph can turn off auto-commit behavior and use &quot;transaction&quot; behavior instead. With auto-commit turned off, we can add triples until we have a complete set, a known state. If anything goes wrong to interrupt the load, we can roll the transaction back and start over. Otherwise, commit the transaction and all the triples enter the store at once. </p>
<p>In order to use transaction semantics, the user account must have &quot;:session&quot; privileges with AllegroGraph Server. This is an elevated level of privilege. AllegroGraph users are profiled through the </p>
<p>In practice, transaction semantics require at least two connections to the triple store, one in auto-commit mode and one in transaction mode. Queries should be run against the auto-commit connection, where the resources are always in a known and complete state. The transaction connection is used for loading and commiting batches of triples. </p>
<p>&quot;Commit&quot; means to make a batch of newly-loaded triples visible in the auto-commit connection. The two sessions are &quot;synched up&quot; by the commit. Any &quot;new&quot; triples added to either connection will suddenly be visible in both connections after a commit. </p>
<p>&quot;Rollback&quot; means to discard the recent additions to the transaction connection. This, too, synchs up the two sessions. After a rollback, the transaction connection &quot;sees&quot; exactly the same triples as the auto-commit connection does. </p>
<p>&quot;Closing&quot; the transaction connection deletes all uncommitted triples, and all rules, generators and matrices that were created in that connection. Rules, generators and matrices cannot be committed. </p>
<p>Example22() performs some simple data manipulations on a transaction connection to demonstrate the rollback and commit features. It begins by creating two connections to the repository. Then we turn one of them into a &quot;transaction&quot; connection by setting <strong>setAutoCommit()</strong> to <strong>false</strong>. </p>
<pre class="input">    public static void example22() throws Exception {<br>        AGServer server = new AGServer(SERVER_URL, USERNAME, PASSWORD);<br>        AGCatalog catalog = server.getCatalog(CATALOG_ID);<br>        AGRepository myRepository = catalog.createRepository(&quot;agraph_test&quot;);<br>        myRepository.initialize();<br>        AGValueFactory vf = myRepository.getValueFactory();<br>        // Create conn1 (autoCommit) and conn2 (no autoCommit).<br>        AGRepositoryConnection conn1 = myRepository.getConnection();<br>        closeBeforeExit(conn1);<br>        conn1.clear();<br>        AGRepositoryConnection conn2 = myRepository.getConnection();<br>        closeBeforeExit(conn2);<br>        conn2.clear();<br>        conn2.setAutoCommit(false);</pre>
<p>In this example,<strong> conn1</strong> is the auto-commit session, and <strong>conn2</strong> will be used for transactions. </p>
<p>We'll reuse the Kennedy and Les Miserables data. The Les Miserables data goes in the auto-commit session, and the Kennedy data goes in the transaction session. </p>
<pre class="input">        String baseURI = &quot;http://example.org/example/local&quot;;<br>        conn1.add(new File(&quot;src/tutorial/java-lesmis.rdf&quot;), baseURI, RDFFormat.RDFXML);<br>        println(&quot;Loaded &quot; + conn1.size() + &quot; java-lesmis.rdf triples into conn1.&quot;);<br>        conn2.add(new File(&quot;src/tutorial/java-kennedy.ntriples&quot;), baseURI, RDFFormat.NTRIPLES);<br>        println(&quot;Loaded &quot; + conn2.size() + &quot; java-kennedy.ntriples into conn2.&quot;);</pre>
<p>The two sessions should now have independent content. When we look in the auto-commit session we should see only Les Miserables triples. The transaction session could contain only Kennedy triples. We set up a series of simple tests similar to this one:</p>
<pre class="input">        Literal valjean = vf.createLiteral(&quot;Valjean&quot;);<br>        Literal kennedy = vf.createLiteral(&quot;Kennedy&quot;);<br>        printRows(&quot;\nUsing getStatements() on conn1 should find Valjean:&quot;,<br>                1, conn1.getStatements(null, null, valjean, false));</pre>
<p>This test looks for our friend Valjean in the auto-commit session. He should be there. This is the output:</p>
<pre class="output">Using getStatements() on conn1 should find Valjean:<br>(http://www.franz.com/lesmis#character11, http://purl.org/dc/elements/1.1/title, &quot;Valjean&quot;) [null]<br>Number of results: 1</pre>
<p>However, there should not be anyone in the auto-commit session named &quot;Kennedy.&quot; The code of the test is almost identical to that shown above, so we'll skip straight to the output.</p>
<pre class="output">Using getStatements() on conn1 should not find Kennedy:<br>Number of results: 0</pre>
<p>We should not see Valjean in the transaction session:</p>
<pre class="output">Using getStatements() on conn2 should not find Valjean:<br>Number of results: 0</pre>
<p>There should be a Kennedy (at least one) visible in the transaction session. (We limited the output to one match.) </p>
<pre class="output">Using getStatements() on conn2 should find Kennedy:<br>(http://www.franz.com/simple#person1, http://www.franz.com/simple#last-name, &quot;Kennedy&quot;) [null]<br>Number of results: 1</pre>
<p>The next step in the demonstration is to roll back the data in the transaction session. This will make the Kennedy data disappear. It will also make the Les Miserables data visible in both sessions. We'll perform the same four tests, with slightly different expectations.</p>

<p>First we roll back the transaction:</p>
<pre class="input">        println(&quot;\nRolling back contents of conn2.&quot;);<br>        conn2.rollback();</pre>
<p>Valjean is still visible in the auto-commit session:</p>
<pre class="output">Using getStatements() on conn1 should find Valjean:<br>(http://www.franz.com/lesmis#character11, http://purl.org/dc/elements/1.1/title, &quot;Valjean&quot;) [null]<br>Number of results: 1</pre>
<p>There are still no Kennedys in the auto-commit session: </p>
<pre class="output">Using getStatements() on conn1 should not find Kennedys:<br>Number of results: 0</pre>
<p>There should be no Kennedys visible in the transaction session:</p>
<pre class="output">Using getStatements() on conn2 should not find Kennedys:<br>Number of results: 0</pre>
<p>And finally, we should suddenly see Valjean in the transaction session:</p>
<pre class="output">Using getStatements() on conn2 should find Valjean:<br>(http://www.franz.com/lesmis#character11, http://purl.org/dc/elements/1.1/title, &quot;Valjean&quot;) [null]<br>Number of results: 1</pre>
<p>The rollback has succeeded in deleting the uncommitted triples from the transaction session. It has also refreshed or resynched the transaction session with the auto-commit session.</p>
<p>To set up the next test, we have to reload the Kennedy triples. Then we'll perform a commit.  </p>
<pre class="input">        println(&quot;\nReload 1214 java-kennedy.ntriples into conn2.&quot;);<br>        conn2.add(new File(&quot;src/tutorial/java-kennedy.ntriples&quot;), baseURI, RDFFormat.NTRIPLES);<br>        println(&quot;\nCommitting contents of conn2.&quot;);<br>        conn2.commit();</pre>
<p>This should make both types of triples visible in both sessions. Here are the four tests:</p>
<pre class="output">Using getStatements() on conn1 should find Valjean:
(http://www.franz.com/lesmis#character11, http://purl.org/dc/elements/1.1/title, "Valjean") [null]
Number of results: 1

Using getStatements() on conn1 should find Kennedys:
(http://www.franz.com/simple#person1, http://www.franz.com/simple#last-name, "Kennedy") [null]
Number of results: 1

Using getStatements() on conn2 should find Kennedys:
(http://www.franz.com/simple#person1, http://www.franz.com/simple#last-name, "Kennedy") [null]
Number of results: 1

Using getStatements() on conn2 should find Valjean:
(http://www.franz.com/lesmis#character11, http://purl.org/dc/elements/1.1/title, "Valjean") [null]
Number of results: 1</pre>
<p>The Les Miserables triples are visible in both sessions. So too are the Kennedy triples. </p>
<p>&nbsp;</p>
-->
</body>
</html>
