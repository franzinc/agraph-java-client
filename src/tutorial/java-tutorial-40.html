<html>
<head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<title>Java API Tutorial for AllegroGraph 4.0</title>

<style type="text/css">

.input { margin-left:4em; background-color:#ADDFFF;}
.output { margin-left:4em; background-color:#F1F1F1;}
.returnlink {font-size:small;  font-weight:normal; }

.style1 {
	color: #0000FF;
	font-weight: bold;
}
.style2 {
	color: #008040;
	font-weight: bold;
}
.style3 {
	color: #800080;
	font-weight: bold;
}
</style>
</head>
<body>
<h1>Java API Tutorial for AllegroGraph 4.0</h1>
<p>This is a introduction to the Java client API to AllegroGraph RDFStore&#8482; version 4.0 from <a href="http://agraph.franz.com/allegrograph/">Franz Inc.</a> </p>
<p>
The Java API offers convenient and efficient
access to an AllegroGraph server from a Java-based application.  This API provides methods for
creating, querying and maintaining RDF data, and for managing the stored triples. </p>
<p>The Java API deliberately emulates the Aduma Sesame API to make it easier to migrate from Sesame to AllegroGraph.&nbsp; The Java API has also been extended in ways that make it easier and more intuitive than the Sesame API.&nbsp; </p>
<h2 id="Contents">Contents</h2>
<table width="554" border="0" style="vertical-align:top" >
  <tr>
    <td width="249"><ul>
      <li><a href="#Overview">Overview</a></li>
<!--      <li><a href="#PrerequisitesWindows">Prerequisites (Windows)</a> </li>
      <li><a href="#PrerequisitesLinux">Prerequisites (Linux)</a></li>
-->      <li><a href="#Terminology">Terminology</a></li>
      <li><a href="#Creating a Repository">Creating a Repository</a></li>
      <li><a href="#Asserting and Retracting Triples">Asserting and Retracting Triples</a></li>
      <li><a href="#A SPARQL Query">A SPARQL Query</a></li>
      <li><a href="#Statement Matching">Statement Matching</a></li>
      <li><a href="#Literal Values">Literal Values</a></li>
      <li><a href="#Importing Triples">Importing Triples</a></li>
	  <li><a href="#Exporting Triples">Exporting Triples</a></li>      
      <li><a href="#Datasets and Contexts">Datasets and Contexts</a></li>
    </ul></td>
    <td width="295"><ul>
      <li><a href="#Namespaces">Namespaces</a></li>
      <li><a href="#Free Text Search">Free Text Search</a></li>
      <li><a href="#Ask, Describe, and Construct Queries">Ask, Describe, and Construct Queries</a></li>
      <li><a href="#Parametric Queries">Parametric Queries</a></li>
      <li><a href="#Range Matches">Range Matches</a></li>
<!--      <li><a href="#Federated Repositories">Federated Repositories</a></li>  -->
	  <li><a href="#Prolog Rule Queries">Prolog Rule Queries</a></li>
      <li><a href="#Loading Prolog Rules">Loading Prolog Rules</a> </li>
      <li><a href="#RDFS++ Inference">RDFS++ Inference</a> </li>
<!--      <li><a href="#Geospatial Search">Geospatial Search</a> </li>
      <li><a href="#Social Network Analysis">Social Network Analysis</a> </li>
-->      <li><a href="#Transaction">Transactions </a></li>
      </ul>
    <p>&nbsp;</p></td>
  </tr>
</table>
<p>&nbsp;</p>
<h2 id="Overview">Overview&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>The Java client tutorial rests on a simple architecture involving AllegroGraph, disk-based data files, Java, and a file of Java examples called TutorialExamples.java.</p>
<table width="964" border="0">
  <tr>
    <td width="286"><p>AllegroGraph 4.0 Server runs as a Windows service in this example. It contains the Java API, which is part of the AllegroGraph installation. </p>
    <p>Java communicates with AllegroGraph through HTTP port 8080 in this example. Java and AllegroGraph may be installed on the same computer, but in practice one server is shared by multiple clients. </p>
    <p>Load TutorialExamples.java into Java to view the tutorial examples. </p></td>
    <td width="668"><img src="allegrographdiagram.jpg" width="668" height="443"></td>
  </tr>
</table>
<p>Each lesson in <strong>TutorialExamples.java</strong> is encapsulated in a Java method, named exampleN(), where N ranges from 0 to 21 (or more). The function names are referenced in the title of each section to make it easier to compare the tutorial text and the living code of the examples file. </p>
<!--<h2 id="PrerequisitesLinux">Prerequisites (Windows) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<table border="1">
    <tr>
        <td width="867">The following procedure describes the installation of both the paid and free versions of AllegroGraph Server. Note that you cannot install both versions on the same computer. Follow the instructions that are appropriate to your version. </td>
    </tr>
</table>

<p>The tutorial examples can be run on a 32-bit Windows XP computer, running AllegroGraph and Java on the same computer (&quot;localhost&quot;). The tutorial assumes that AllegroGraph and Java 2.5 have  been installed and configured using this procedure:</p>
<p>&nbsp;</p>
<ol>
  <li>Download an AllegroGraph 4.0 installation file (agraph-4.0-windows.exe). The free edition is available <a href="http://www.franz.com/downloads/clp/ag_survey">here.</a> For the licensed edition please contact <a href="mailto:support@franz.com">Franz customer support</a> for a download link and authorizing key. </li>
  <li>Run the agraph-4.0-windows.exe to install AllegroGraph. The default installation directory is C:\Program Files\AllegroGraphFJE32 for the free edition, or c:\Program Files\AllegroGraphJEE32 for the licensed edition.</li>
  <li>Create a scratch directory for AllegroGraph to use for disk-based data storage. In this tutorial the directory is c:\tmp\scratch. If you elect to use a different location, the configuration and example files will have to be modified in the same way.</li>
  <li>
  Edit the <strong>agraph.cfg</strong> configuration file. You'll find it in the AllegroGraph installation directory. Set the following parameters to the indicated values. 
      <pre>:new-http-port 8080
:new-http-catalog ("c:/tmp/scratch")
:client-prolog t </pre>
  If you use a different port number, you will need to change the value of the AG_PORT variable at the top of tutorial_examples_40.java.
 It defaults to 8080. <br>
 <br>
 NOTE: On Windows Vista and Windows 7 systems, you must edit this file with elevated privileges. To do this, either start a Command Prompt with&nbsp; the context menu item &quot;Run as Administrator&quot; then edit the file using a text editor launched in that shell, or run your favorite editor with &quot;Run as Administrator&quot;. If you do not edit with elevated privileges, the file will look like it was saved successfully but the changes will not be seen by the service when it is started. This produces a &quot;cannot connect to server&quot; error message. 
  <li>To update AllegroGraph Server with recent patches, open a connection to the Internet. Run <strong>update.exe</strong>, which you will find the AllegroGraph installation directory. This automatically downloads and installs all current patches. </li>
  <li>On a Windows computer, the AllegroGraph Server runs as a Windows service. You have to restart this service to load the updates. Beginning at the Windows <strong>Start </strong>button, navigate this path: <br>
    <br>
  Start &gt; Settings &gt; Control Panel &gt; Administrative Tools &gt; Services. <br>
  <br>
  Locate the AllegroGraph Server service and select it. Click the <strong>Restart</strong> link to restart the service. </li>
  <li>This example used ActivePython 2.5 from ActiveState.com. Download and install the Windows installation file, 

 
  <a href="http://downloads.activestate.com/ActivePython/windows/2.5/ActivePython-2.5.2.2-win32-x86.msi">ActivePython-2.5.2.2-win32-x86.msi.</a> The default installation direction is C:\Python25.</li>
  <li>It is necessary to augment Python 2.5 with the CJSON package from python.cs.hu. Download and run the installation file, 

 
  <a href="http://python.cx.hu/python-cjson/python-cjson-1.0.3x6.win32-py2.5.exe">python-cjson-1.0.3x6.win32-py2.5.exe.</a> It will add files to the default Python directory structure.</li>
  <li>It is also necessary to augment Python 2.5 with the Pycurl package. Download and run the installation file, 

 
  <a href="http://pycurl.sourceforge.net/download/pycurl-ssl-7.18.2.win32-py2.5.exe">pycurl-ssl-7.18.2.win32-py2.5.exe.</a> It will add a small directory to your default Python directory structure. </li>
  <li>
    Link the Python software to the AllegroGraph Python API by setting a PYTHONPATH environment variable. For the free edition of AllegroGraph, the path value is:
      <pre>PYTHONPATH=C:\Program Files\AllegroGraphFJE40\python</pre>
For the licensed edition of AllegroGraph, the path value is:
      <pre>PYTHONPATH=C:\Program Files\AllegroGraphJEE40\python</pre>
In Windows XP, you can set an environment variable by 


 right-clicking on the <strong>My Computer</strong> icon, then navigate to Properties &gt; Advanced tab &gt; Environment Variables. Create a new variable showing the path to the AllegroGraph python subdirectory.<br>
 <br>
 <img src="environmentvariable.jpg" width="423" height="205"> <br>
  </li>
  <li>Start the ActivePython 2.5 PythonWin editor. Navigate this path:  <strong>Start</strong> button &gt; Programs &gt; ActiveState ActivePython 2.5 &gt;  PythonWin Editor. </li>
  <li>In the PythonWin editor, open the File menu, select Run, and browse to the location of the tutorial_examples_40.java file. It will be in the AllegroGraph\python subdirectory. Run this file. This loads and runs the Python tutorial examples.</li>
</ol>
<h2 id="PrerequisitesLinux">Prerequisites (Linux) &nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>The tutorial examples can be run on a Linux system, running AllegroGraph and Python on the same computer (&quot;localhost&quot;). The tutorial assumes that AllegroGraph and Python 2.5 have been installed and configured using this procedure:</p>
<ol>
  <li> There are two Linux versions of AllegroGraph: 32-bit (x86) and 64-bit (x86-64). This example uses the 64-bit version. AllegroGraph is distributed both as an RPM and a tar.gz file. This example uses the RPM file.&nbsp; <a href="http://www.franz.com/agraph/downloads/">Download the appropriate AllegroGraph Free Server Edition </a> as directed by <a href="mailto:support@franz.com">Franz customer support</a>. In this example, the file was agraph-4.0-1.x86_64.rpm. </li>
  <li>
    Use the Red Hat Package Manager (RPM) to install the AllegroGraph package.
     
<pre class="input"># rpm -i agraph-4.0-1.x86_64.rpm
</pre>
  </li>
  <li>
     Set up AllegroGraph as a service that runs automatically at startup.
     
       <pre class="input"># chkconfig --add agraph</pre>
  </li>
  <li>Start the AllegroGraph service.<br>
    <pre class="input"># service agraph start</pre>
  </li>
  <li> Edit the agraph.cfg configuration file. 


 You'll find it in the agraph-fje-4.0 subdirectory.&nbsp; The rpm's default <br>
&nbsp;&nbsp;&nbsp; location for this subdirectory is &quot;/usr/lib/agraph-fje-4.0&quot;.  Set the following parameters to the indicated values.
      <pre>       :new-http-port 8080
       :new-http-catalog ("/tmp/scratch")
       :client-prolog t</pre>
  </li>
  <li>You'll have to restart the AllegroGraph Server to force it to load the edited configuration file. <br>
    <pre class="input"># service agraph restart</pre>
  </li>
  <li>If Python is not pre-installed on your Linux system, you'll have to download and install it as a module. See the Python <a href="http://www.python.org/download/">download page.</a> </li>
  <li>AllegroGraph requires the Python cjson and pycurl libraries. 


 Please see your distributions documentation on how to install these libraries.&nbsp; On a redhat-based distribution you can use the following: <br>
    <pre class="input"># yum install python-cjson python-pycurl</pre>
    or 


 on a debian based system:<br>
    <pre class="input"># apt-get install python-cjson python-pycurl</pre>
  If your distribution does not offer these libraries then installation from source is recommended. </li>
  <li>To test the installation, navigate to the /agraph-fje-4.0/python/ directory and run the tutorial file.<br>
    <pre class="input"># python tutorial_examples_40.java</pre>
    The command window will fill with output from the example functions described below. 
  </li>
</ol> 
-->
<h2 id="Terminology">Terminology&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>We need to clarify some terminology before proceeding. </p>
<ul>
  <li>&quot;RDF&quot; is the <a href="http://www.w3.org/RDF/">Resource Description Framework</a> defined by the <a href="http://www.w3.org/">World Wide Web Consortium</a> (W3C). It provides a elegantly simple means for describing multi-faceted resource objects and for linking them into complex relationship graphs. AllegroGraph Server creates, searches, and manages such RDF graphs. </li>
  <li>A &quot;URI&quot; is a <a href="http://www.isi.edu/in-notes/rfc2396.txt">Uniform Resource Identifier</a>. It is label used to uniquely identify variosu types of entities in an RDF graph. A typical URI looks a lot like a web address: &lt;http:\\www.company.com\project\class#number&gt;. In spite of the resemblance, a URI is not a web address. It is simply a unique label. </li>
  <li>A &quot;triple&quot; is a data statement, a &quot;fact,&quot; stored in RDF format. It states that a  resource has an attribute with a value. It consists of three fields:</li>
  <ul>  <li>Subject: The first field contains the URI that uniquely identifies the resource that this triple describes. </li>
  <li>Predicate: The second field contains the URI identifying a property of this resource, such as its color or size, or a relationship between this resource and another one, such as parentage or ownership. </li>
  <li>Object: The third field is the value of the property. It could be a literal value, such as &quot;red,&quot; or the URI of a linked resource. </li>
  </ul>
  <li>A &quot;quad&quot; is a triple with an added &quot;context&quot; field, which is used to divide the repository into &quot;subgraphs.&quot; This context or subgraph is just a URI label that appears in the fourth field of related triples. </li>
  <li>A &quot;quint&quot; is a quad with a fifth field used for the &quot;tripleID.&quot; AllegroGraph Server implements all triples as quints behind the scenes. The fourth and fifth fields are often ignored, however, so we speak casually of &quot;triples,&quot; and sometimes of &quot;quads,&quot; when it would be more rigorous to call them all &quot;quints.&quot; </li>
  <li>A &quot;resource description&quot; is defined as a collection of triples that all have the same URI in the subject field. In other words, the triples all describe attributes of the same thing.</li>
  <li>A &quot;statement&quot; is a client-side Java object that describes a triple (quad, quint).&nbsp; </li>
</ul>
  <table width="809" border="0">
  <tr>
    <td width="378"><p>In the context of AllegroGraph Server: </p>
      <ul>
        <li>A &quot;catalog&quot; is a list of repositories owned by an AllegroGraph server.</li>
        <li>A &quot;repository&quot; is a collection of triples within a Catalog, stored and indexed on a hard disk.</li>
        <li>A &quot;context&quot; is a subgraph of the triples in a repository. </li>
        <li>If contexts are not in use, the triples are stored in the background (default) graph. </li>
      </ul>      </td>
    <td width="421"><img src="catalogrepositorycontext.jpg" width="397" height="400" align="right"></td>
  </tr>
</table>
  <p>&nbsp;</p>
  <h2 id="Creating a Repository">Creating a Repository (example1()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>The first task is to our AllegroGraph Server and open a repository. This task is implemented in<strong> example1()</strong> from<strong> TutorialExamples.java</strong>. </p>
<p>In <strong>example1()</strong> we build a chain of Java objects,  ending in a &quot;connection&quot; object that lets us manipulate triples in a specific repository. The overall process of generating the connection object follows 
this diagram:</p>
  <table width="809" border="0">
  <tr>
    <td width="378"><p>The example1() function opens (or creates) a repository by building a series of client-side objects, culminating in a &quot;connection&quot; object. The connection object will be passed to other methods in TutorialExamples.java. </p>
      <p>We will also make use of the repository's &quot;value factory.&quot; </p></td>
    <td width="421"><img src="createconnectionobject.jpg" width="679" height="356"></td>
  </tr>
</table>

<p>The example first connects to an AllegroGraph Server by providing the endpoint (host IP address and port number) of an already-launched AllegroGraph server. You'll also need a user name and password. This creates a client-side server object, which can access the AllegroGraph server's list of available catalogs through the <strong>listCatalogs()</strong> method:</p>
<pre class="input">public class TutorialExamples {
  static private final String SERVER_URL = &quot;http://localhost:8080&quot;;
  static private final String CATALOG_ID = &quot;scratch&quot;;
  static private final String USERNAME = &quot;user&quot;;
  static private final String PASSWORD = &quot;password&quot;;

    public static AGRepositoryConnection example1(boolean close) throws RepositoryException {        // Tests getting the repository up. <br>        println(&quot;Starting example example1().&quot;);<br>        AGServer server = new AGServer(SERVER_URL, USERNAME, PASSWORD);<br>        println(&quot;Available catalogs: &quot; + (server.listCatalogs()));</pre>
<p>This is the output so far:</p>
<pre class="output">Starting example example1().<br>Available catalogs: null</pre>
<p>In the next line of example1(), we use the server's <strong>getCatalog()</strong> method to create a client-side catalog object. This object has methods such as <strong>getCatalogName()</strong> and <strong>getAllRepositories()</strong> that we can use to investigate the catalogs on the AllegroGraph server. When we look inside the &quot;scratch&quot; catalog, we can see which repositories are available:</p>
<pre class="input">        AGCatalog catalog = server.getCatalog(CATALOG_ID);<br>        println(&quot;Available repositories in catalog &quot; + <br>                (catalog.getCatalogName()) + &quot;: &quot; + <br>                catalog.getAllRepositories());</pre>
<p>The corresponding output lists the available repositories.  (When you run the examples, you may see a different list of repositories.)</p>
<pre class="output">Available repositories in catalog scratch: null</pre>
<p>The next step is to create a client-side repository object representing the respository we wish to open, by calling the
<strong>getRepository()</strong> method of the catalog object. We have to provide the name of the desired repository (<strong>scratch</strong> in this case).</p>
<pre class="input">        AGRepository myRepository = catalog.createRepository(CATALOG_ID);<br>        myRepository.initialize();</pre>
<p>A new or renewed repository must be initialized, using the <strong>initialize()</strong> method of the repository object. If you try to initialize a respository twice you get a warning message in the Java window but no exception. </p>
<p>The goal of all this object-building has been to create a client-side connection object, whose methods let us manipulate the triples of the repository. The repository object's <strong>getConnection()</strong> method returns this connection object. The function <strong>closeBeforeExit()</strong> maintains a list of connection objects and automatically cleans them up when the client exits. </p>
<pre class="input">        AGRepositoryConnection conn = myRepository.getConnection();
		closeBeforeExit(conn);<br>        println(&quot;Got a connection.&quot;);<br>        conn.clear();  // remove previous triples, if any.<br>        println(&quot;Cleared the connection.&quot;);<br>        println(&quot;Repository &quot; + (myRepository.getRepositoryID()) +<br>                &quot; is up! It contains &quot; + (conn.size()) +<br>                &quot; statements.&quot;              <br>                );</pre>
 <p>The <strong>size()</strong> method of the connection object returns how many triples are present. In the example1() function, this number should always be zero because we &quot;renewed&quot; the repository. This is the output in the Java window: </p>
<pre class="output">   Repository scratch is up! It contains 0 statements.</pre>
<p>In its default mode, example1() closes the connection. It can optionally return the connection when called by another method, as will occur in several examples below. If you are done with the connection, closing it will free resources.</p>
<pre class="input">         if (close) {
             conn.close();
             myRepository.shutDown();
             return null;
        }
        return conn;<br>    }</pre>

<h2 id="Asserting and Retracting Triples">Asserting and Retracting Triples (example2()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>




<p>

In example example2(), we show how
to create resources describing two
people, Bob and Alice, by asserting individual triples into the respository. The example also retracts and replaces a triple.  Assertions and retractions to the triple store
are executed by 'add' and 'remove' methods belonging to the connection object, which we obtain by calling the example1() function (described above).
</p>
<p>Before asserting a triple, we have to generate the URI values for the subject, predicate and object fields. The Java API to AllegroGraph Server predefines a number of classes and predicates for the RDF, RDFS, XSD, and OWL ontologies.  RDF.TYPE is one of the predefined predicates we will use. </p>
<p>
The 'add' and 'remove' methods take an optional 'contexts' argument that
specifies one or more subgraphs that are the target of triple assertions
and retractions.  When the context is omitted, triples are asserted/retracted
to/from the background graph.  In the example below, facts about Alice and Bob
reside in the background graph.
</p>
<p>The example2() function begins by calling example1() to create the appropriate connection object, which is bound to the variable <strong>conn</strong>. We will also need the repository's &quot;value factory&quot; object, because it has many useful methods. If we have the connection object, we can retrieve the repository object, and then the value factory. We will need both object in order to proceed. </p>
<pre class="input">    public static AGRepositoryConnection example2(boolean close) throws RepositoryException {<br>        // Asserts some statements and counts them.<br>        AGRepositoryConnection conn = example1(false);<br>        AGValueFactory vf = conn.getRepository().getValueFactory();<br>        println(&quot;Starting example example2().&quot;);</pre>
 <p>The next step is to begin assembling the URIs we will need for the new triples. The valueFactory's <strong>createURI()</strong> method generates a URI from a string. These are the subject URIs identifying the resources &quot;Bob&quot; and &quot;Alice&quot;:</p>
 <pre class="input">        URI alice = vf.createURI(&quot;http://example.org/people/alice&quot;);<br>        URI bob = vf.createURI(&quot;http://example.org/people/bob&quot;);</pre>
 <p>Both Bob and Alice will have a &quot;name&quot; attribute. </p>
 <pre class="input">        URI name = vf.createURI(&quot;http://example.org/ontology/name&quot;);</pre>
 <p>The name attributes will contain literal values. We have to generate the Literal objects from strings: </p>
 <pre class="input">        Literal bobsName = vf.createLiteral(&quot;Bob&quot;);<br>        Literal alicesName = vf.createLiteral(&quot;Alice&quot;);</pre>
 <p>The next line prints out the number of triples currently in the repository. </p>
 <pre class="input">        println(&quot;Triple count before inserts: &quot; + <br>                (conn.size()));</pre>
<pre class="output">Triple count before inserts:  0
</pre>
<p>Now we assert four triples, two for Bob and two more for Alice, using the connection object's <strong>add()</strong> method. Note the use of RDF.TYPE, which is an attribute of the RDF object in 


 <a href="http://www.openrdf.org/doc/sesame2/api/org/openrdf/model/vocabulary/package-summary.html">org.openrdf.model.vocabulary</a>. This attribute is set the the URI of the rdf:type predicate, which is used to indicate the class of a resource. </p>
<pre class="input">        // Alice's name is &quot;Alice&quot;<br>        conn.add(alice, name, alicesName);<br>        // Alice is a person<br>        conn.add(alice, RDF.TYPE, person);<br>        //Bob's name is &quot;Bob&quot;<br>        conn.add(bob, name, bobsName);<br>        //Bob is a person, too. <br>        conn.add(bob, RDF.TYPE, person);</pre>
<p>After the assertions, we count triples again (there should be four) and print out the triples for inspection. The &quot;null&quot; arguments to the getStatements() method say that we don't want to restrict what values may be present in the subject, predicate, object or context positions. Just print out all the triples. </p>
<pre class="input">        println(&quot;Triple count after inserts: &quot; + <br>                (conn.size()));<br>        RepositoryResult&lt;Statement&gt; result = conn.getStatements(null, null, null, false);<br>        while (result.hasNext()) {<br>            Statement st = result.next();<br>            println(st);<br>        }</pre>
<p>This is the output at this point. We see four triples, two about Alice and two about Bob:</p>
<pre class="output">Triple count after inserts: 4
(http://example.org/people/alice, http://example.org/ontology/name, "Alice") [null]
(http://example.org/people/alice, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/ontology/Person) [null]
(http://example.org/people/bob, http://example.org/ontology/name, "Bob") [null]
(http://example.org/people/bob, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/ontology/Person) [null]
</pre>
<p>We see two resources of type &quot;person,&quot; each with a literal name. The<strong> [null] </strong>value at the end of each triple indicates that the triple is resident in the default background graph, rather than being assigned to a specific named subgraph. </p>
<p>The next step is to demonstrate how to remove a triple. Use the <strong>remove()</strong> method of the connection object, and supply a triple pattern that matches the target triple. In this case we want to remove Bob's name triple from the repository. Then we'll count the triples again to verify that there are only three remaining. Finally, we re-assert Bob's name so we can use it in subsequent examples, and we'll return the connection object.</p>
<pre class="input">        conn.remove(bob, name, bobsName);<br>        println(&quot;Removed one triple.&quot;);<br>        println(&quot;Triple count after deletion: &quot; + <br>                (conn.size()));</pre>
 
 <pre class="output">Removed one triple.<br>Triple count after deletion: 3</pre>
 <p>example2() ends with a condition that either closes the connection or passes it on to the next method for reuse. </p>
 <h2 id="A SPARQL Query">A SPARQL Query (example3()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>SPARQL stands for  the &quot;<a href="http://www.w3.org/TR/rdf-sparql-query/">SPARQL Protocol and RDF Query Language</a>,&quot; a recommendation of the <a href="http://www.w3.org/">World Wide Web Consortium (W3C)</a>. SPARQL is a query language for retrieving RDF triples. </p>
 <p>Our next example illustrates how to evaluate a SPARQL query. This is the simplest query, the one that returns all triples. Note that example3() continues with the four triples created in example2(). </p>
 <pre class="input">    public static void example3() throws Exception {<br>        AGRepositoryConnection conn = example2(false);<br>        try {<br>            String queryString = &quot;SELECT ?s ?p ?o  WHERE {?s ?p ?o .}&quot;;</pre>
<p>The SELECT clause returns the variables ?s, ?p and ?o. The variables are bound to the subject, predicate and object values of each triple that satisfies the WHERE clause. In this case the WHERE clause is unconstrained. The dot (.) in the fourth position signifies the end of the pattern. </p>
<p>The connection object's <strong>prepareTupleQuery()</strong> method
  creates a query object that can be evaluated one or more times. (A &quot;tuple&quot; is an ordered sequence of data elements.)   The results are returned in a TupleQueryResult iterator that gives access to a sequence of bindingSets.</p>
<pre class="input">            TupleQuery tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString);<br>            TupleQueryResult result = tupleQuery.evaluate();</pre>
<p>Below we illustrate one (rather heavyweight) method for extracting the values
  from a binding set, indexed by the name of the corresponding column variable
in the SELECT clause.</p>
<pre class="input">            try {<br>                while (result.hasNext()) {<br>                    BindingSet bindingSet = result.next();<br>                    Value s = bindingSet.getValue(&quot;s&quot;);<br>                    Value p = bindingSet.getValue(&quot;p&quot;);<br>                    Value o = bindingSet.getValue(&quot;o&quot;);<br>                    System.out.format(&quot;%s %s %s\n&quot;, s, p, o);<br>                }</pre>
<pre class="output">
http://example.org/people/alice http://www.w3.org/1999/02/22-rdf-syntax-ns#type http://example.org/ontology/Person
http://example.org/people/alice http://example.org/ontology/name "Alice"
http://example.org/people/bob http://www.w3.org/1999/02/22-rdf-syntax-ns#type http://example.org/ontology/Person
http://example.org/people/bob http://example.org/ontology/name "Bob"
</pre>
<p>The RepositoryConnection class is designed to be created for the duration of a sequence of updates and queries, and then closed. In practice, many AllegroGraph applications keep a connection open indefinitely. However, best practice dictates that the connection should be closed, as illustrated below. The same hygiene applies to the iterators that generate binding sets.</p>
<pre class="input">
        finally:
            result.close();
    finally:
        conn.close();</pre>
<h2 id="Statement Matching">Statement Matching (example4()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>

<p>
The getStatements() method of the connection object provides a simple way to perform unsophisticated queries. This method lets you enter a mix of required values and wildcards, and retrieve all matching triples. (If you need to perform sophisticated tests and comparisons you should use the SPARQL query instead.)</p>
<p>
Below, we illustrate two kinds of getStatement calls.  The first mimics
traditional Sesame syntax, and returns a Statement object at each iteration. This is the <strong>example4()</strong> function of TutorialExamples.java. It begins by calling example2() to create a connection object and populate the agraph_test repository with four triples describing Bob and Alice. </p>
<pre class="input">    public static void example4() throws RepositoryException {<br>        RepositoryConnection conn = example2(false);
		closeBeforeExit(conn);</pre>
<p>We're going to search for triples that mention Alice, so we have to create an &quot;Alice&quot; URI to use in the search pattern. This requires us to build the bridge from the connection back to the valueFactory:</p>
<pre class="input">        Repository myRepository = conn.getRepository();<br>        URI alice = myRepository.getValueFactory().createURI(&quot;http://example.org/people/alice&quot;);</pre>
<p> Now we search for triples with Alice's URI in the subject position.  The &quot;null&quot; values are wildcards for the predicate and object positions of the triple. </p>
<pre class="input">        RepositoryResult&lt;Statement&gt; statements = conn.getStatements(alice, null, null, false);</pre>
<p>The getStatements() method returns a repositoryResult object (bound to the variable &quot;statements&quot; in this case). This object can be iterated over, exposing one result statement at a time. It is sometimes desirable to screen the results for duplicates, using the enableDuplicateFilter() method. Note, however, that duplicate filtering can be expensive. Our example does not contain any duplicates, but it is possible for them to occur. </p>
<pre class="input">        try {<br>            statements.enableDuplicateFilter();<br>            while (statements.hasNext()) {<br>                println(statements.next());<br>            }</pre>
<p>This prints out the two matching triples for &quot;Alice.&quot; </p>
<pre class="output">(http://example.org/people/alice, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/ontology/Person) [null]<br>(http://example.org/people/alice, http://example.org/ontology/name, &quot;Alice&quot;) [null]</pre>
<p>At this point it is good form to close the respositoryResponse object because it occupies memory and is rarely reused in most programs. We can also close the connection and shut down the repository. </p>
<pre class="input">        } finally {<br>            statements.close();<br>        }
        conn.close();<br>        myRepository.shutDown();<br>    }</pre>
<p>&nbsp;</p>

<h2 id="Literal Values">Literal Values (example5())&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>The next example, <strong>example5()</strong>, illustrates some variations on what we have seen so far.  The example creates and asserts typed literal values, including  language-specific literals.</p>
<p>First, example5() obtains a connection object from example1(). From the connection we can determine the respository and the repository's valueFactory. Then it clears the repository of all existing triples. </p>
<pre class="input">    public static void example5() throws Exception {<br>        RepositoryConnection conn = example2(false);<br>        Repository myRepository = conn.getRepository();<br>        ValueFactory f = myRepository.getValueFactory();<br>        conn.clear();</pre>
<p>For sake of coding efficiency, it is good practice to create variables for namespace strings. We'll use this namespace again and again in the following lines. </p>
<pre class="input">        String exns = &quot;http://example.org/people/&quot;;</pre>
<p>The example creates new resources describing Alice and Ted. Apparently Bob was on vacation. These are URIs to use in the subject field of the triples. </p>
<pre class="input">        URI alice = f.createURI(&quot;http://example.org/people/alice&quot;);<br>        URI ted = f.createURI(exns, &quot;Ted&quot;);</pre>
<p>These are the URIs of the four predicates used in the example: age, weight, favoriteColor, and birthdate. </p>
<pre class="input">        URI age = f.createURI(exns, &quot;age&quot;);<br>        URI weight = f.createURI(exns, &quot;weight&quot;);    <br>        URI favoriteColor = f.createURI(exns, &quot;favoriteColor&quot;);<br>        URI birthdate = f.createURI(exns, &quot;birthdate&quot;);</pre>
<p>Favorite colors, declared in English (default) and French. </p>
<pre class="input">        Literal red = f.createLiteral(&quot;Red&quot;);<br>        Literal rouge = f.createLiteral(&quot;Rouge&quot;, &quot;fr&quot;);</pre>
<p>Age values, declared as INT, LONG, and untyped: </p>
<pre class="input">        Literal fortyTwoInt = f.createLiteral(&quot;42&quot;, XMLSchema.INT);<br>        Literal fortyTwoLong = f.createLiteral(&quot;42&quot;, XMLSchema.LONG);    <br>        Literal fortyTwoUntyped = f.createLiteral(&quot;42&quot;);</pre>
<p>Birth date values, declared as DATE and DATETIME types. </p>
<pre class="input">        Literal date = f.createLiteral(&quot;1984-12-06&quot;, XMLSchema.DATE);     <br>        Literal time = f.createLiteral(&quot;1984-12-06T09:00:00&quot;, XMLSchema.DATETIME);         </pre>
<p>Weights, written as floats, but one untyped and the other declared to be a FLOAT. </p>
<pre class="input">        Literal weightUntyped = f.createLiteral(&quot;120.5&quot;);<br>        Literal weightFloat = f.createLiteral(&quot;120.5&quot;, XMLSchema.FLOAT);</pre>
 <p>The connection object's createStatement() method assembles the elements of a triple, but does not yet add them to the repository. Here are Alice's and Ted's ages assembled into statements. (We gave Ted two age triples because Bob was on vacation. The triples have the same value cast into different types.) </p>
 <pre class="input">        Statement stmt1 = f.createStatement(alice, age, fortyTwoInt);<br>        Statement stmt2 = f.createStatement(ted, age, fortyTwoLong);    <br>        Statement stmt3 = f.createStatement(ted, age, fortyTwoUntyped);</pre>
<p>The Java API to AllegroGraph Server uses the <strong>add()</strong> method for asserting triples into the repository. It can create triples from statements, or from URIs and literal values, as shown here. </p>
<pre class="input">        conn.add(stmt1);<br>        conn.add(stmt2);<br>        conn.add(stmt3);<br>        conn.add(alice, weight, weightFloat);<br>        conn.add(ted, weight, weightUntyped);<br>        conn.add(alice, favoriteColor, red);<br>        conn.add(ted, favoriteColor, rouge);<br>        conn.add(alice, birthdate, date);<br>        conn.add(ted, birthdate, time);    </pre>
<p>The RDF/SPARQL spec is very conservative when matching various combinations of literal values. The match and query statements below illustrate how some of these combinations perform. Note that this loop uses the getStatements() method to retrieve triples. We'll do SPARQL queries in a minute. </p>
<pre class="input">        for (Literal obj : new Literal[] {null, fortyTwoInt, fortyTwoUntyped, fortyTwoLong, weightFloat, weightUntyped,<br>                    red, rouge}) {<br>            println( &quot;\nRetrieve triples matching &quot; + obj + &quot;.&quot;);<br>            RepositoryResult&lt;Statement&gt; statements = conn.getStatements(null, null, obj, false);<br>            try {<br>                while (statements.hasNext()) {<br>                    println(statements.next());<br>                }<br>            } finally {<br>                statements.close();<br>            }<br>        }</pre>
<p>The getStatements() method looks for all triples that have a specific value in the object position. It doesn't care which resource or which predicate are in play. </p>
<p>These are the results of the tests in this loop. The first iteration uses &quot;null&quot; as the object value. This is a wildcard value, and matches all the triples in the repository: </p>
<pre class="output">Retrieve triples matching null.<br>(http://example.org/people/alice, http://example.org/people/age, &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#int&gt;) [null]<br>(http://example.org/people/ted, http://example.org/people/age, &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#long&gt;) [null]<br>(http://example.org/people/ted, http://example.org/people/age, &quot;42&quot;) [null]<br>(http://example.org/people/alice, http://example.org/people/weight, &quot;120.5&quot;) [null]<br>(http://example.org/people/ted, http://example.org/people/weight, &quot;120.5&quot;^^&lt;http://www.w3.org/2001/XMLSchema#float&gt;) [null]<br>(http://example.org/people/alice, http://example.org/people/favoriteColor, &quot;Red&quot;) [null]<br>(http://example.org/people/ted, http://example.org/people/favoriteColor, &quot;Rouge&quot;@fr) [null]<br>(http://example.org/people/alice, http://example.org/people/birthdate, &quot;1984-12-06&quot;^^&lt;http://www.w3.org/2001/XMLSchema#date&gt;) [null]<br>(http://example.org/people/ted, http://example.org/people/birthdate, &quot;1984-12-06T09:00:00&quot;^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt;) [null]</pre>
<p>What triples match &quot;42&quot; declared as an INT? [fortyTwoInt]</p>
<pre class="output">Retrieve triples matching &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#int&gt;.<br>(http://example.org/people/alice, http://example.org/people/age, &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#int&gt;) [null]</pre>
<p>What triples match &quot;42&quot; declared as an LONG? [fortyTwoLong]</p>
<pre class="output">Retrieve triples matching &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#long&gt;.<br>(http://example.org/people/ted, http://example.org/people/age, &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#long&gt;) [null]</pre>
<p>What triples match &quot;42&quot; untyped? [fortyTwoUntyped] </p>
<pre class="output">Retrieve triples matching &quot;42&quot;.<br>(http://example.org/people/ted, http://example.org/people/age, &quot;42&quot;) [null]</pre>
<p>What triples match &quot;120.5&quot; declared as a FLOAT? [weightFloat]</p>
<pre class="output">Retrieve triples matching &quot;120.5&quot;^^&lt;http://www.w3.org/2001/XMLSchema#float&gt;.<br>(http://example.org/people/alice, http://example.org/people/weight, &quot;120.5&quot;^^&lt;http://www.w3.org/2001/XMLSchema#float&gt;) [null]</pre>
<p>What triples match &quot;120.5&quot; untyped? [weightUntyped]</p>
<pre class="output"></p>Retrieve triples matching &quot;120.5&quot;.<br>(http://example.org/people/ted, http://example.org/people/weight, &quot;120.5&quot;) [null]</pre>
<p>What triples match &quot;Red&quot; as a simple string? [Red] </p>
<pre class="output"></p>Retrieve triples matching &quot;Red&quot;.<br>(http://example.org/people/alice, http://example.org/people/favoriteColor, &quot;Red&quot;) [null]</pre>
<p>What triples match &quot;Rouge&quot; declared as a French string? [Rouge] </p>
<pre class="output"></p>Retrieve triples matching &quot;Rouge&quot;@fr.<br>(http://example.org/people/ted, http://example.org/people/favoriteColor, &quot;Rouge&quot;@fr) [null]</pre>
<p>This loop builds and evaluates a SPARQL query instead of using getStatements(). It also shows examples of putting coded values into the search criteria without creating Literal objects as an intermediate step. It also shows how to use a BindingSet instead of a RepositoryResult object, and how to extract individual subject, predicate and object values from each returned triple. </p>
<pre class="input"> for (String obj : new String[]{&quot;42&quot;, &quot;\&quot;42\&quot;&quot;, &quot;20.5&quot;, &quot;\&quot;20.5\&quot;&quot;, &quot;\&quot;20.5\&quot;^^xsd:float&quot;,<br>                                       &quot;\&quot;Rouge\&quot;@fr&quot;, &quot;\&quot;Rouge\&quot;&quot;, &quot;\&quot;1984-12-06\&quot;^^xsd:date&quot;}) {<br>            println( &quot;\nQuery triples matching &quot; + obj + &quot;.&quot;);<br>            String queryString = &quot;PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; SELECT ?s ?p ?o WHERE {?s ?p ?o . filter (?o = &quot; + obj + &quot;)}&quot;;<br>            TupleQuery tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString);<br>            TupleQueryResult result = tupleQuery.evaluate();<br>            try {<br>                while (result.hasNext()) {<br>                    BindingSet bindingSet = result.next();<br>                    Value s = bindingSet.getValue(&quot;s&quot;);<br>                    Value p = bindingSet.getValue(&quot;p&quot;);<br>                    Value o = bindingSet.getValue(&quot;o&quot;);<br>                    println(&quot;  &quot; + s + &quot; &quot; + p + &quot; &quot; + o);<br>                }</pre>
<p>What triples match &quot;42&quot; (which is an int). We get both ints and longs. 
<pre class="output">Query triples matching 42.<br>  http://example.org/people/alice http://example.org/people/age &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#int&gt;<br>  http://example.org/people/ted http://example.org/people/age &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#long&gt;</pre>
<p>What triples match &quot;\&quot;42\&quot;&quot; (which is a string?) </p>
<pre class="output">Query triples matching &quot;42&quot;.<br>  http://example.org/people/ted http://example.org/people/age &quot;42&quot;</pre>
<p>What triples match &quot;120.5&quot; (a float)? </p>
<pre class="output">Query triples matching 120.5.<br>  http://example.org/people/alice http://example.org/people/weight &quot;120.5&quot;^^&lt;http://www.w3.org/2001/XMLSchema#float&gt;</pre>
<p>What triples match &quot;\&quot;120.5\&quot;&quot; (a string)? </p>
<pre class="output">Query triples matching &quot;120.5&quot;.<br>  http://example.org/people/ted http://example.org/people/weight &quot;120.5&quot;</pre>
<p>What triples match&quot;\&quot;120.5\&quot;^^xsd:float&quot; (a float)? </p>
<pre class="output">Query triples matching &quot;120.5&quot;^^xsd:float.<br>  http://example.org/people/alice http://example.org/people/weight &quot;120.5&quot;^^&lt;http://www.w3.org/2001/XMLSchema#float&gt;</pre>
<p>What triples match &quot;\&quot;Rouge\&quot;@fr&quot; (a French string)? </p>
<pre class="output">Query triples matching &quot;Rouge&quot;@fr.<br>  http://example.org/people/ted http://example.org/people/favoriteColor &quot;Rouge&quot;@fr</pre>
<p>What triples match &quot;Rouge&quot; (a string)? </p>
<pre class="output">Query triples matching &quot;Rouge&quot;. 
[No matches. General string fails to match French string.]</p></pre>
<p>In the following example, we use getStatements() to match a DATE object. We have used a DATE literal in the object position of the triple pattern: </p> 
<pre class="input">            println(&quot;Retrieve triples matching DATE object.&quot;);<br>            RepositoryResult&lt;Statement&gt; statements = conn.getStatements(null, null, date, false);<br>            try {<br>                while (statements.hasNext()) {<br>                    println(statements.next());<br>                }<br>            } finally {<br>                statements.close();<br>            }</pre> 
<pre class="output">Retrieve triples matching DATE object.<br>(http://example.org/people/alice, http://example.org/people/birthdate, &quot;1984-12-06&quot;^^&lt;http://www.w3.org/2001/XMLSchema#date&gt;) [null]</pre>
<p>Note the string representation of the DATE object in the following query.  </p>
<pre class="input">            RepositoryResult&lt;Statement&gt; statements = conn.getStatements(null, null,<br>                    f.createLiteral(&quot;\&quot;1984-12-06\&quot;^^&lt;http://www.w3.org/2001/XMLSchema#date&gt;&quot;), false);</pre>
<pre class="output">Match triples having specific DATE value.<br>(&lt;http://example.org/people/alice&gt;, &lt;http://example.org/people/birthdate&gt;, &quot;1984-12-06&quot;^^&lt;http://www.w3.org/2001/XMLSchema#date&gt;)
</pre>
<p>Let's try the same experiment with DATETIME:</p>
<pre class="input">           RepositoryResult&lt;Statement&gt; statements = conn.getStatements(null, null, time, false);</pre> 
<pre class="output">Retrieve triples matching DATETIME object.<br>(http://example.org/people/ted, http://example.org/people/birthdate, &quot;1984-12-06T09:00:00&quot;^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt;) [null]</pre>



<p>And a DATETIME match without using a literal value object:</p>
<pre class="input">           RepositoryResult&lt;Statement&gt; statements = conn.getStatements(null, null,<br>                    f.createLiteral(&quot;\&quot;1984-12-06T09:00:00\&quot;^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt;&quot;), false);</pre>
<pre class="output">Retrieve triples matching DATETIME object.<br>(http://example.org/people/ted, http://example.org/people/birthdate, &quot;1984-12-06T09:00:00&quot;^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt;) [null]</pre>
<h2 id="Importing Triples">Importing Triples (example6() and example7()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>
The Java API client can load triples in either RDF/XML format or  NTriples format.  The example below calls the connection object's <strong>add()</strong> method to load 
an NTriples file, and <strong>addFile()</strong> to load  an RDF/XML file. Both methods work, but the best practice is to use addFile(). </p>
<table width="769" border="2px" cellpadding="4px" style="border-collapse:collapse; border-color:#0000FF;">
  <tr>
    <td width="928"><strong>Note:</strong> If you get a &quot;file not found&quot; error while running this example, it means that Java is looking in the wrong directory for the data files to load. The usual explanation is that you have moved the TutorialExamples.java file to an unexpected directory. You can clear the issue by putting the data files in the same directory as TutorialExamples.java. </td>
  </tr>
</table>
<p>&nbsp;</p>
<p>The RDF/XML file contains a short list of v-cards (virtual business cards), like this one:</p>
<pre>  &lt;rdf:Description rdf:about=&quot;http://somewhere/JohnSmith/&quot;&gt;<br>    &lt;vCard:FN&gt;John Smith&lt;/vCard:FN&gt;<br>    &lt;vCard:N rdf:parseType=&quot;Resource&quot;&gt;<br>	    &lt;vCard:Family&gt;Smith&lt;/vCard:Family&gt;<br>	    &lt;vCard:Given&gt;John&lt;/vCard:Given&gt;<br>    &lt;/vCard:N&gt;<br>  &lt;/rdf:Description&gt; </pre>
<p>The NTriples file contains a graph of resources describing the Kennedy family, the places where they were each born, their colleges, and their professions. A typical entry from that file looks like this:</p>
<pre>&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#first-name&gt; &quot;Joseph&quot; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#middle-initial&gt; &quot;Patrick&quot; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#last-name&gt; &quot;Kennedy&quot; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#suffix&gt; &quot;none&quot; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#alma-mater&gt; &lt;http://www.franz.com/simple#Harvard&gt; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#birth-year&gt; &quot;1888&quot; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#death-year&gt; &quot;1969&quot; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#sex&gt; &lt;http://www.franz.com/simple#male&gt; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#spouse&gt; &lt;http://www.franz.com/simple#person2&gt; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#has-child&gt; &lt;http://www.franz.com/simple#person3&gt; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#profession&gt; &lt;http://www.franz.com/simple#banker&gt; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.franz.com/simple#birth-place&gt; &lt;http://www.franz.com/simple#place5&gt; . 
&lt;http://www.franz.com/simple#person1&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;http://www.franz.com/simple#person&gt; . </pre>

<p>Note that AllegroGraph can segregate triples into contexts (subgraphs) by treating them as quads, but the NTriples and RDF/XML formats can not include context information. They deal with triples only, so there is no place to store a fourth field in those formats. In the case of the add() call, we have omitted the context
  argument so the triples are loaded the default background graph (sometimes called the &quot;null context<em>.</em>&quot;) </p>
<p>The
  addFile() call includes an explicit context setting, so the fourth argument of
  each vcard triple will be the context named "/tutorial/vc_db_1_rdf".  </p>
<p>The connection size() method takes an optional context argument.  With no
    argument, it returns the total number of triples in the repository.  Below, it returns the number
    '16' for the named subgraph, and the number '28' for the null context
    (None) argument. </p>
<p>The example6() function of TutorialExamples.java creates a <a href="#Transaction">dedicated session</a> connection to AllegroGraph, using methods you have seen before, plus the repositoryConnection object's <strong>openSession()</strong> method: </p>
<pre class="input">    public static AGRepositoryConnection example6() throws Exception {<br>        AGServer server = new AGServer(SERVER_URL, USERNAME, PASSWORD);<br>        AGCatalog catalog = server.getCatalog(CATALOG_ID);<br>        AGRepository myRepository = catalog.createRepository(REPOSITORY_ID);<br>        myRepository.initialize();<br>        AGRepositoryConnection conn = myRepository.getConnection();<br>        closeBeforeExit(conn);<br>        conn.clear();<br>        conn.setAutoCommit(false);  // dedicated session<br>        ValueFactory f = myRepository.getValueFactory();</pre>
<p>The dedicated session is not immediately pertinent to the examples in this section, but will become important in later examples that reuse this connection to demonstrate <a href="#Prolog Rule Queries">Prolog Rules</a> and <a href="#Social Network Analysis">Social Network Analysis</a>. </p>
<p>The variables path1 and path2 are bound to the RDF/XML and NTriples files, respectively. You may have to redefine these paths depending on your platform and how you have set up the project. The data files are in the same directory as TutorialExamples.java.</p>
<pre class="input">        String path1 = &quot;src/vc-db-1.rdf&quot;;    <br>        String path2 = &quot;src/kennedy.ntriples&quot;;   </pre>
<p>Both examples need a base URI as one of the required arguments to the asserting methods: </p>
<pre class="input">        String baseURI = &quot;http://example.org/example/local&quot;;</pre>
<p>The NTriples about the vcards will be added to a specific context, so naturally we need a URI to identify that context. </p>
<pre class="input">        URI context = f.createURI(&quot;http://example.org#vcards&quot;);</pre>
<p>In the next step we use addFile() to load the vcard triples into the #vcards context: </p>
<pre class="input">        conn.add(new File(path1), baseURI, RDFFormat.RDFXML, context);</pre>
<p>Then we use add() to load the Kennedy family tree into the null context: </p>
<pre class="input">        conn.add(new File(path2), baseURI, RDFFormat.NTRIPLES);</pre>
<p>Now we'll ask AllegroGraph to report on how many triples it sees in the null context and in the #vcards context: </p>
<pre class="input">        println(&quot;After loading, repository contains &quot; + conn.size(context) +<br>                &quot; vcard triples in context '&quot; + context + &quot;'\n    and   &quot; +<br>                conn.size((Resource)null) + &quot; kennedy triples in context 'null'.&quot;);</pre>
<p>The output of this report was:</p>
<pre class="output">After loading, repository contains 16 vcard triples in context 'http://example.org#vcards'<br>    and   1214 kennedy triples in context 'null'.</pre>
<p><strong>example7()</strong> borrows the same triples we loaded in example6(), above, and runs two unconstrained retrievals. The first uses getStatement, and prints out the subject URI and context of each triple. </p>
<pre class="input">    public static void example7() throws Exception {<br>        RepositoryConnection conn = example6(false);<br>        println(&quot;\nMatch all and print subjects and contexts&quot;);<br>        RepositoryResult&lt;Statement&gt; result = conn.getStatements(null, null, null, false);<br>        for (int i = 0; i &lt; 25 &amp;&amp; result.hasNext(); i++) {<br>            Statement stmt = result.next();<br>            println(stmt.getSubject() + &quot;  &quot; + stmt.getContext());<br>        }<br>        result.close();</pre>
<p>This loop prints out a mix of triples from the null context and from the #vcards context. In this case the output contained the 16 v-card triples plus another nine from the Kennedy data. We set a limit of 25 triples on the output because the Kennedy dataset contains over a thousand triples. </p>
<p>The following loop, however, does not produce the same results. This is a SPARQL query that should match all available triples, printing out the subject and context of each triple: </p>
<pre class="input">        println(&quot;\nSame thing with SPARQL query (can't retrieve triples in the null context)&quot;);<br>        String queryString = &quot;SELECT ?s ?c WHERE {graph ?c {?s ?p ?o .} }&quot;;<br>        TupleQuery tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString);<br>        TupleQueryResult qresult = tupleQuery.evaluate();       <br>        while (qresult.hasNext()) {<br>            BindingSet bindingSet = qresult.next();<br>            println(bindingSet.getBinding(&quot;s&quot;) + &quot;  &quot; + bindingSet.getBinding(&quot;c&quot;));<br>        }<br>        qresult.close();<br>        conn.close();</pre>
<p>In this case, the loop prints out only the sixteen v-card triples from the #vcards context. The SPARQL query is not able to access the null context when a named context is also present. </p>
<h2 id="Exporting Triples">Exporting Triples (example8() and example9()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>The next examples show how to write triples out to a file in either NTriples format or RDF/XML format. The output of either format may be optionally redirected to standard output (the Java command window) for inspection.</p>
<p>Example example8() begins by obtaining a connection object from example6(). This means the repository contains v-card triples in the <strong>#vcards</strong> context, and Kennedy family tree triples in the<strong> null </strong>context. </p>
<pre class="input">    public static void example8() throws Exception {<br>        RepositoryConnection conn = example6(false);<br>        Repository myRepository = conn.getRepository();</pre>
<p>In this example, we'll export the triples in the #vcards context. </p>
<pre class="input">        URI context = myRepository.getValueFactory().createURI(&quot;http://example.org#vcards&quot;);</pre>
<p>To write triples in
NTriples format, call <strong>NTriplesWriter()</strong>. You have to a give it an output stream, which could be either a file path or standard output. The code below gives you the choice of writing to a file or to the interaction window. </p>
<pre class="input">        String outputFile = &quot;/tmp/temp.nt&quot;;<br>//        outputFile = null;<br>        if (outputFile == null) {<br>            println(&quot;\nWriting n-triples to Standard Out instead of to a file&quot;);<br>        } else {<br>            println(&quot;\nWriting n-triples to: &quot; + outputFile);<br>        }<br>        OutputStream output = (outputFile != null) ? new FileOutputStream(outputFile) : System.out;<br>        NTriplesWriter ntriplesWriter = new NTriplesWriter(output);<br>        conn.export(ntriplesWriter, context);</pre>
<p>To write triples in RDF/XML format, call <strong>RDFXMLWriter()</strong>. </p>
<pre class="input">        String outputFile2 = &quot;/tmp/temp.rdf&quot;;<br>        outputFile2 = null;<br>        if (outputFile2 == null) {<br>            println(&quot;\nWriting RDF to Standard Out instead of to a file&quot;);<br>        } else {<br>            println(&quot;\nWriting RDF to: &quot; + outputFile2);<br>        }<br>        output = (outputFile2 != null) ? new FileOutputStream(outputFile2) : System.out;<br>        RDFXMLWriter rdfxmlfWriter = new RDFXMLWriter(output);<br>        conn.export(rdfxmlfWriter, context);<br>        output.write('\n');<br>        conn.close();</pre>
<p>
The <strong>export()</strong> method writes
  out all triples in one or more contexts.  This provides a convenient means for making
  local backups of sections of your RDF store.  If two or more contexts are specified,
  then triples from all of those contexts will be written to<em> the same file</em>.  Since the
triples are "mixed together" in the file, the context information is not recoverable. If the context argument is omitted, all triples in the store are written out, and again all context information is lost. </p>
<p>Finally, if the objective is to write out a filtered set of triples,
  the <strong>exportStatements()</strong> method can be used.  The example below (from<strong> example9()</strong>) writes
  out all RDF:TYPE declaration triples to standard output. </p>
<pre class="input">        conn.exportStatements(null, RDF.TYPE, null, false, new RDFXMLWriter(System.out));</pre>

<h2 id="Datasets and Contexts">Datasets and Contexts (example10()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>
We have already seen contexts at work when loading and saving files.  In example10() we provide more realistic examples of contexts, and we introduce the dataset object. A dataset is a list of contexts that should all be searched simultaneously. </p>
<p>To set up the example, we create six statements, and add two
  of each to three different contexts: context1, context2, and the null context. The process of setting up the six statements follows the same pattern as we used in the previous examples: </p>
<pre class="input">        RepositoryConnection conn = example1(false);<br>        Repository myRepository = conn.getRepository();<br>        ValueFactory f = myRepository.getValueFactory();<br>        String exns = &quot;http://example.org/people/&quot;;<br>        URI alice = f.createURI(exns, &quot;alice&quot;);<br>        URI bob = f.createURI(exns, &quot;bob&quot;);<br>        URI ted = f.createURI(exns, &quot;ted&quot;);        <br>        URI person = f.createURI(&quot;http://example.org/ontology/Person&quot;);<br>        URI name = f.createURI(&quot;http://example.org/ontology/name&quot;);<br>        Literal alicesName = f.createLiteral(&quot;Alice&quot;);<br>        Literal bobsName = f.createLiteral(&quot;Bob&quot;);<br>        Literal tedsName = f.createLiteral(&quot;Ted&quot;);        <br>        URI context1 = f.createURI(exns, &quot;cxt1&quot;);      <br>        URI context2 = f.createURI(exns, &quot;cxt2&quot;);         <br>        conn.add(alice, RDF.TYPE, person, context1);<br>        conn.add(alice, name, alicesName, context1);<br>        conn.add(bob, RDF.TYPE, person, context2);<br>        conn.add(bob, name, bobsName, context2);<br>        conn.add(ted, RDF.TYPE, person);<br>        conn.add(ted, name, tedsName);</pre>
<p>The first test uses getStatements() to return all triples in all contexts (context1, context2, and null). </p>
<pre class="input">        RepositoryResult&lt;Statement&gt; statements = conn.getStatements(null, null, null, false);<br>        println(&quot;All triples in all contexts:&quot;);        <br>        while (statements.hasNext()) {<br>            println(statements.next());            <br>        }</pre>
<p>The output of this loop is shown below. The context URIs are in the fourth position. Triples from the null context have [null] in the fourth position. </p>
<pre class="output">All triples in all contexts:<br>(http://example.org/people/alice, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/ontology/Person) [http://example.org/people/cxt1]<br>(http://example.org/people/alice, http://example.org/ontology/name, &quot;Alice&quot;) [http://example.org/people/cxt1]<br>(http://example.org/people/bob, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/ontology/Person) [http://example.org/people/cxt2]<br>(http://example.org/people/bob, http://example.org/ontology/name, &quot;Bob&quot;) [http://example.org/people/cxt2]<br>(http://example.org/people/ted, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/ontology/Person) [null]<br>(http://example.org/people/ted, http://example.org/ontology/name, &quot;Ted&quot;) [null]</pre>
<p>The next match explicitly lists 'context1' and 'context2' as the only contexts to participate in the match. It returns four statements. </p>
<pre class="input">        statements = conn.getStatements(null, null, null, false, context1, context2);<br>        println(&quot;\nTriples in contexts 1 or 2:&quot;);        <br>        while (statements.hasNext()) {<br>            println(statements.next());<br>        }</pre>
<p>The output of this loop shows that the triples in the null context have been excluded. </p>
<pre class="output">Triples in contexts 1 or 2:<br>(http://example.org/people/bob, http://example.org/ontology/name, &quot;Bob&quot;) [http://example.org/people/cxt2]<br>(http://example.org/people/bob, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/ontology/Person) [http://example.org/people/cxt2]<br>(http://example.org/people/alice, http://example.org/ontology/name, &quot;Alice&quot;) [http://example.org/people/cxt1]<br>(http://example.org/people/alice, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/ontology/Person) [http://example.org/people/cxt1]</pre>
<p>This time we use getStatements() to search explicitly for triples in the null context or in context 2.</p>
<pre class="input">        statements = conn.getStatements(null, null, null, false, null, context2);<br>        println(&quot;\nTriples in contexts null or 2:&quot;);        <br>        while (statements.hasNext()) {<br>            println(statements.next());<br>        }</pre>
<p>The output of this loop is:</p>
<pre class="output">Triples in contexts null or 2:<br>(http://example.org/people/bob, http://example.org/ontology/name, &quot;Bob&quot;) [http://example.org/people/cxt2]<br>(http://example.org/people/bob, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/ontology/Person) [http://example.org/people/cxt2]<br>(http://example.org/people/ted, http://example.org/ontology/name, &quot;Ted&quot;) [null]<br>(http://example.org/people/ted, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/ontology/Person) [null]</pre>
<p>Next, we switch to SPARQL queries. Named contexts may be included in the FROM and FROM-NAMED clauses in a SPARQL query. Below, we illustrate the procedural equivalent, which is to create a <strong>dataset</strong> object, add the contexts to that, and then to attach the dataset to the query object. The query is (again) restricted to only those statements in contexts 1 and 2.</p>
<pre class="input">        String queryString = &quot;SELECT ?s ?p ?o ?c WHERE { GRAPH ?c {?s ?p ?o . } }&quot;;        <br>        DatasetImpl ds = new DatasetImpl();<br>        ds.addNamedGraph(context1);<br>        ds.addNamedGraph(context2);<br>        TupleQuery tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString);<br>        tupleQuery.setDataset(ds);<br>        TupleQueryResult result = tupleQuery.evaluate();    <br>        println(&quot;\nQuery over contexts 1 and 2.&quot;);<br>        while (result.hasNext()) {<br>            BindingSet bindingSet = result.next();<br>            println(bindingSet.getBinding(&quot;s&quot;) + &quot; &quot; + bindingSet.getBinding(&quot;c&quot;));<br>        }    </pre>
<p>The output of this loop contains four triples, as expected. </p>
<pre class="output">Query over contexts 1 and 2.<br>s=http://example.org/people/alice p=http://www.w3.org/1999/02/22-rdf-syntax-ns#type o=http://example.org/ontology/Person c=http://example.org/people/cxt1<br>s=http://example.org/people/alice p=http://example.org/ontology/name o=&quot;Alice&quot; c=http://example.org/people/cxt1<br>s=http://example.org/people/bob p=http://www.w3.org/1999/02/22-rdf-syntax-ns#type o=http://example.org/ontology/Person c=http://example.org/people/cxt2<br>s=http://example.org/people/bob p=http://example.org/ontology/name o=&quot;Bob&quot; c=http://example.org/people/cxt2</pre>
<p> Currently, its not possible to combine the null context with other contexts in a SPARQL query. Below, we illustrate how to evaluate a query against only the null context.</p>
<pre class="input">        queryString = &quot;SELECT ?s ?p ?o WHERE {?s ?p ?o . }&quot;;<br>        ds = new DatasetImpl();<br>        // TODO: ds.addDefaultGraph(null);<br>        tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString);<br>        tupleQuery.setDataset(ds);<br>        result = tupleQuery.evaluate();    <br>        println(&quot;\nQuery over the null context.&quot;);<br>        while (result.hasNext()) {<br>            println(result.next());<br>        }</pre>

<p>The output of this loop is:</p>
<!-- TODO Java was returning six triples, should be two. -->
<pre class="output">Query over the null context.<br>['&lt;http://example.org/people/ted&gt;', '&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;', '&lt;http://example.org/people/Person&gt;']
['&lt;http://example.org/people/ted&gt;', '&lt;http://example.org/people/name&gt;', '&quot;Ted&quot;']</pre>

<h2 id="Namespaces">Namespaces (example11()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>
A <i>namespace</i> is that portion of a URI that preceeds the last '#',
'/', or ':' character, inclusive.  The remainder of a URI is called the
<i>localname</i>.  For example, with respect to the URI "http://example.org/people/alice",
the namespace is "http://example.org/people/" and the localname is "alice".
When writing SPARQL queries, it is convenient to define prefixes or nicknames
for the namespaces, so that abbreviated URIs can be specified.  For example,
if we define "ex" to be a nickname for "http://example.org/people/", then the
string "ex:alice" is a recognized abbreviation for "http://example.org/people/alice".
This abbreviation is called a <i>qname</i>.
</p>
<p>
In the SPARQL query in the example below, we see two qnames, "rdf:type" and
"ex:alice".  Ordinarily, we would expect to see "PREFIX" declarations in
SPARQL that define namespaces for the "rdf" and "ex" nicknames.  However,
the RepositoryConnection and Query machinery can do that job for you.  The
mapping of prefixes to namespaces includes the built-in prefixes RDF, RDFS, XSD, and OWL.
Hence, we can write "rdf:type" in a SPARQL query, and the system already knows
its meaning.  In the case of the 'ex' prefix, we need to instruct it.  The
setNamespace() method of the connection object registers a new namespace.  In the example
below, we first register the 'ex' prefix, and then submit the SPARQL query.
It is legal, although not recommended, to redefine the built-in prefixes RDF, etc..
</p>
<p>The example example11() begins by borrowing a connection object from example1(). Then we retrieve the repository object and its associated valueFactory. </p>
<pre class="input">    public static void example11 () throws Exception {<br>        RepositoryConnection conn = example1(false);<br>        Repository myRepository = conn.getRepository();<br>        ValueFactory f = myRepository.getValueFactory();</pre>
<p>We need a namespace string (bound to the variable <strong>exns</strong>) to use when generating the <strong>alice</strong> and <strong>person</strong> URIs. </p>
<pre class="input">        String exns = &quot;http://example.org/people/&quot;;<br>        URI alice = f.createURI(exns, &quot;alice&quot;);<br>        URI person = f.createURI(exns, &quot;Person&quot;);</pre>
<p>Now we can assert Alice's RDF:TYPE triple. </p>
<pre class="input">        conn.add(alice, RDF.TYPE, person);</pre>
<p>Now we register the exns namespace with the connection object, so we can use it in a SPARQL query. The query looks for triples that have &quot;rdf:type&quot; in the predicate position, and &quot;ex:Person&quot; in the object position. </p>
<pre class="input">        conn.setNamespace(&quot;ex&quot;, exns);<br>        String queryString = <br>        	&quot;SELECT ?s ?p ?o &quot; +<br>        	&quot;WHERE { ?s ?p ?o . FILTER ((?p = rdf:type) &amp;&amp; (?o = ex:Person) ) }&quot;;<br>        TupleQuery tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString);<br>        TupleQueryResult result = tupleQuery.evaluate();  <br>        while (result.hasNext()) {<br>            println(result.next());<br>        }</pre>
<p>The output shows the single triple with its fully-expanded URIs.  This demonstrates that the qnames in the SPARQL query successfully matched the fully-expanded URIs in the triple. </p>
<pre class="output">[s=http://example.org/people/alice;p=http://www.w3.org/1999/02/22-rdf-syntax-ns#type;o=http://example.org/people/Person]</pre>
<p>It is worthwhile to briefly discuss performance here.  In the current
  AllegroGraph system, queries run more efficiently if constants appear inside
  of the "where" portion of a query, rather than in the "filter" portion.  For
  example, the SPARQL query below will evaluate more efficiently than the one
  in the above example.  However, in this case, you have lost the ability to
  output the constants "http://www.w3.org/1999/02/22-rdf-syntax-ns#type" and
"http://example.org/people/alice".  Occasionally you may find it useful to
  output constants in the output of a 'select' clause; in general though,
  the above code snippet illustrates a query syntax that is discouraged. </p>
<pre class="input">
SELECT ?s  
WHERE { ?s rdf:type ex:person } 
</pre>

<h2 id="Free Text Search">Free Text Search (example12()) &nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>
It is common for users to build RDF applications that combine
some form of "keyword search" with their queries. For example, a user
might want to retrieve all triples for which the string "Alice" appears
as a word within the third (object) argument to the triple.  AllegroGraph
provides a capability for including free text matching within a SPARQL
query.  It requires, however, that you register the predicates that will participate in text searches so they can be indexed. </p>
<p> The example example12() begins by borrowing the connection object from example1(). Then it creates a namespace string and registers the namespace with the connection object, as in the previous example. </p>
<pre class="input">	public static void example12 () throws Exception {    <br>        AGRepositoryConnection conn = example1(false);<br>	    ValueFactory f = conn.getValueFactory();<br>	    String exns = &quot;http://example.org/people/&quot;;<br>	    conn.setNamespace(&quot;ex&quot;, exns);</pre>
<p>We have to register the predicates that will participate in text indexing. In the example12() example below, we have
called the connection method <strong>registerFreeTextPredicate()</strong> to register the predicate "http://example.org/people/fullname" for text indexing. Generating the predicate's URI is a separate step. </p>
<pre class="input">	    conn.registerFreetextPredicate(f.createURI(exns,&quot;fullname&quot;));</pre>
<p>The next step is to create two new resources, &quot;Alice1&quot; named &quot;Alice B. Toklas,&quot; and &quot;book1&quot; with the title &quot;Alice in Wonderland.&quot; Notice that we did not register the book title predicate for text indexing. </p>
<pre class="input">	    URI alice = f.createURI(exns, &quot;alice1&quot;);<br>	    URI persontype = f.createURI(exns, &quot;Person&quot;);<br>	    URI fullname = f.createURI(exns, &quot;fullname&quot;);    <br>	    Literal alicename = f.createLiteral(&quot;Alice B. Toklas&quot;);<br>	    URI book =  f.createURI(exns, &quot;book1&quot;);<br>	    URI booktype = f.createURI(exns, &quot;Book&quot;);<br>	    URI booktitle = f.createURI(exns, &quot;title&quot;);    <br>	    Literal wonderland = f.createLiteral(&quot;Alice in Wonderland&quot;);</pre>
<p>Clear the repository, so our new triples are the only ones available. </p>
<pre class="input">
        conn.clear()    </pre>
<p>Add the resource for the new person, Alice B. Toklas: </p>
<pre class="input">	    conn.add(alice, RDF.TYPE, persontype);<br>	    conn.add(alice, fullname, alicename);</pre>
<p>Add the new book, <em>Alice in Wonderland</em>. </p>
<pre class="input">	    conn.add(book, RDF.TYPE, booktype);    <br>	    conn.add(book, booktitle, wonderland); </pre>
<p>Now we set up the SPARQL query that looks for triples containing &quot;Alice&quot; in the object position. </p>
<p>The text match occurs through a &quot;magic&quot; predicate called <strong>fti:match</strong>. This is not an RDF &quot;predicate&quot; but a LISP &quot;predicate,&quot; meaning that it behaves as a true/false test. This predicate  has two arguments. One is  the subject URI of the resources to search. The other is the string pattern to search for, such as &quot;Alice&quot;. Only registered text predicates will be searched. Only full-word matches will be found. </p>
<pre class="input">	    String queryString = <br>	        &quot;SELECT ?s ?p ?o &quot; +<br>	        &quot;WHERE { ?s ?p ?o . ?s fti:match 'Alice' . }&quot;;<br>        TupleQuery tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString);<br>        TupleQueryResult result = (TupleQueryResult)tupleQuery.evaluate();</pre>
<p>There is no need to include a prefix declaration for the 'fti' nickname. That is because 'fti' is included among the built-in namespace/nickname mappings in AllegroGraph.</p>
<p>When we execute our SPARQL query, it matches the "Alice" within the literal "Alice B. Toklas" because that literal occurs in a triple having the registered <strong>fullname</strong> predicate, but it does not match the "Alice" in the literal "Alice in Wonderland" because the <strong>booktitle</strong> predicate was not registered for text indexing. This query returns <em>all triples</em> of a resource that had a successful match in at least one object value. </p>
<pre class="input">        TupleQuery tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString);<br>        TupleQueryResult result = (TupleQueryResult)tupleQuery.evaluate();<br>        int count = 0;<br>        while (result.hasNext()) {<br>            BindingSet bindingSet = result.next();<br>            if (count &lt; 5) {<br>                println(bindingSet);<br>            }<br>            count += 1;<br>        }</pre>
<p>The output of this loop is:</p>
<pre class="output">Whole-word match for 'Alice'.<br>[s=http://example.org/people/alice1;p=http://example.org/people/fullname;o=&quot;Alice B. Toklas&quot;]<br>[s=http://example.org/people/alice1;p=http://www.w3.org/1999/02/22-rdf-syntax-ns#type;o=http://example.org/people/Person]</pre>
<p>The text index supports simple wildcard queries. The asterisk (*) may be appended to the end of the pattern to indicate &quot;any number of additional characters.&quot; For instance, this query looks for whole words that begin with &quot;Ali&quot;:</p>
<pre class="input">        queryString = <br>        	&quot;SELECT ?s ?p ?o &quot; +<br>        	&quot;WHERE { ?s ?p ?o . ?s fti:match 'Ali*' . }&quot;;</pre>
<p>It finds the same two triples as before.</p>
<p>There is also a single-character wildcard, the questionmark.  You can add as many question marks as you need to the string pattern.  This query looks for a five-letter word that has "l" in the second position, and "c" in the fourth position:</p>
<pre class="input">        queryString = <br>        	&quot;SELECT ?s ?p ?o &quot; +<br>        	&quot;WHERE { ?s ?p ?o . ?s fti:match '?l?c?' . }&quot;;</pre>
<p>This query finds the same two triples as before. </p>
<p>This time we'll do something a little different.  The free text indexing matches whole words only, even when using wildcards. What if you really need to match a substring in a word of unknown length? You can write a SPARQL query that performs a <strong>regex </strong>match against object values. This can be inefficient compared to indexed search, and the match is not confined to the registered free-text predicates. The following query looks for the substring &quot;lic&quot; in all literal object values:</p>
<pre class="input">        queryString = <br>        	&quot;SELECT ?s ?p ?o &quot; +<br>        	&quot;WHERE { ?s ?p ?o . FILTER regex(?o, \&quot;lic\&quot;) }&quot;;</pre>
<p>This query returns two triples, but they are not quite the same as before:</p>
<pre class="output">Substring match for 'lic'.<br>[s=http://example.org/people/alice1;p=http://example.org/people/fullname;o=&quot;Alice B. Toklas&quot;]<br>[s=http://example.org/people/book1;p=http://example.org/people/title;o=&quot;Alice in Wonderland&quot;]</pre>
<p>As you can see, the regex match found &quot;lic&quot; in &quot;Alice in Wonderland,&quot; which was not a registered free-text predicate. It made this match by doing a string comparison against every object value in the triple store. Even though you can streamline the SPARQL query considerably by writing more restrictive patterns, this is still inherently less efficient than using the indexed approach. </p>
<h2 id="Ask, Describe, and Construct Queries">Ask, Describe, and Construct Queries (example13())&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>SPARQL provides alternatives to the standard SELECT query. Example example13() exercises these alternatives to show how AllegroGraph Server handles them. </p>
<ul>
  <li>    SELECT: Returns all, or a subset of, the variables bound in a query pattern match. </li>
  <li>CONSTRUCT: Returns an RDF graph constructed by substituting variables in a set of triple templates. </li>
  <li>ASK: Returns a boolean indicating whether a query pattern matches or not. </li>
  <li>DESCRIBE: Returns an RDF graph that describes the resources found. </li>
</ul>
<p>The example begins by borrowing a connection object from example2(). Then it registers two namespaces for use in the SPARQL queries.:
<pre class="input">    public static void example13 () throws Exception {<br>        RepositoryConnection conn = example2(false);<br>        conn.setNamespace(&quot;ex&quot;, &quot;http://example.org/people/&quot;);<br>        conn.setNamespace(&quot;ont&quot;, &quot;http://example.org/ontology/&quot;);</pre>
<p>The example begins with an unconstrained SELECT query so we can see what triples are available for matching. </p>
<pre class="input">        String queryString = &quot;select ?s ?p ?o where { ?s ?p ?o} &quot;;<br>        TupleQuery tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString);<br>        TupleQueryResult result = tupleQuery.evaluate();<br>        while (result.hasNext()) {<br>            println(result.next());<br>        }<br>        result.close();</pre>
The output for the SELECT query was four triples about Alice and Bob:
<pre class="output">SELECT result:<br>[s=http://example.org/people/alice;p=http://example.org/ontology/name;o=&quot;Alice&quot;]<br>[s=http://example.org/people/alice;p=http://www.w3.org/1999/02/22-rdf-syntax-ns#type;o=http://example.org/ontology/Person]<br>[s=http://example.org/people/bob;p=http://www.w3.org/1999/02/22-rdf-syntax-ns#type;o=http://example.org/ontology/Person]<br>[s=http://example.org/people/bob;p=http://example.org/ontology/name;o=&quot;Bob&quot;]</pre>
<p>The ASK query returns a Boolean, depending on whether the triple pattern matched any triples. In this case it looks for any ont:name triplecontaining the value &quot;Alice.&quot; Note that the ASK query uses a different construction method than the SELECT query:<strong> prepareBooleanQuery()</strong>. </p>
<pre class="input">        queryString = &quot;ask { ?s ont:name \&quot;Alice\&quot; } &quot;;<br>        BooleanQuery booleanQuery = conn.prepareBooleanQuery(QueryLanguage.SPARQL, queryString);<br>        boolean truth = booleanQuery.evaluate(); <br>        println(&quot;\nBoolean result: &quot; + truth);</pre>
<p>The output of this loop is:</p>
<pre class="output">Boolean result: true</pre>
<p>The CONSTRUCT query contructs a statement object out of the matching values in the triple pattern. A &quot;statement&quot; is a client-side triple. Construction queries use <strong>prepareGraphQuery()</strong>. The point is that the query can bind variables from existing triples and then &quot;construct&quot; a new triple by recombining the values. </p>
<pre class="input">        queryString = &quot;construct {?s ?p ?o} where { ?s ?p ?o . filter (?o = \&quot;Alice\&quot;) } &quot;;<br>        GraphQuery constructQuery = conn.prepareGraphQuery(QueryLanguage.SPARQL, queryString);<br>        GraphQueryResult gresult = constructQuery.evaluate(); <br>        List statements = new ArrayList();<br>        while (gresult.hasNext()) {<br>            statements.add(gresult.next());<br>        }<br>        println(&quot;\nConstruct result:\n&quot; + statements);</pre>
<p>The output of this loop is below. It has created a statement from values found in the repository. </p>
<pre class="output">Construct result:<br>[(http://example.org/people/alice, http://example.org/ontology/name, &quot;Alice&quot;)]</pre>
The DESCRIBE query returns a &quot;graph,&quot; meaning all triples of the matching resources.  It uses <strong>prepareGraphQuery()</strong>. 
<pre class="input">        queryString = &quot;describe ?s where { ?s ?p ?o . filter (?o = \&quot;Alice\&quot;) } &quot;;<br>        GraphQuery describeQuery = conn.prepareGraphQuery(QueryLanguage.SPARQL, queryString);<br>        gresult = describeQuery.evaluate(); <br>        println(&quot;\nDescribe result:&quot;);<br>        while (gresult.hasNext()) {<br>            println(gresult.next());<br>        }<br>        gresult.close();<br>        conn.close();</pre>
<p>The output of this loop is:</p>
<pre class="output">Describe result:<br>(http://example.org/people/alice, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/ontology/Person)<br>(http://example.org/people/alice, http://example.org/ontology/name, &quot;Alice&quot;)</pre>
<h2 id="Parametric Queries">Parametric Queries (example14())&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
 <p>The Java API to AllegroGraph Server lets you set up a SPARQL query and then fix the value of one of the query variables prior to matching the triples. This is more efficient than testing for the same value in the body of the query. </p>
 <p>In <strong>example14()</strong> we set up two-triple resources for Bob and Alice, and then use an unconstrained SPARQL query to retrieve the triples. Normally this query would find all four triples, but by binding the subject value ahead of time, we can retrieve the &quot;Bob&quot; triples separately from the &quot;Alice&quot; triples.</p>
 <p>The example begins by borrowing a connection object from example2(). This means there are already Bob and Alice resources in the repository. We do need to recreate the URIs for the two resources, however. </p>
 <pre class="input">    public static void example14() throws Exception {<br>        RepositoryConnection conn = example2(false);<br>        ValueFactory f = conn.getValueFactory();<br>        URI alice = f.createURI(&quot;http://example.org/people/alice&quot;);<br>        URI bob = f.createURI(&quot;http://example.org/people/bob&quot;);</pre>
<p>The SPARQL query is the simple, unconstrained query that returns all triples. We use <strong>prepareTupleQuery()</strong> to create the query object. </p>
<pre class="input">        String queryString = &quot;select ?s ?p ?o where { ?s ?p ?o} &quot;;<br>        TupleQuery tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString);</pre>
<p>Before evaluating the query, however, we'll use the query object's <strong>setBinding()</strong> method to assign Alice's URI to the &quot;s&quot; variable in the query. This means that all matching triples are required to have Alice's URI in the subject position of the triple. </p>
<pre class="input">        tupleQuery.setBinding(&quot;s&quot;, alice);<br>        TupleQueryResult result = tupleQuery.evaluate();<br>        println(&quot;\nFacts about Alice:&quot;);            <br>        while (result.hasNext()) {<br>            println(result.next());<br>        }<br>        result.close();</pre>
<p>The output of this loop consists of all triples that describe Alice:</p>
<pre class="output">Facts about Alice:<br>[s=http://example.org/people/alice;p=http://www.w3.org/1999/02/22-rdf-syntax-ns#type;o=http://example.org/ontology/Person]<br>[s=http://example.org/people/alice;p=http://example.org/ontology/name;o=&quot;Alice&quot;]</pre>
<p>Now we'll run the same query again, but this time we'll constrain &quot;s&quot; to be Bob's URI. The query will return all triples that describe Bob. </p>
<pre class="input">        tupleQuery.setBinding(&quot;s&quot;, bob);<br>        println(&quot;\nFacts about Bob:&quot;);    <br>        result = tupleQuery.evaluate();<br>        while (result.hasNext()) {<br>            println(result.next());<br>        }<br>        result.close();<br>        conn.close();</pre>
 The output of this loop is:
 <pre class="output">Facts about Bob:<br>[s=http://example.org/people/bob;p=http://example.org/ontology/name;o=&quot;Bob&quot;]<br>[s=http://example.org/people/bob;p=http://www.w3.org/1999/02/22-rdf-syntax-ns#type;o=http://example.org/ontology/Person]</pre>
 <h2 id="Range Matches">Range Matches (example15())&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
 <p>Example example15() demonstrates how to set up a query that matches a range of values. In this case, we'll retrieve all people between 30 and 50 years old (inclusive). We can accomplish this using a SPARQL query to take advantage of AllegroGraph's automatic typing of literal values. </p>
 <p>This example begins by getting a connection object from example1(), and then clearing the repository of the existing triples. </p>
 <pre class="input">    public static void example15() throws Exception {<br>        println(&quot;Starting example example15().&quot;);<br>        AGRepositoryConnection conn = example1(false);<br>        ValueFactory f = conn.getValueFactory();<br>        conn.clear();</pre>
<p>Then we register a namespace to use in the query. </p>
<pre class="input">        String exns = &quot;http://example.org/people/&quot;;<br>        conn.setNamespace(&quot;ex&quot;, exns);</pre>
<p>Next we need to set up the URIs for Alice, Bob, Carol and the predicate &quot;age&quot;. </p>
<pre class="input">        URI alice = f.createURI(exns, &quot;alice&quot;);<br>        URI bob = f.createURI(exns, &quot;bob&quot;);<br>        URI carol = f.createURI(exns, &quot;carol&quot;);    <br>        URI age = f.createURI(exns, &quot;age&quot;);    </pre>
<p>The next step is to create age triples for the three people. Notice that the values are inconsistent. One is an integer; one is a float; and one is a number in a string. Good programming would require more consistency here, but real-world data often breaks the rules. </p>
<pre class="input">        conn.add(alice, age, f.createLiteral(42));<br>        conn.add(bob, age, f.createLiteral(45.1));<br>        conn.add(carol, age, f.createLiteral(&quot;39&quot;));</pre>
<p>AllegroGraph's internal datatype mapping automatically transforms 42 into an XMLSchema#int, and 45.1 into an XMLSchema#double. The string, however, is treated as a literal string value. </p>
<p>The next step is to use SPARQL to retrieve all triples where the age value is between 30 and 50. Note that the literal numbers 30 and 50 are converted internally to integers, but the test also permits floats (doubles) to match, too. </p>
<pre class="input">        println(&quot;\nRange query for integers and floats.&quot;);<br>        String queryString = <br>        	&quot;SELECT ?s ?p ?o  &quot; +<br>        	&quot;WHERE { ?s ?p ?o . &quot; +<br>        	&quot;FILTER ((?o &gt;= 30) &amp;&amp; (?o &lt;= 50)) }&quot;;<br>        TupleQuery tupleQuery = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString);<br>        TupleQueryResult result = tupleQuery.evaluate();</pre>
<p>The result object contains:</p>
<pre class="output">Range query for integers and floats.<br>http://example.org/people/alice http://example.org/people/age &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#int&gt;<br>http://example.org/people/bob http://example.org/people/age &quot;45.1&quot;^^&lt;http://www.w3.org/2001/XMLSchema#double&gt;</pre>
<p>It has matched 42 and 45.1, but not &quot;39&quot;. </p>
<p>What if we want to pick up the odd values that were created as strings? SPARQL lets us cast the triple's object value as an integer before making the test. That query looks like this:</p>
<pre class="input">         String queryString = 
         &quot;PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; &quot; +
         &quot;SELECT ?s ?p ?o &quot; +
         &quot;WHERE { ?s ?p ?o . &quot; +
         &quot;FILTER ((xsd:integer(?o) &gt;= 30) &amp;&amp; (xsd:integer(?o) &lt;= 50)) }&quot;;</pre>

<p>Note that we had to add a PREFIX line to accommodate the xsd: namespace. The <strong>xsd:integer(?o)</strong> element takes the current object value and attempts to coerce it to be an integer. If successful, the test goes forward.</p>
<p>The output of this query is:</p>
<pre class="output">Range query for integers, floats, and integers in strings.
http://example.org/people/alice http://example.org/people/age &quot;42&quot;^^&lt;http://www.w3.org/2001/XMLSchema#int&gt;
http://example.org/people/bob http://example.org/people/age &quot;45.1&quot;^^&lt;http://www.w3.org/2001/XMLSchema#double&gt;
http://example.org/people/carol http://example.org/people/age &quot;39&quot;  </pre>
<p>This query picked up integer, double, and string values. </p>
<h2 id="Federated Repositories">Federated Repositories (test16())&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>AllegroGraph lets you split up your triples among repositories on multiple servers and then search them all in parallel. To do this we query a single &quot;federated&quot; repository that automatically distributes the queries to the secondary repositories and combines the results. From the point of view of your Python code, it looks like you are working with a single repository. </p>
<p>This example begins by defining a small output function that we'll use at the end of the lesson. It prints out responses from different repositories. This example is about red apples and green apples, so the output function talks about apples. </p>
<pre class="input">    private static void pt(String kind, TupleQueryResult rows) throws Exception {<br>        println(&quot;\n&quot; + kind + &quot; Apples:\t&quot;);<br>        while (rows.hasNext()) {<br>            println(rows.next());<br>        }<br>        rows.close();<br>    }</pre>
<p>In example16(), we open connections to a redRepository and a greenRepository on the local server. In a typical federation scenario, these respositories would be distributed across multiple servers. We begin with the connection object from example6(), and then climb the object tree to obtain its catalog. </p>
<pre class="input">    public static void example16() throws Exception {<br>        AGRepositoryConnection conn = example6(false);<br>        AGRepository myRepository = conn.getRepository();<br>        AGCatalog catalog = myRepository.getCatalog();</pre>
<p>The next few lines establish a &quot;red&quot; repository in the catalog. </p>
<pre class="input">        AGRepository redRepo = catalog.createRepository(&quot;redthings&quot;);<br>        redRepo.initialize();<br>        RepositoryConnection redConn = redRepo.getConnection();
		closeBeforeExit(redConn);<br>        redConn.clear();<br>        ValueFactory rf = redConn.getValueFactory();</pre>
<p>Followed by a &quot;green&quot; repository. </p>
<pre class="input">        AGRepository greenRepo = catalog.createRepository(&quot;greenthings&quot;);<br>        greenRepo.initialize();<br>        RepositoryConnection greenConn = greenRepo.getConnection();
		closeBeforeExit(greenConn);<br>        greenConn.clear();<br>        ValueFactory gf = greenConn.getValueFactory();</pre>
<p>Now we create a &quot;federated&quot; respository, which is connected to the distributed repositories at the back end. First we have to obtain the server object because the server supplies the <strong>createFederation() </strong>method. </p>
<pre class="input">
        AGServer server = myRepository.getCatalog().getServer();<br>        AGRepository rainbowRepo = server.createFederation(&quot;rainbowthings&quot;,redRepo, greenRepo);<br>        rainbowRepo.initialize();<br>        RepositoryConnection rainbowConn = rainbowRepo.getConnection();
		closeBeforeExit(rainbowConn);</pre>
<p>The next step is to populate the Red and Green repositories with a few triples. Notice that we have two red apples, a green apple, and a famous frog. </p>
<pre class="input">        String ex = &quot;http://www.demo.com/example#&quot;;<br>        // add a few triples to the red and green stores:<br>        redConn.add(rf.createURI(ex+&quot;mcintosh&quot;), RDF.TYPE, rf.createURI(ex+&quot;Apple&quot;));<br>        redConn.add(rf.createURI(ex+&quot;reddelicious&quot;), RDF.TYPE, rf.createURI(ex+&quot;Apple&quot;));    <br>        greenConn.add(gf.createURI(ex+&quot;pippin&quot;), RDF.TYPE, gf.createURI(ex+&quot;Apple&quot;));<br>        greenConn.add(gf.createURI(ex+&quot;kermitthefrog&quot;), RDF.TYPE, gf.createURI(ex+&quot;Frog&quot;));</pre>
<p>It is necessary to register the &quot;ex&quot; namespace in all three repositories so we can use it in the upcoming query. </p>
<pre class="input">        redConn.setNamespace(&quot;ex&quot;, ex);<br>        greenConn.setNamespace(&quot;ex&quot;, ex);<br>        rainbowConn.setNamespace(&quot;ex&quot;, ex);</pre>
<p>Now we write a query that retrieves Apples from the Red repository, the Green repository, and the federated repository, and prints out the results. </p>
<pre class="input">        String queryString = &quot;select ?s where { ?s rdf:type ex:Apple }&quot;;<br>        // query each of the stores; observe that the federated one is the union of the other two:<br>        pt(&quot;red&quot;, redConn.prepareTupleQuery(QueryLanguage.SPARQL, queryString).evaluate());<br>        pt(&quot;green&quot;, greenConn.prepareTupleQuery(QueryLanguage.SPARQL, queryString).evaluate());<br>        pt(&quot;federated&quot;, rainbowConn.prepareTupleQuery(QueryLanguage.SPARQL, queryString).evaluate());<br>    }</pre>
<p>The output is shown below. The federated response combines the individual responses. (There are no frogs.) </p>
<pre class="output">Red Apples:	<br>[s=http://www.demo.com/example#reddelicious]<br>[s=http://www.demo.com/example#mcintosh]<br>
Green Apples: <br>[s=http://www.demo.com/example#pippin]<br>
Federated Apples: <br>[s=http://www.demo.com/example#reddelicious]<br>[s=http://www.demo.com/example#mcintosh]<br>[s=http://www.demo.com/example#pippin]</pre>
<h2 id="Prolog Rule Queries">Prolog Rule Queries (example17())&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>AllegroGraph Server lets us load Prolog backward-chaining rules to make query-writing simpler.&nbsp; The Prolog rules let us write the queries in terms of higher-level concepts.&nbsp; When a query refers to one of these concepts, Prolog rules become active in the background to determine if the concept is valid in the current context.&nbsp; </p>
<p>For instance, in this example the query says that the matching resource must be a &quot;man&quot;.&nbsp; A Prolog rule examines the matching resources to see which of them are persons who are male.&nbsp; The query can proceed for those resources. The rules provide a level of abstraction that makes the queries simpler to express. </p>
<p>The example17() example begins by borrowing a connection object from example example6(), which contains the Kennedy family tree.&nbsp; Note that example6() creates a <a href="#Transaction">dedicated session</a> for the rules to operate in, using the Connection object's <strong>openDedicated()</strong> method. Java rules cannot be loaded into the AllegroGraph common back end. </p>
<pre class="input">        conn.openSession(); # in example6()</pre>
<p>This converts the connection to a &quot;dedicated&quot; session. After that step, all of the code is exactly the same as when using the common back end.</p>
<pre class="input">    public static void example17() throws Exception {<br>        AGRepositoryConnection conn = example6(false);</pre>
<p>We will need the same namespace as we used in the Kennedy example. </p>
<pre class="input">        conn.setNamespace(&quot;kdy&quot;, &quot;http://www.franz.com/simple#&quot;);</pre>
<p>These are the &quot;man&quot; and &quot;woman&quot; rules.&nbsp; A resource represents a &quot;woman&quot; if the resource contains a sex = female triple and an rdf:type = person triple.&nbsp; A similar deduction identifies a &quot;man&quot;.&nbsp; The &quot;q&quot; at the beginning of each pattern simply stands for &quot;query&quot; and introduces a triple pattern. </p>
<pre class="input">        String rules1 =<br>            &quot;(&lt;-- (woman ?person) ;; IF\n&quot; +<br>            &quot;     (q ?person !kdy:sex !kdy:female)\n&quot; +<br>            &quot;     (q ?person !rdf:type !kdy:person))\n&quot; +<br>            &quot;(&lt;-- (man ?person) ;; IF\n&quot; +<br>            &quot;     (q ?person !kdy:sex !kdy:male)\n&quot; +<br>            &quot;     (q ?person !rdf:type !kdy:person))&quot;;</pre>
<p>The rules must be explicitly added to the dedicated session. </p>
<pre class="input">        conn.addRules(rules1);
</pre>
<p>This is the query.&nbsp; This query locates all the &quot;man&quot; resources, and retrieves their first and last names. </p>
<pre class="input">        String queryString =<br>            &quot;(select (?first ?last)\n&quot; +<br>            &quot;        (man ?person)\n&quot; +<br>            &quot;        (q ?person !kdy:first-name ?first)\n&quot; +<br>            &quot;        (q ?person !kdy:last-name ?last))&quot;;</pre>
<p>Here we perform the query and retrieve the result object.&nbsp; </p>
<pre class="input">        TupleQuery tupleQuery = conn.prepareTupleQuery(AGQueryLanguage.PROLOG, queryString);<br>        TupleQueryResult result = tupleQuery.evaluate();</pre>
<p>The result object contains multiple bindingSets.&nbsp; We can iterate over them to print out the values. </p>
<pre class="input">        while (result.hasNext()) {<br>            BindingSet bindingSet = result.next();<br>            Value f = bindingSet.getValue(&quot;first&quot;);<br>            Value l = bindingSet.getValue(&quot;last&quot;);<br>            println(f + &quot; &quot; + l);<br>        }<br>        result.close();</pre>
<p>The output contains many names; there are just a few of them. </p>
<pre class="output">&quot;Robert&quot; &quot;Kennedy&quot;<br>&quot;Alfred&quot; &quot;Tucker&quot;<br>&quot;Arnold&quot; &quot;Schwarzenegger&quot;<br>&quot;Paul&quot; &quot;Hill&quot;<br>&quot;John&quot; &quot;Kennedy&quot;</pre>
<p>It is good form to close the dedicated session when you are finished with it.</p>
<pre class="input">    conn.closeSession();</pre>
<h2 id="Loading Prolog Rules">Loading Prolog Rules (example18())&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>Example <strong>example18()</strong> demonstrates how to load a file of Prolog rules into the Java API of AllegroGraph Server.&nbsp; It also demonstrates how robust a rule-augmented system can become.&nbsp; The domain is the Kennedy family tree again, borrowed from example6().&nbsp; After loading a file of rules (<strong>relative_rules.txt</strong>), we'll pose a simple query.&nbsp; The query asks AllegroGraph to list all the uncles in the family tree, along with each of their nieces or nephews.&nbsp; This is the query:</p>
<pre class="input">(select (?person ?uncle) &quot; +<br>	&quot;(uncle ?y ?x)&quot; +<br>	&quot;(name ?x ?person)&quot; +<br>	&quot;(name ?y ?uncle))&quot;;</pre>
<p>The problem is that the triple store contains no information about uncles.&nbsp; The rules will have to deduce this relationship by finding paths across the RDF graph.</p>
<p>What's an &quot;uncle,&quot; then?&nbsp; Here's a rule that can recognize uncles:</p>
<pre class="input">(&lt;-- (uncle ?uncle ?child) <br>    (man ?uncle)<br>    (parent ?grandparent ?uncle)<br>    (parent ?grandparent ?siblingOfUncle)<br>    (not (= ?uncle ?siblingOfUncle))<br>    (parent ?siblingOfUncle ?child))</pre>
<p>The rule says that an &quot;uncle&quot; is a &quot;man&quot; who has a sibling who is the &quot;parent&quot; of a child.&nbsp; (Rules like this always check to be sure that the two nominated siblings are not the same resource.) Note that none of these relationships directly match triples in the repository. They all deal in higher-order concepts. We'll need additional rules to determine what a &quot;man&quot; is, and what a &quot;parent&quot; is.</p>
<p>What is a &quot;parent?&quot; It turns out that there are two ways to be classified as a parent:</p>
<pre class="input">(&lt;-- (parent ?father ?child)<br>    (father ?father ?child))

(&lt;-- (parent ?mother ?child)<br>    (mother ?mother ?child))</pre>
<p>A person is a &quot;parent&quot; if a person is a &quot;father.&quot;&nbsp; Similarly, a person is a &quot;parent&quot; if a person is a &quot;mother.&quot; </p>
<p>What's a &quot;father?&quot;</p>
<pre class="input">(&lt;-- (father ?parent ?child)<br>    (man ?parent)<br>    (q ?parent !rltv:has-child ?child))</pre>
<p>A person is a &quot;father&quot; if the person is &quot;man&quot; and has a child. &nbsp; The final pattern (starting with &quot;q&quot;) is a triple match from the Kennedy family tree.</p>
<p>What's a &quot;man?&quot;</p>
<pre class="input">(&lt;-- (man ?person)<br>    (q ?person !rltv:sex !rltv:male)<br>    (q ?person !rdf:type !rltv:person))</pre>
<p>A &quot;man&quot; is a person who is male.&nbsp; These patterns both match triples in the repository.&nbsp; </p>
<p>The<strong> relative_rules.txt</strong> file contains many more Prolog rules describing relationships, including transitive relationships like &quot;ancestor&quot; and &quot;descendant.&quot; Please examine this file for more ideas about how to use rules with AllegroGraph. </p>
<p>The <strong>example18()</strong> example begins by borrowing a connection object from example6(), which means the Kennedy family tree is already loaded into the repository, and we are dealing with a <a href="#Transaction">dedicated session</a>. &nbsp; </p>
<pre class="input">    public static void example18() throws Exception {<br>        AGRepositoryConnection conn = example6(false);</pre>
<p>We need these two namespaces because they are used in the query and in the file of rules. </p>
<pre class="input">        conn.setNamespace(&quot;kdy&quot;, &quot;http://www.franz.com/simple#&quot;);<br>        conn.setNamespace(&quot;rltv&quot;, &quot;http://www.franz.com/simple#&quot;);</pre>
<!-- <p>We need to tell AllegroGraph Server which query syntax to expect. </p>
<pre class="input">
    conn.setRuleLanguage(QueryLanguage.PROLOG)</pre> 
	-->
<p>The next step is to load the rule file. Note that you might have to edit the file path, depending on your platform and installation. </p>
<pre class="input">        String path = &quot;src/relative_rules.txt&quot;;<br>        conn.addRules(new FileInputStream(path));</pre>
<p>The query asks for the full name of each uncle and each niece/nephew.&nbsp; (The (name ?x ?fullname) relationship used in the query is provided by yet another Prolog rule, which concatenates a person's first and last names into a single string.) </p>
<pre class="input">        String queryString = <br>        	&quot;(select (?person ?uncle) &quot; +<br>        		&quot;(uncle ?y ?x)&quot; +<br>        		&quot;(name ?x ?person)&quot; +<br>        		&quot;(name ?y ?uncle))&quot;;</pre>
<p>Here we execute the query and display the results:</p>
<pre class="input">        TupleQuery tupleQuery = conn.prepareTupleQuery(AGQueryLanguage.PROLOG, queryString);<br>        TupleQueryResult result = tupleQuery.evaluate();     <br>        while (result.hasNext()) {<br>            BindingSet bindingSet = result.next();<br>            Value p = bindingSet.getValue(&quot;person&quot;);<br>            Value u = bindingSet.getValue(&quot;uncle&quot;);<br>            println(u + &quot; is the uncle of &quot; + p);<br>        }</pre>
<p>The output of this loop (in part) looks like this:
<pre class="output">&quot;{Edward} {Kennedy}&quot; is the uncle of &quot;{Robin} {Lawford}&quot;<br>&quot;{Edward} {Kennedy}&quot; is the uncle of &quot;{Stephen} {Smith}&quot;<br>&quot;{Edward} {Kennedy}&quot; is the uncle of &quot;{William} {Smith}&quot;<br>&quot;{Edward} {Kennedy}&quot; is the uncle of &quot;{Amanda} {Smith}&quot;<br>&quot;{Edward} {Kennedy}&quot; is the uncle of &quot;{Kym} {Smith}&quot;</pre>
<p>As before, it is good form to free the dedicated session and the result object when you are finished with them.</p>
<pre class="input">        result.close();<br>        conn.close();</pre>

<h2 id="RDFS++ Inference">RDFS++ Inference (example19())&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>The great promise of the semantic web is that we can use RDF metadata to combine information from multiple sources into a single, common model.&nbsp; The great problem of the semantic web is that it is so difficult to recognize when two resource descriptions from different sources actually represent the same thing.&nbsp; This problem arises because there is no uniform or universal way to generate URIs identifying resources.&nbsp; As a result, we may create two resources, Bob and Robert, that actually represent the same person. </p>
<p>This problem has generated much creativity in the field. One way to approach the problem is through inference.&nbsp; There are certain relationships and circumstances where an inference engine can deduce that two resource descriptions actually represent one thing, and then automatically merge the descriptions.&nbsp; AllegroGraph's <a href="http://www.franz.com/agraph/support/documentation/3.0.1/reasoner-tutorial.html">inference engine</a> can be turned on or off each time you run a query against the triple store.&nbsp; </p>
<p>In example example19(), we will create four resources: Bob, with son Bobby, and Robert with daughter Roberta.&nbsp; </p>
<p><img src="inferenceSetup.jpg" width="448" height="101"></p>
<p>First we have to set up the data. We begin by generating four URIs for the new resources. </p>
<pre class="input">    public static void example19() throws Exception {<br>        AGRepositoryConnection conn = example1(false);<br>        ValueFactory f = conn.getValueFactory();<br>        URI robert = f.createURI(&quot;http://example.org/people/robert&quot;);<br>        URI roberta = f.createURI(&quot;http://example.org/people/roberta&quot;);<br>        URI bob = f.createURI(&quot;http://example.org/people/bob&quot;);<br>        URI bobby = f.createURI(&quot;http://example.org/people/bobby&quot;);</pre>
The next step is to create URIs for the predicates we'll need (<em>name</em> and <em>child</em>), plus one for the Person class. <br>
<pre class="input">        URI name = f.createURI(&quot;http://example.org/ontology/name&quot;);<br>        URI fatherOf = f.createURI(&quot;http://example.org/ontology/fatherOf&quot;);<br>        URI person = f.createURI(&quot;http://example.org/ontology/Person&quot;);</pre>
The names of the four people will be literal values. <br>
<pre class="input">        Literal bobsName = f.createLiteral(&quot;Bob&quot;);<br>        Literal bobbysName = f.createLiteral(&quot;Bobby&quot;);<br>        Literal robertsName = f.createLiteral(&quot;Robert&quot;);<br>        Literal robertasName = f.createLiteral(&quot;Roberta&quot;);</pre>
<p>Robert, Bob and the children are all instances of class Person.&nbsp; It is good practice to identify all resources by an rdf:type link to a class.</p>
<pre class="input">        conn.add(robert, RDF.TYPE, person);<br>        conn.add(roberta, RDF.TYPE, person);<br>        conn.add(bob, RDF.TYPE, person);<br>        conn.add(bobby, RDF.TYPE, person);</pre>
The four people all have literal names. <br>
<pre class="input">        conn.add(robert, name, robertsName);<br>        conn.add(roberta, name, robertasName);<br>        conn.add(bob, name, bobsName);<br>        conn.add(bobby, name, bobbysName);</pre> 
Robert and Bob have links to the child resources:
<br>
<pre class="input">        // robert has a child<br>        conn.add(robert, fatherOf, roberta);<br>        // bob has a child<br>        conn.add(bob, fatherOf, bobby);</pre> 
<h3>SameAs</h3>
<p>Now that the basic resources and relations are in place, we'll seed the triple store with a statement that &quot;Robert is the same as Bob,&quot; using the <strong>owl:sameAs</strong> predicate.&nbsp; The AllegroGraph inference engine recognizes the semantics of owl:sameAs, and automatically infers that Bob and Robert share the same attributes.&nbsp; Each of them originally had one child.&nbsp; When inference is turned on, however, they each have two children.&nbsp; </p>
<p><img src="inferenceSaveAs.jpg" width="459" height="182"></p>
<p>Note that SameAs does not combine the two resources.&nbsp; Instead it links each of the two resources to all of the combined children.&nbsp; The red links in the image are &quot;inferred&quot; triples.&nbsp; They have been deduced to be true, but are not actually present in the triple store. </p>
<p>This is the critical link that tells the inference engine to regard Bob and Robert as the same resource. </p>
<pre class="input">        conn.add(bob, OWL.SAMEAS, robert);</pre>
This is a simple getStatements() search asking for the children of Robert, with inference turned OFF. &quot;Inference&quot; <br>
is the fifth parameter to getStatements(), defaulting to &quot;False&quot;. <br>
<pre class="input">        println(&quot;/nChildren of Robert, inference OFF&quot;);<br>        printRows( conn.getStatements(robert, fatherOf, null, false) );</pre> 
<p>The search returns one triple, which is the link from Robert to his direct child, Roberta. </p>
<pre class="output">Children of Robert, inference OFF<br>(http://example.org/people/robert, http://example.org/ontology/fatherOf, http://example.org/people/roberta) [null]</pre>
<p>This is a getStatements() search with inference turned ON.&nbsp; This time we added the fifth parameter, True, to getStatements(). This turns on the inference engine. </p>
<pre class="input">        println(&quot;/nChildren of Robert, inference ON&quot;);<br>        printRows( conn.getStatements(robert, fatherOf, null, true) );</pre>
<pre class="output">Children of Robert, inference ON<br>(http://example.org/people/robert, http://example.org/ontology/fatherOf, http://example.org/people/roberta) [null]<br>(http://example.org/people/robert, http://example.org/ontology/fatherOf, http://example.org/people/bobby) [null]</pre>
<p>Note that with inference ON, Robert suddenly has two children because Bob's child has been included.&nbsp; Also note that the final triple (robert hasChild bobby) has been inferred.&nbsp; The inference engine has determined that this triple logically must be true, even though it does not appear in the repository. </p>
<h3>InverseOf</h3>
<p>We can reuse the Robert family tree to see how the inference engine can deduce the presence of inverse relationships. </p>
<p>Up to this point in this tutorial, we have created new predicates simply by creating a URI and using it in the predicate position of a triple.&nbsp; This time we need to create a predicate<em> resource</em> so we can set an attribute of that resource.&nbsp; We're going to declare that the <strong>hasFather</strong> predicate is the <strong>owl:inverseOf</strong> the existing fatherOf predicate. </p>
<p>The first step is to remove the owl:sameAs link, because we are done with it. </p>
<pre class="input">        conn.remove(bob, OWL.SAMEAS, robert);</pre>
<p>We'll need a URI for the new hasFather predicate:</p>

<pre class="input">        URI hasFather = f.createURI(&quot;http://example.org/ontology/hasFather&quot;);</pre>
<p>This is the line where we create a predicate resource.&nbsp; It is just a triple that describes a property of the predicate.&nbsp; The hasFather predicate is the inverse of the fatherOf predicate: </p>

<pre class="input">        conn.add(hasFather, OWL.INVERSEOF, fatherOf);</pre>
<p>First, we'll search for hasFather triples, leaving inference OFF to show that there are no such triples in the repository: </p>

<pre class="input">        println(&quot;/nPeople with fathers, inference OFF&quot;);<br>        printRows( conn.getStatements(null, hasFather, null, false) );</pre>
<pre class="output">People with fathers, inference OFF<br></pre>
<p>Now we'll turn inference ON.&nbsp; This time, the AllegroGraph inference engine discovers two &quot;new&quot; hasFather triples. </p>
<pre class="input">        println(&quot;/nPeople with fathers, inference ON&quot;);<br>        printRows( conn.getStatements(null, hasFather, null, true) );</pre>
<pre class="output">People with fathers, inference ON<br>(http://example.org/people/roberta, http://example.org/ontology/hasFather, http://example.org/people/robert) [null]<br>(http://example.org/people/bobby, http://example.org/ontology/hasFather, http://example.org/people/bob) [null]</pre>
<p>Both of these triples are inferred by the inference engine.</p>
<h3>SubPropertyOf</h3>
<p>Invoking inference using the <strong>rdfs:subPropertyO</strong>f predicate lets us &quot;combine&quot; two predicates so they can be searched as one.&nbsp; For instance, in our Robert/Bob example, we have explicit fatherOf relations.&nbsp; Suppose there were other resources that used a parentOf relation instead of fatherOf.&nbsp; By making fatherOf a subproperty of parentOf, we can search for parentOf triples and automatically find the fatherOf triples at the same time. </p>
<p>First we should remove the owl:inverseOf relation from the previous example. We don't have to, but it keeps things simple. </p>
<pre class="input">       conn.remove(bob, OWL.SAMEAS, robert);</pre>
<p>We'll need a parentOf URI to use as the new predicate.&nbsp; Then we'll add a triple saying that fatherOf is an rdfs:subPropertyOf the new predicate, parentOf:</p>
<pre class="input">        URI parentOf = f.createURI(&quot;http://example.org/ontology/parentOf&quot;);<br>        conn.add(fatherOf, RDFS.SUBPROPERTYOF, parentOf);</pre>
<p>If we now search for parentOf triples with inference OFF, we won't find any. No such triples exist in the repository. </p>
<pre class="input">        println(&quot;/nPeople with parents, inference OFF&quot;);<br>        printRows( conn.getStatements(null, parentOf, null, false) );</pre>
<pre class="output">People with parents, inference OFF

</pre>
<p>With inference ON, however, AllegroGraph infers two new triples: </p>
<pre class="input">        println(&quot;/nPeople with parents, inference ON&quot;);<br>        printRows( conn.getStatements(null, parentOf, null, true) );</pre>
<pre class="output">People with parents, inference ON<br>(http://example.org/people/robert, http://example.org/ontology/parentOf, http://example.org/people/roberta) [null]<br>(http://example.org/people/bob, http://example.org/ontology/parentOf, http://example.org/people/bobby) [null]</pre>
<p>The fact that two fatherOf triples exist means that two correponding parentOf triples must be valid.&nbsp; There they are.</p>
<p>Before setting up the next example, we should clean up:</p>
<pre class="input">        conn.remove(fatherOf, RDFS.SUBPROPERTYOF, parentOf);</pre>
<h3>Domain and Range</h3>
<p>When you declare the domain and range of a predicate, the AllegroGraph inference engine can infer the rdf:type of resources found in the subject and object positions of the triple.&nbsp; For instance, in the triple &lt;<em>subject</em>, fatherOf, <em>object</em>&gt; we know that the <em>subject</em> is always an instance of class Parent, and the <em>object</em> is always an instance of class Child.&nbsp;</p>
<p>In RDF-speak, we would say that the <strong>domain</strong> of the fatherOf predicate is rdf:type Parent.&nbsp; The <strong>range</strong> of fatherOf is rdf:type Child.&nbsp; </p>
<p>This lets the inference engine determine the rdf:type of every resource that participates in a fatherOf relationship.&nbsp; </p>
<p>We'll need two new classes, Parent and Child.&nbsp; Note that RDF classes are always capitalized, just as predicates are always lowercase.</p>
<pre class="input">        URI parent = f.createURI(&quot;http://example.org/ontology/Parent&quot;);<br>        URI child = f.createURI(&quot;http://exmaple.org/ontology/Child&quot;);</pre>
<p>Now we add two triples defining the domain and rage of the fatherOf predicate: </p><pre class="input">        conn.add(fatherOf, RDFS.DOMAIN, parent);<br>        conn.add(fatherOf, RDFS.RANGE, child);</pre>
<p>Now we'll search for resources of rdf:type Parent.&nbsp; The inference engine supplies the appropriate triples: </p>
<pre class="input">        println(&quot;/nWho are the parents?  Inference ON.&quot;);<br>        printRows( conn.getStatements(null, RDF.TYPE, parent, true) );</pre>
<pre class="output">Who are the parents?  Inference ON.<br>(http://example.org/people/robert, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/ontology/Parent) [null]<br>(http://example.org/people/bob, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/ontology/Parent) [null]</pre>
<p>Bob and Robert are parents.&nbsp; Who are the children? </p>
<pre class="input">        println(&quot;/nWho are the children?  Inference ON.&quot;);<br>        printRows( conn.getStatements(null, RDF.TYPE, child, true) );<br>        conn.close();</pre>
<pre class="output">Who are the children?  Inference ON.
(&lt;http://example.org/people/bobby&gt;, &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;, &lt;http://exmaple.org/ontology/Child&gt;)
(&lt;http://example.org/people/roberta&gt;, &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;, &lt;http://exmaple.org/ontology/Child&gt;)</pre>
<p>Bobby and Roberta are the children. &nbsp;  </p>
<!--
<h2 id="Geospatial Search">Geospatial Search (example20())&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>AllegroGraph provides the ability to locate resources within a geospatial coordinate system. You can set up either a flat (X,Y Cartesian) or spherical (latitude, longitude) system. The systems are two-dimensional only. (There is no Z or altitude dimension available). </p>
<p>The purpose of the geospatial representation is to efficiently find all entities that are located within a specific circular, rectangular or polygonal area. </p>
<h3>Cartesian System </h3>
<p>A Cartesian system is a flat (X,Y) plane. Locations are designated by (X,Y) pairs. At this time, AllegroGraph does not support real-world measurement units (km, miles, latitude, etc.,) in the Cartesian system. </p>
<p>The first example uses a Cartesian (X,Y) system that is 100 units square, and contains three people located at various points along the X = Y diagonal.</p>
<p><img src="gepCartesian.jpg" width="417" height="333"> </p>
<p>The example is in the function example20(). After establishing a connection, it begins by creating URIs for the three people.</p>
<pre class="input">    exns = &quot;http://example.org/people/&quot;<br>    conn.setNamespace('ex', exns)<br>    alice = conn.createURI(exns, &quot;alice&quot;)<br>    bob = conn.createURI(exns, &quot;bob&quot;)<br>    carol = conn.createURI(exns, &quot;carol&quot;)</pre>
<p>Then we have the connection object generate a rectangular coordinate system for us to use. A rectangular (Cartesian) system can be used to represent anything that can be plotted using (X,Y) coordinates, such as the location of transistors on a silicon chip. </p>
<pre>    conn.createRectangularSystem(scale=10, xMax=100, yMax=100) 
</pre>
<p>The size of the coordinate system is determined by the <strong>xMin, xMax, yMin</strong> and <strong>yMax</strong> parameters. The minimum values default to zero, so this system is 0 to 100 in the X dimension, and 0 to 100 in the Y dimension. </p>
<p>The <strong>scale</strong> parameter influences how the coordinate data is stored and retrieved, and impacts search performance. The  task is to locate the people who are within a specific region. As a rule of thumb, set the scale parameter to approximately the same value as the height (Y-axis) of your typical search region. You can be off by a factor of ten without impacting performance too badly, but if your application will search regions that are orders of magnitude different in size, you'll want to create multiple coordinate systems that are scaled for different sized search regions. In this case, our search region is about 20 units high (Y), and we have set the scale parameter to 10 units. That's close enough.</p>
<p>The next step is to create a &quot;location&quot; predicate and enter the locations of the three people. </p>
<pre class="input">    location = conn.createURI(exns, &quot;location&quot;)<br>    conn.add(alice, location, conn.createCoordinate(30,30))<br>    conn.add(bob, location, conn.createCoordinate(40, 40))<br>    conn.add(carol, location, conn.createCoordinate(50, 50))  
</pre>
<p>Note that the coordinate pairs need to be encapsulated in a GeoCoordinate object to facilitate indexing and retrieval, using the connection object's <strong>createCoordinate()</strong> method. </p>
<p>At this point we have a Cartesian coordinate system containing three entities at specific (X,Y) locations. The next step is to define a search region. The first example is a &quot;box&quot; that is twenty units square, with the upper left corner at position (20, 20). The <strong>createBox()</strong> method requires parameters for <strong>xMin, xMax, yMin</strong>, and <strong>yMax</strong>. </p>
<pre class="input">    box1 = conn.createBox(20, 40, 20, 40)  
</pre>
<p>The problem is to find the people whose locations lie within this box:</p>
<p><img src="geoBox1.jpg" width="412" height="330"></p>
<p>Locating the matching entities is remarkably easy to do:</p>
<pre class="input">    for r in conn.getStatements(None, location, box1) : print r 
</pre>
<p>This retrieves all the location triples whose coordinates fall within the box1 region. Here are the resulting triples:</p>
<pre class="output">(&lt;http://example.org/people/alice&gt;, &lt;http://example.org/people/location&gt;, 
&quot;+30.000000004656613+30.000000004656613&quot;^^&lt;http://franz.com/ns/allegrograph/3.0/geospatial/cartesian/0.0/100.0/0.0/100.0/1.0&gt;)<br>(&lt;http://example.org/people/bob&gt;, &lt;http://example.org/people/location&gt;, 
&quot;+39.999999990686774+39.999999990686774&quot;^^&lt;http://franz.com/ns/allegrograph/3.0/geospatial/cartesian/0.0/100.0/0.0/100.0/1.0&gt;) </pre>
<p>AllegroGraph has located Alice and Bob, as expected. Note that Bob was exactly on the corner of the search area, showing that the boundaries are inclusive. </p>
<p>We can also find all objects within a circle with a known center and radius. Circle1 is centered at (35, 35) and has a radius of 10 units.</p>
<pre class="input">    circle1 = conn.createCircle(35, 35, radius=10)   
</pre>
<p><img src="geoCircle1.jpg" width="415" height="333"></p>
<p>A search within circle1 finds Alice and Bob again:</p>
<pre class="input">    for r in conn.getStatements(None, location, circle1) : print r 
</pre>
<pre class="output">(&lt;http://example.org/people/alice&gt;, &lt;http://example.org/people/location&gt;, 
&quot;+30.000000004656613+30.000000004656613&quot;^^&lt;http://franz.com/ns/allegrograph/3.0/geospatial/cartesian/0.0/100.0/0.0/100.0/1.0&gt;)<br>(&lt;http://example.org/people/bob&gt;, &lt;http://example.org/people/location&gt;, 
&quot;+39.999999990686774+39.999999990686774&quot;^^&lt;http://franz.com/ns/allegrograph/3.0/geospatial/cartesian/0.0/100.0/0.0/100.0/1.0&gt;) </pre>
<p>AllegroGraph can also locate points that lie within an irregular polygon. Just tell AllegroGraph the vertices of the polygon:</p>
<pre class="input">    polygon1 = conn.createPolygon([(10,40), (50,10), (35,40), (50,70)]) 
</pre>
<p><img src="geoPolygon1.jpg" width="423" height="330"></p>
<p>When we ask what people are within polygon1, AllegroGraph finds Alice.</p>
<pre class="input">    for r in conn.getStatements(None, location, polygon1) : print r 
</pre>
<pre class="output">(&lt;http://example.org/people/alice&gt;, &lt;http://example.org/people/location&gt;, 
&quot;+30.000000004656613+30.000000004656613&quot;^^&lt;http://franz.com/ns/allegrograph/3.0/geospatial/cartesian/0.0/100.0/0.0/100.0/1.0&gt;)</pre>
<h3>Spherical System</h3>
<p>A spherical coordinate system projects (X,Y) locations on a spherical surface, simulating locations on the surface of the earth. AllegroGraph supports the usual units of latitude and longitude in the spherical system. The default unit of distance is the kilometer (km). (These functions presume that the sphere is the size of the planet earth. For spherical coordinate systems of other sizes, you will have to work with the Lisp radian functions that underlie this interface.)</p>
<p><img src="geoWorld.jpg" width="602" height="340"></p>
<p>To establish a global coordinate system, use the connection object's createLatLongSystem() method. </p>
<pre class="input">    latLongGeoType = conn.createLatLongSystem(scale=5, unit='degree')</pre>
<p>Once again, the <strong>scale</strong> parameter is an estimate of the size of a typical search area, in the longitudinal direction this time. The default unit is the degree. For this system, we expect a typical search to cover about five degrees in the east-west direction. Actual search regions may be as much as ten times larger or smaller without significantly impacting performance. If the application will use search regions that are significantly larger or smaller, then you will want to create multiple coordinate systems that have been optimized for different scales. </p>
<p>First we set up the resources for the entities within the spherical system. We'll need these subject URIs:</p>
<pre class="input">    amsterdam = conn.createURI(exns, &quot;amsterdam&quot;)<br>    london = conn.createURI(exns, &quot;london&quot;)<br>    sanfrancisto = conn.createURI(exns, &quot;sanfrancisco&quot;)<br>    salvador = conn.createURI(exns, &quot;salvador&quot;)     
</pre>
<p>Then we'll need a <strong>geolocation</strong> predicate to describe the lat/long coordinates of each entity.</p>
<pre class="input">    location = conn.createURI(exns, &quot;geolocation&quot;)</pre>
<p>Now we can create the entities by asserting a geolocation for each one. Note that the coordinates have to be encapsulated in coordinate objects: </p>
<pre class="input">    conn.add(amsterdam, location, conn.createCoordinate(52.366665, 4.883333))<br>    conn.add(london, location, conn.createCoordinate(51.533333, -0.08333333))<br>    conn.add(sanfrancisto, location, conn.createCoordinate(37.783333, -122.433334)) <br>    conn.add(salvador, location, conn.createCoordinate(13.783333, -88.45))  </pre>
<p>The coordinates are decimal degrees. Northern latitudes and eastern longitudes are positive. </p>
<p>The next step is to create a box-shaped region, so we can see what entities lie within it. </p>
<pre class="input">    box2 = conn.createBox( 25.0, 50.0, -130.0, -70.0) 
</pre>
<p>This region corresponds roughly to the contiguous United States. </p>
<p><img src="geoBox2.jpg" width="634" height="361"></p>
<p>Now we retrieve all the triples located within the search region:</p>
<pre class="input">    for r in conn.getStatements(None, location, box2) : print r     
</pre>
<p>AllegroGraph has located San Francisco:</p>
<pre class="output">(&lt;http://example.org/people/sanfrancisco&gt;, &lt;http://example.org/people/geolocation&gt;,
&quot;+374659.49909-1222600.00212&quot;^^&lt;http://franz.com/ns/allegrograph/3.0/geospatial/
spherical/degrees/-180.0/180.0/-90.0/90.0/5.0&gt;) 
</pre>
<p>This time let's search for entities within 2000 kilometers of Mexico City, which is located at 19.3994 degrees north latitude, -99.08 degrees west longitude. </p>
<pre class="input">    circle2 = conn.createCircle(19.3994, -99.08, 2000, unit='km')</pre>
<p><img src="geoCircle2.jpg" width="630" height="365"></p>
<pre class="input">    for r in conn.getStatements(None, location, circle2) : print r</pre>
<pre class="output">(&lt;http://example.org/people/salvador&gt;, &lt;http://example.org/people/geolocation&gt;, 
&quot;+134659.49939-0882700&quot;^^&lt;http://franz.com/ns/allegrograph/3.0/geospatial/spherical/degrees/-180.0/180.0/-90.0/90.0/5.0&gt;)</pre>
<p>And AllegroGraph returns the triple representing El Salvador. </p>
<p>In the next example, the search area is a triangle roughly enclosing the United Kingdom:</p>
<pre class="input">    polygon2 = conn.createPolygon([(51.0, 2.00),(60.0, -5.0),(48.0,-12.5)])
</pre>
<p><em><img src="geoPolygon2.jpg" width="631" height="385"> </em></p>
<p>We ask AllegroGraph to find all entities within this triangle:</p>
<pre class="input">    for r in conn.getStatements(None, location, polygon2) : print r 
</pre>
<pre class="output">(&lt;http://example.org/people/london&gt;, &lt;http://example.org/people/geolocation&gt;, 
&quot;+513159.49909-0000459.99970&quot;^^&lt;http://franz.com/ns/allegrograph/3.0/geospatial/spherical/degrees/-180.0/180.0/-90.0/90.0/5.0&gt;)</pre>
<p>AllegroGraph returns the location of London, but not the nearby Amsterdam.</p>
<h2 id="Social Network Analysis">Social Network Analysis  (example21())&nbsp;&nbsp;&nbsp;<a class="returnlink" href="#Contents">Return to Top</a></h2>
<p>AllegroGraph includes sophisticated algorithms for social-network analysis (SNA). It can examine an RDF graph of relationships among people (or similar entities, such as businesses) and discover:</p>
<ul>
  <li>Cliques of mutually-supporting individuals.</li>
  <li>The importance of a person within a clique. </li>
  <li>Paths from one individual to another.</li>
  <li>Bottlenecks where information flow might be controlled or break down. </li>
</ul>
<p>This section has multiple subsections:</p>
<ul>
  <li><a href="#Example Network">Example Network</a></li>
  <li><a href="#Setting Up the Example">Setting Up the Example</a></li>
  <li><a href="#Creating SNA Generators">Creating SNA Generators</a></li>
    <li><a href="#Creating Neighbor Matrices">Creating Neighbor Matrices</a></li>
    <li><a href="#Deleting Generators and Matrices">Deleting Generators and Matrices</a></li>
    <li><a href="#SNA Search - Ego Group">SNA Search - Ego Group</a></li>
    <li><a href="#SNA Search - Path from A to B">SNA Search - Path from A to B</a></li>
    <li><a href="#Graph Measures">Graph Measures</a></li>
    <li><a href="#Cliques">Cliques</a></li>
    <li><a href="#Actor Centrality">Actor Centrality</a></li> 
</ul>
<p>Most (but not all) of AllegroGraph's SNA features can be accessed from Java. We access them in multiple ways:</p>
<ul>
  <li>The Java API to AllegroGraph contains setup functions that let you create an SNA environment ready for queries.</li>
  <li>From Java, we can issue Prolog queries to AllegroGraph. Some of the SNA functions have Prolog equivalents that can be called directly from a query. These are explored in the sections below. </li>
  <li>Within a Prolog query, we can open a window into Lisp and reach for the AllegroGraph's Lisp SNA functions. </li>
</ul>
<h3 id="Example Network">Example Network</h3>
<p>The example file for this exercise is <strong>lesmis.rdf</strong>. It contains resources representing 80 characters from Victor Hugo's <em>Les Miserables</em>, a novel about Jean Valjean's search for redemption in 17th-century Paris. </p>
<p>The raw data behind the model measured the strength of relationships by counting the number of book chapters where two characters were both present. The five-volume novel has 365 chapters, so it was possible to create a relationship network that had some interesting features. This is a partial display of the graph in <a href="http://www.franz.com/agraph/gruff/index.lhtml">Franz's Gruff graphical browser</a>. </p>
<p><img src="lesmismap.jpg" width="768" height="426"> </p>
<p>There are four possible relationships between any two characters. </p>
<ul>
  <li><strong>No direct connection</strong>. (They never appeared in the same chapter.) AllegroGraph can locate indirect connections through their mutual acquaintances.</li>
  <li><span class="style1">Barely knows</span>. The characters barely know each other.</li>
  <li><span class="style2">Knows</span>. The two characters appear together in 15 or more chapters.</li>
  <li><span class="style3">Knows well</span>. The two characters appear together in 25 or more chapters. </li>
</ul>
<p>(The Gruff illustrations were made from a parallel repository in which the resources were altered to display the character's name in the graph node rather than his URI. That file is called<strong> lemisNames.rdf</strong>.) </p>
<h3 id="Setting Up the Example">Setting Up the Example</h3>
<p>The SNA examples are in function <strong>example21() </strong>in <strong>tutorial_examples_40.java</strong>. This exercise begins by creating a <a href="#Transaction">dedicated session</a> for the SNA Prolog queries to operation within. These are the same initializing steps we have used in previous examples, plus <strong>conn.openDedicated()</strong> to create a dedicated connection. </p>
<pre class="input">    server = AllegroGraphServer(AG_HOST, AG_PORT, 'username', 'password')<br>    catalog = server.openCatalog('scratch')  <br>    myRepository = catalog.getRepository(&quot;agraph_test&quot;, Repository.RENEW)<br>    myRepository.initialize()<br>    conn = myRepository.getConnection()<br>    conn.openDedicated() # SNA requires dedicated session.
</pre>
<p>The next step is to load the lesmis.rdf file.</p>
<pre class="input">    path1 = "./lesmis.rdf"
    print "Load Les Miserables triples."
    conn.addFile(path1, None, format=RDFFormat.RDFXML);
</pre>

<p>There are three predicates of interest in the Les Miserables repository. We need to create their URIs and bind them for later use. These are the <strong>knows, barely_knows,</strong> and <strong>knows_well</strong> predicates. </p>
<pre class="input">    # Create URIs for relationship predicates.
    lmns = "http://www.franz.com/lesmis#"
    conn.setNamespace('lm', lmns)
    knows = conn.createURI(lmns, "knows")
    barely_knows = conn.createURI(lmns, "barely_knows")
    knows_well = conn.createURI(lmns, "knows_well")
</pre>
<p>We need to bind URIs for two characters: Valjean and Bossuet.  Any analysis of <em>Les Miserables</em> will involve Valjean. Bossuet is someone who &quot;barely knows&quot; Valjean, but the two characters are linked through multiple characters who are more strongly connected. We will ask AllegroGraph to find paths from Valjean to Bossuet.</p>
<pre class="input">    # Create URIs for some characters.
    valjean = conn.createURI(lmns, "character11")
    bossuet = conn.createURI(lmns, "character64")
</pre>
<p>We also need to set the rule language. </p>
<pre class="input">
    conn.setRuleLanguage(QueryLanguage.PROLOG)</pre>
<h3 id="Creating SNA Generators">Creating SNA Generators</h3>
<p>The SNA functions use &quot;generators&quot; to describe the relationships  we want to analyze. A generator encapsulates a list of predicates to use in social network analysis. It also describes the directions in which each predicate is interesting. </p>
<p>In an RDF graph, two resources are linked by a single triple, sometimes called a &quot;resource-valued predicate.&quot; This triple has a resource URI in the <em>subject</em> position, and a different one in the <em>object</em> position. For instance:</p>
<pre>    (&lt;Cosette&gt;, knows_well, &lt;Valjean&gt;)</pre>
<p>This triple  is a one-way link unless we tell the generator to treat it as bidirectional. This is frequently necessary in RDF data, where inverse relations are often implied but not explicitly declared as triples. </p>
<p>For this exercise, we will declare three generators:</p>
<ul>
  <li>&quot;intimates&quot; uses <strong>knows_well</strong> as a bidirectional predicate.</li>
  <li>&quot;associates&quot; uses <strong>knows</strong> and <strong>knows_well</strong> as bidirectional predicates.</li>
  <li>&quot;everyone&quot; uses <strong>barely_knows</strong>, <strong>knows</strong>, and <strong>knows_well</strong> as bidirectional predicates. </li>
</ul>
<p>"Intimates" takes a narrow view of persons who know one another quite well. "Associates" follows both strong and medium relationships. "Everyone" follows all relationships, even the weak ones. This provides three levels of resolution for our analysis.</p>
<p>The connection object's <strong>registerSNAGenerator()</strong> method asks for a generator name (any label), and then for one or more predicates of interest. Each predicate should be assigned to the &quot;subjectOf&quot; direction, the &quot;objectOf&quot; direction, or the &quot;undirected&quot; direction (both ways at once). In addition, you may specify a &quot;generator query,&quot; which is a Prolog &quot;select&quot; query that lets you be more specific about the links you want to analyze. </p>
<p>&quot;Intimates&quot; follows &quot;knows_well&quot; links only, but it treats them as bidirectional. If Cosette knows Valjean, then we'll assume that Valjean knows Cosette. </p>
<pre class=input>    conn.registerSNAGenerator(&quot;intimates&quot;, subjectOf=None, objectOf=None, <br>        undirected=knows_well, generator_query=None)</pre>
<p>&quot;Associates&quot; follows &quot;knows&quot; and &quot;knows_well&quot; links. </p>
<pre class="input">
    conn.registerSNAGenerator(&quot;associates&quot;, subjectOf=None, objectOf=None, <br>        undirected=[knows, knows_well], generator_query=None)
</pre>
<p>&quot;Everyone&quot; follows all three relationship links. </p>
<pre class="input">    conn.registerSNAGenerator(&quot;everyone&quot;, subjectOf=None, objectOf=None, <br>        undirected=[knows, knows_well, barely_knows], 
        generator_query=None)</pre>
<p>&nbsp;</p>		

<h3 id="Creating Neighbor Matrices">Creating Neighbor Matrices</h3>
<p>A generator provides a powerful and flexible tool for examining a graph, but it performs repeated queries against the repository in order to extract the subgraph appropriate to your query. If your data is static, the generator will extract the same subgraph each time you use it. It is better to run the generator once and store the results for quick retrieval. </p>
<p>That is the purpose of  a &quot;neighbor matrix.&quot; This is a persistent, in-memory cache of a generator's output. You can substitute the matrix for the generator in AllegroGraph's SNA functions. </p>
<p>The advantage of using a matrix instead of a generator is a many-fold increase in speed. This benefit is especially visible if you are searching for paths between two nodes in your graph. The exact difference in speed is difficult to estimate because there can be complex trade-offs and scaling issues to consider, but it is easy to try the experiment and observe the effect. </p>
<p>To create a matrix, use the connection object's <strong>registerNeighborMatrix()</strong> method. You must supply a matrix name (any symbol), the name of the generator, the URI of a resource to serve as the starting point, and a maximum depth. The idea is to place limits on the subgraph so that the search algorithms can operate in a restricted space rather than forcing them to analyze the entire repository. </p>
<p>In the following excerpt, we are creating four matrices to match the four generators we created. In this example, &quot;matrix1&quot; is the matrix for generator &quot;intimates,&quot; and so forth. </p>
<pre class="input">    conn.registerNeighborMatrix(&quot;matrix1&quot;, &quot;intimates&quot;, valjean, max_depth=2)<br>    conn.registerNeighborMatrix(&quot;matrix2&quot;, &quot;associates&quot;, valjean, max_depth=2)<br>    conn.registerNeighborMatrix(&quot;matrix3&quot;, &quot;everyone&quot;, valjean, max_depth=2)</pre>
<p>A matrix is a static snapshot of the output of a generator.  If your data is dynamic, you should regenerate the matrix at intervals.</p>

<h3 id="Deleting Generators and Matrices">Deleting Generators and Matrices</h3>
<p>There is no direct way to delete individual matrices and generators, but closing the dedicated session frees all of the resources formerly used by all of the objects and structures that were created there. </p>

<h3 id="SNA Search - Ego Group"><strong>SNA Search - Ego Group</strong></h3>
<p>Our first search will enumerate Valjean's &quot;ego group members.&quot; This is the set of nodes (characters) that can be found by following the interesting predicates out from Valjean's node of the graph to some specified depth. We'll use the &quot;associates&quot; generator (&quot;knows&quot; and &quot;knows_well&quot;) to specify the predicates, and we'll impose a depth limit of one link. This is the group we expect to find:</p>
<p><img src="snaEgoGroup.jpg" width="599" height="203"></p>
<p>The following Java code sends a Prolog query to AllegroGraph and returns the result to Java. </p>
<pre class="input">    print "Valjean's ego group (using associates)."
    queryString = """
    (select (?member ?name)
      (ego-group-member !lm:character11 1 associates ?member)
      (q ?member !dc:title ?name))
      """
    tupleQuery = conn.prepareTupleQuery(QueryLanguage.PROLOG, queryString)
    result = tupleQuery.evaluate();
    print &quot;Found %i query results&quot; % len(result)      <br>    for bindingSet in result:
        p = bindingSet.getValue("member")
        n = bindingSet.getValue("name")
        print "%s %s" % (p, n)
</pre>
<p>This is the iconic block of code that is repeated in the SNA examples, below, with minor variations in the display of bindingSet values. To save virtual trees, we'll focus more tightly on the Prolog query from this point on:</p>
<pre class="input">    (select (?member ?name)
      (ego-group-member !lm:character11 1 associates ?member)
      (q ?member !dc:title ?name))
</pre>
<p>In this example, <strong>ego-group-member</strong> is an AllegroGraph SNA function that has been adapted for use in Prolog queries. There is a list of such functions on the <a href="http://www.franz.com/agraph/support/documentation/current/reference-guide.html#sna">AllegroGraph documentation reference page</a>. </p>
<p>The query will execute <strong>ego-group-member</strong>, using Valjean (character11) as the starting point, following the predicates described in &quot;associates,&quot; to a depth of 1 link. It binds each matching node to <strong>?member</strong>. Then, for each binding of ?member, the query looks for the member's <strong>dc:title</strong> triple, and binds the member's <strong>?name</strong>.  The query returns multiple results, where each result is a (?member ?name) pair. The result object is passed back to Java, where we can iterate over the results and print out their values. </p>
<p>This is the output of the example:</p>
<pre class="output">Valjean's ego group (using associates).
Found 8 query results
&lt;http://www.franz.com/lesmis#character27&gt; "Javert"
&lt;http://www.franz.com/lesmis#character24&gt; "MmeThenardier"
&lt;http://www.franz.com/lesmis#character25&gt; "Thenardier"
&lt;http://www.franz.com/lesmis#character28&gt; "Fauchelevent"
&lt;http://www.franz.com/lesmis#character11&gt; "Valjean"
&lt;http://www.franz.com/lesmis#character26&gt; "Cosette"
&lt;http://www.franz.com/lesmis#character23&gt; "Fantine"
&lt;http://www.franz.com/lesmis#character55&gt; "Marius"</pre>
<p>If you compare this list with the Gruff-generated image of Valjean's ego group, you'll see that AllegroGraph has found all eight expected nodes. You might be surprised that Valjean is regarded as a member of his <em>own</em> ego group, but that is a logical result of the definition of &quot;ego group.&quot; The ego group is the set of all nodes within a certain depth of the starting point, and certainly the starting point must be is a member of that set. </p>
<p>We can perform the same search using a neighbor matrix, simply by substituting &quot;matrix2&quot; for &quot;associates&quot; in the query:</p>
<pre class="input">    (select (?member ?name)
      (ego-group-member !lm:character11 1 <strong>matrix2</strong> ?member)
      (q ?member !dc:title ?name))
</pre>
<p>This produces the same set of result nodes, but under the right circumstances the matrix would run a lot faster than the generator. </p>
<p>This variation returns Valjean's ego group as a single list:</p>
<pre class="input">    (select ?group
      (ego-group !lm:character11 1 associates ?group))</pre>
The result in the Java interaction window is:
<pre class="output">Valjean's ego group in one list depth 1 (using associates).
"({character27} {character24} {character25} {character28} {character11}
 {character26} {character23} {character55})"</pre>
<h3 id="SNA Search - Path from A to B">SNA Search - Path from A to B</h3>
<p>In the following examples, we explore the graph for the shortest path from Valjean to Bossuet, using the three generators to place restrictions on the quality of the path. These are the relevant paths between these two characters:</p>
<img src="pathsValBos.jpg" width="913" height="254"> 
<p>Our first query asks AllegroGraph to use <strong>intimates</strong> to find the shortest possible path between Valjean and Bossuet that is composed entirely of &quot;knows_well&quot; links. Those would be the green arrows in the diagram above. The <strong>breadth-first-search-paths</strong> function asks for a start node and an end node, a generator, an optional maximum path length, and a variable to bind to the resulting path(s). </p>
<pre class="input">    (select ?path
      (breadth-first-search-paths !lm:character11 !lm:character64 intimates 10 ?path))</pre>
<p>It is easy to examine the diagram and see that there is no such path. Valjean and Bossuet are not well-acquainted, and do not have any chain of well-acquainted mutual friends. AllegroGraph lets us know that.</p>
<pre class="output">Shortest breadth-first path connecting Valjean to Bossuet using intimates.
Found 0 query results</pre>
<p>This time we'll broaden the criteria. What is the shortest path from Valjean to Bossuet, using <strong>associates</strong>? We can follow either &quot;knows_well&quot; or &quot;knows&quot; links across the graph. Those are the green and the blue links in the diagram. </p>
<pre class="input">(select ?path
      (breadth-first-search-paths !lm:character11 !lm:character64 associates 10 ?path))</pre>
<p>Although there are multiple such paths, there are only two that are &quot;shortest&quot; paths. </p>
<pre class="output">Shortest breadth-first path connecting Valjean to Bossuet using associates.
Found 2 query results
"({character11} {character55} {character62} {character64})"
"({character11} {character55} {character58} {character64})"</pre>
<p>These are the paths &quot;Valjean &gt; Marius &gt; Enjolras &gt; Bossuet&quot; and &quot;Valjean &gt; Marius &gt; Courfeyrac &gt; Bossuet.&quot; AllegroGraph returns two paths because they are of equal length. If one of the paths had been shorter, it would have returned only the short path. </p>
<p>Our third query asks for the shortest path from Valjean to Bossuet using <strong>everyone</strong>, which means that &quot;barely-knows&quot; links are permitted in addition to &quot;knows&quot; and &quot;knows_well&quot; links. </p>
<pre class="input">    (select ?path
      (breadth-first-search-paths !lm:character11 !lm:character64 everyone 10 ?path))
</pre>
<p>This time AllegroGraph returns a single, short path:</p>
<pre class="output">Shortest breadth-first path connecting Valjean to Bossuet using everyone.
Found 1 query results
"({character11} {character64})"</pre>
<p>This is the &quot;barely-knows&quot; link directly from from Valjean to Bossuet. </p>
<p>The Prolog select query can also use <strong>depth-first-search-paths()</strong> and <strong>bidirectional-search-paths()</strong>. Their syntax is essentially identical to that shown above. </p>
<h3 id="Graph Measures">Graph Measures</h3>
<p>AllegroGraph provides several utility functions that measure the characteristics of a node, such as the number of connections it has to other nodes, and its importance as a communication path in a clique. </p>
<p>For instance, we can use the <strong>nodal-degree</strong> function to ask how many nodal neighbors Valjean has, using <strong>everyone</strong> to catalog all the nodes connected to Valjean by &quot;knows,&quot; &quot;barely_knows&quot;, and &quot;knows_well&quot; predicates. There are quite a few of them:</p>
<p><img src="allLinksValjean.jpg" width="720" height="341"> </p>
<p>The nodal-degree function requires the URI of the target node (Valjean is character11), the generator, and a variable to bind the returned value to. </p>
<pre class="input">    print &quot;\nHow many neighbors are around Valjean? (should be 36).&quot;<br>    queryString = &quot;&quot;&quot;<br>    (select ?neighbors<br>      (nodal-degree !lm:character11 everyone ?neighbors))<br>      &quot;&quot;&quot;<br>    tupleQuery = conn.prepareTupleQuery(QueryLanguage.PROLOG, queryString)<br>    result = tupleQuery.evaluate();<br>    for bindingSet in result:<br>        p = bindingSet.getValue(&quot;neighbors&quot;)<br>        print &quot;%s&quot; % (p)<br>        print &quot;%s&quot; % <strong>p.toJava()</strong></pre>
<p>Note that this function returns a string that describes an integer, which in its raw form is difficult for Java to use. We convert the raw value to a Java integer using the <strong>.toJava() </strong>method that is available to all literal values in the Java API to AllegroGraph. This example prints out both the string value and the converted number.</p>
<pre class="output">How many neighbors are around Valjean? (should be 36).
"36"^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;
36</pre>
<p>If you want to see the names of these neighbors, you can use either the <strong>ego-group-member</strong> function described earlier on this page, or the <strong>nodal-neighbors</strong> function shown below:</p>
<pre class="input">
    (select (?name)
      (nodal-neighbors !lm:character11 everyone ?member)
      (q ?member !dc:title ?name))
</pre>
<p>This example enumerates all immediate neighbors of Valjean and returns their names:
<pre class="output">Who are Valjean's neighbors? (using everyone).
"Isabeau",  "Labarre",  "Cochepaille",  "Marguerite",  "Babet",  "Woman2",  <br>"Enjolras",  "Chenildieu",  "Toussaint",  "MmeThenardier",  "Gavroche",  <br>"Bossuet",  "MotherInnocent",  "Gueulemer",  "Simplice",  "Fauchelevent",  <br>"MmeMagloire",  "Claquesous",  "Bamatabois",  "Woman1",  "Thenardier",  <br>"Marius",  "Cosette",  "MlleBaptistine",  "Montparnasse",  "MlleGillenormand",  <br>"Gervais",  "Brevet",  "Champmathieu",  "Fantine",  "Judge",  "Gillenormand",  <br>"Javert",  "MmeDeR",  "Scaufflaire",  "Myriel",  </pre>

<p>Another descriptive statistic is <strong>graph-density</strong>, which measures the density of connections within a subgraph. </p>
<p>For instance, this is Valjean's ego group with all <strong>associates</strong>  included. </p>
<p><img src="graphDensity.jpg" width="806" height="297"> </p>
<p>Only 9 of 28 possible links are in place in this subgraph, so the graph density is 0.32. The following query asks AllegroGraph to calculate this figure for Valjean's ego group:</p>
<pre class="input">
    (select ?density
      (ego-group !lm:character11 1 associates ?group)
      (graph-density ?group associates ?density))
</pre>
<p>We used the<strong> ego-group</strong> function to return a list of Valjean's ego-group members, bound to the variable <strong>?group</strong>, and then we used ?group to feed that subgraph to the <strong>graph-density</strong> function. The return value, <strong>?density</strong>, came back as a string describing a float, and had to be converted to a Java float using <strong>.toJava()</strong>.</p>
<pre class="output">Graph density of Valjean's ego group? (using associates).
"3.2142857e-1"^^&lt;http://www.w3.org/2001/XMLSchema#double&gt;
3.2142857e-1</pre>
<h3 id="Cliques">Cliques</h3>
<p>A &quot;clique&quot; is a subgraph where every node is connected to every other node by predicates specified in some generator. AllegroGraph, using everyone (&quot;knows,&quot; &quot;knows_well,&quot; and &quot;barely_knows&quot;), found that Valjean participates in 239 cliques! </p>
<p><img src="valjeanBigClique.jpg" width="859" height="301"> </p>
<p>It is counterintuitive that a &quot;clique&quot; should be composed mainly of people who &quot;barely_know&quot; each other, so let's try the same experiment using &quot;associates,&quot; which restricts the cliques to people Valjean &quot;knows&quot; or &quot;knows_well.&quot; In this case, AllegroGraph returns two cliques. One contains Valjean, Cosette, and Marius. The other contains Valjean and the Thenardiers. </p>
<p><img src="valjeanSmallCliques.jpg" width="397" height="248"> </p>
<p>This is the query that finds Valjean's &quot;associates&quot; cliques:</p>
<pre class="input">
    (select ?clique
      (clique !lm:character11 associates ?clique))
</pre>



<p>AllegroGraph returns two cliques:</p>
<pre class="output">Valjean's cliques? Should be two (using associates).
Number of cliques: 2
"({character11} {character26} {character55})"
"({character11} {character25} {character24})"</pre>
<p>The first list is the clique with Marius and Cosette. The second one represents the Thernardier clique. </p>
<h3 id="Actor Centrality">Actor Centrality </h3>
<p>AllegroGraph lets us measure the relative importance of a node in a subgraph using the <strong>actor-degree-centrality()</strong> function. For instance, it should be obvious that Valjean is very &quot;central&quot; to his own ego group (depth of one link), because he is linked directly to all other links in the subgraph. In that case he is linked to 7 of 7 possible nodes, and his actor-degree-centrality value is 7/7 = 1. </p>
<p>However, we can regenerate Valjean's ego group using a depth of 2. This adds three nodes that are not directly connected to Valjean. How &quot;central&quot; is he then?</p>
<p><img src="valjeanActorCentrality.jpg" width="875" height="303"> </p>
<p>In this subgraph, Valjean's actor-degree-centrality is 0.70, meaning that he is connected to 70% of the nodes in the subgraph. </p>
<p>This example asks AllegroGraph to generate the expanded ego group, and then to measure Valjean's actor-degree-centrality:</p>
<pre class="input">
    (select (?centrality)
      (ego-group !lm:character11 2 associates ?group)
      (actor-degree-centrality !lm:character11 ?group associates ?centrality))
</pre>
<p>Note that we asked <strong>ego-group()</strong> to explore to a depth of two links, and then fed its result (<strong>?group</strong>) to <strong>actor-degree-centrality()</strong>. This is the output:</p>
<pre class="output">Valjean's centrality to his ego group at depth 2 (using associates).
"7.0e-1"^^<http://www.w3.org/2001/XMLSchema#double>
7.0e-1</pre>
<p>This confirms our expectation that Valjean's actor-degree-centrality should be 0.70 in this circumstance.</p>
<p>We can also measure actor centrality by calculating the average path length from a given node to the other nodes of the subgraph. This is called <strong>actor-closeness-centrality</strong>. For instance, we can calculate the average path length from Valjean to the ten nodes of his ego group (using associates and depth 2). Then we take the inverse of the average, so that bigger values will be &quot;more central.&quot; </p>
<p><img src="valjeanActorClosenessCentrality.jpg" width="875" height="303"> </p>
<p>The actor-closeness-centrality for Marius is 0.60, showing that Valjean is more central and important to the group than is Marius. </p>
<p>This example calculates Valjean's <strong>actor-closeness-centrality</strong> for the associates ego group of depth 2. </p>
<pre class="input">
    (select (?centrality)
      (ego-group !lm:character11 2 associates ?group)
      (actor-closeness-centrality !lm:character11 ?group associates ?centrality))
</pre>
<pre class="output">Valjean's actor-closeness-centrality to his ego group at depth 2 (using associates).
"7.692308e-1"^^&lt;http://www.w3.org/2001/XMLSchema#double&gt;
7.692308e-1</pre>
<p>That is the expected value of 0.769. </p>
<p>Another approach to centrality is to count the number of information paths that are &quot;controlled&quot; by a specific node. This is called<strong> actor-betweenness-centrality</strong>. For instance, there are 45 possible &quot;shortest paths&quot; between pairs of nodes in Valjean's associates depth-2 ego group. Valjean can act as an information valve, potentially cutting off communication on 34 of these 45 paths. Therefore, he controls 75% of the communication in the group. </p>
<p><img src="valjeanActorBetweenCentrality.jpg" width="875" height="303"></p>
<p>This example calculates Valjean's actor-betweenness-centrality:</p>
<pre class="input">
    (select (?centrality)
      (ego-group !lm:character11 2 associates ?group)
      (actor-betweenness-centrality !lm:character11 ?group associates ?centrality))
</pre>

<pre class="output">Valjean's actor-betweenness-centrality to his ego group at depth 2 (using associates).
"7.5555557e-1"^^&lt;http://www.w3.org/2001/XMLSchema#double&gt;
7.5555557e-1</pre>
<p>That's the expected result of 0.755. </p>
-->
<h2 id="Transaction">Transaction (example22())</h2>
<p>Most of the time, multiple AllegroGraph users pool triples in a common session. Their data may be segregated into multiple contexts (subgraphs) for convenience, but in fact any part of this data may be retrieved by any of the users.</p>
<p>There are situations where a little more security is required. You may open a &quot;dedicated session&quot; and populate it with triples that the other users cannot view. These triples may be searched and manipulated in the usual ways, but do not become visible to other users until you &quot;commit&quot; them. </p>
<p>In order to open a dedicated session, the user must have &quot;session&quot; privileges with AllegroGraph Server. This is an elevated level of privilege. Therefore certain features that also require an elevated level of trust are required to use dedicated sessions. For instance, Prolog rules and Social Network Analysis functions cannot be run in the common session. You must open a dedicated session in order to use them. </p>
<p>Session management makes use of a transaction model. Changes in your dedicated session remain private until you are ready to commit them to the common session. </p>
<p>&quot;Commit&quot; means to make the triples in the dedicated session visible in the common session. At the time of the commit, triples in the common session are also made visible to queries in the dedicated session. The two sessions are &quot;synched up&quot; by the commit. </p>
<p>&quot;Rollback&quot; means to discard the contents of the dedicated session. It also makes all common-session triples visible in the dedicated session. </p>
<p>&quot;Closing&quot; the dedicated session deletes all uncommitted triples, and all rules, generators and matrices that were created in the dedicated session. Rules, generators and matrices cannot be committed. They persist as long as the dedicated session persists, and are deleted when the dedicated session is closed.</p>
<p>Example example22() performs some simple data manipulations on a dedicated session to demonstrate the rollback and commit features. It begins by creating a connection to a repository (the common session), and a second connection to a dedicated session. To do that, all you need is a second connection object, and invoke its <strong>setAutoCommit()</strong> method. </p>
<pre class="input">    public static void example22() throws Exception {<br>        AGServer server = new AGServer(SERVER_URL, USERNAME, PASSWORD);<br>        AGCatalog catalog = server.getCatalog(CATALOG_ID);<br>        AGRepository myRepository = catalog.createRepository(&quot;agraph_test&quot;);<br>        myRepository.initialize();<br>        AGValueFactory vf = myRepository.getValueFactory();<br>        // Create conn1 (autoCommit) and conn2 (no autoCommit).<br>        AGRepositoryConnection conn1 = myRepository.getConnection();<br>        closeBeforeExit(conn1);<br>        AGRepositoryConnection conn2 = myRepository.getConnection();<br>        closeBeforeExit(conn2);<br>        conn1.clear();<br>        conn2.clear();<br>        conn2.setAutoCommit(false);  </pre>
<p>In this example,<strong> conn1</strong> is the common session, and <strong>conn2</strong> is the dedicated session. </p>
<p>We'll reuse the Kennedy and Les Miserables data. The Les Miserables data goes in the common session, and the Kennedy data goes in the dedicated session. </p>
<pre class="input">        String baseURI = &quot;http://example.org/example/local&quot;;<br>        conn1.add(new File(&quot;src/tutorial/lesmis.rdf&quot;), baseURI, RDFFormat.RDFXML);<br>        println(&quot;Loaded &quot; + conn1.size() + &quot; lesmis.rdf triples into conn1.&quot;);<br>        conn2.add(new File(&quot;src/tutorial/kennedy.ntriples&quot;), baseURI, RDFFormat.NTRIPLES);<br>        println(&quot;Loaded &quot; + conn2.size() + &quot; kennedy.ntriples into conn2.&quot;);</pre>
<p>The two sessions should now have independent content. When we look in the common session we should see only Les Miserables triples. The dedicated session could contain only Kennedy triples. We set up a series of simple tests similar to this one:</p>
<pre class="input">        Literal valjean = vf.createLiteral(&quot;Valjean&quot;);<br>        Literal kennedy = vf.createLiteral(&quot;Kennedy&quot;);<br>        printRows(&quot;\nUsing getStatements() on conn1 should find Valjean:&quot;,<br>                1, conn1.getStatements(null, null, valjean, false));</pre>
<p>This test looks for our friend Valjean in the common session. He should be there. This is the output:</p>
<pre class="output">Using getStatements() on conn1 should find Valjean:<br>(http://www.franz.com/lesmis#character11, http://purl.org/dc/elements/1.1/title, &quot;Valjean&quot;) [null]<br>Number of results: 1</pre>
<p>However, there should not be anyone in the common session named &quot;Kennedy.&quot; The code of the test is almost identical to that shown above, so we'll skip straight to the output.</p>
<pre class="output">Using getStatements() on conn1 should not find Kennedy:<br>Number of results: 0</pre>
<p>We should not see Valjean in the dedicated session:</p>
<pre class="output">Using getStatements() on conn2 should not find Valjean:<br>Number of results: 0</pre>
<p>There should be a Kennedy (at least one) visible in the dedicated session. (We limited the output to one match.) </p>
<pre class="output">Using getStatements() on conn2 should find Kennedy:<br>(http://www.franz.com/simple#person1, http://www.franz.com/simple#last-name, &quot;Kennedy&quot;) [null]<br>Number of results: 1</pre>
<p>The next step in the demonstration is to roll back the data in the dedicated session. This will make the Kennedy data disappear. It will also make the Les Miserables data visible in both sessions. We'll perform the same four tests, with slightly different expectations.</p>

<p>First we roll back the transaction:</p>
<pre class="input">        println(&quot;\nRolling back contents of conn2.&quot;);<br>        conn2.rollback();</pre>
<p>Valjean is still visible in the common session:</p>
<pre class="output">Using getStatements() on conn1 should find Valjean:<br>(http://www.franz.com/lesmis#character11, http://purl.org/dc/elements/1.1/title, &quot;Valjean&quot;) [null]<br>Number of results: 1</pre>
<p>There are still no Kennedys in the common session: </p>
<pre class="output">Using getStatements() on conn1 should not find Kennedys:<br>Number of results: 0</pre>
<p>There should be no Kennedys visible in the dedicated session:</p>
<pre class="output">Using getStatements() on conn2 should not find Kennedys:<br>Number of results: 0</pre>
<p>And finally, we should suddenly see Valjean in the dedicated session:</p>
<pre class="output">Using getStatements() on conn2 should find Valjean:<br>(http://www.franz.com/lesmis#character11, http://purl.org/dc/elements/1.1/title, &quot;Valjean&quot;) [null]<br>Number of results: 1</pre>
<p>The rollback has succeeded in deleting the uncommitted triples from the dedicated session. It has also refreshed or resynched the dedicated session with the common session.</p>
<p>To set up the next test, we have to reload the Kennedy triples. Then we'll perform a commit.  </p>
<pre class="input">        println(&quot;\nReload 1214 kennedy.ntriples into conn2.&quot;);<br>        conn2.add(new File(&quot;src/tutorial/kennedy.ntriples&quot;), baseURI, RDFFormat.NTRIPLES);<br>        println(&quot;\nCommitting contents of conn2.&quot;);<br>        conn2.commit();</pre>
<p>This should make both types of triples visible in both sessions. Here are the four tests:</p>
<pre class="output">Using getStatements() on conn1 should find Valjean:
(http://www.franz.com/lesmis#character11, http://purl.org/dc/elements/1.1/title, "Valjean") [null]
Number of results: 1

Using getStatements() on conn1 should find Kennedys:
(http://www.franz.com/simple#person1, http://www.franz.com/simple#last-name, "Kennedy") [null]
Number of results: 1

Using getStatements() on conn2 should find Kennedys:
(http://www.franz.com/simple#person1, http://www.franz.com/simple#last-name, "Kennedy") [null]
Number of results: 1

Using getStatements() on conn2 should find Valjean:
(http://www.franz.com/lesmis#character11, http://purl.org/dc/elements/1.1/title, "Valjean") [null]
Number of results: 1</pre>
<p>The Les Miserables triples are visible in both sessions. So too are the Kennedy triples. </p>
<p>&nbsp;</p>
<p><font color="#CCCCCC">September 28, 2009 </font></p>
<p>&nbsp;</p>
-->
<p><font color="#CCCCCC">October 26, 2009</font></p>
</body>
</html>
